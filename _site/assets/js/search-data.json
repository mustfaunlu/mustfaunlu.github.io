{"0": {
    "doc": "About app architecture",
    "title": "About app architecture",
    "content": "Bu kılavuz, sağlam, yüksek kaliteli uygulamalar oluşturmak için best practiceleri ve önerilen mimariyi kapsar. Not: Bu sayfada Android Framework ile ilgili temel bilgilere sahip olduğunuz varsayılmaktadır. Android uygulama geliştirme konusunda yeniyseniz, başlamak ve bu kılavuzda bahsedilen kavramlar hakkında daha fazla bilgi edinmek için Android Basics kursu na göz atın. Mobile app user experiences . Tipik bir Android uygulaması, activities, fragments, services, content providers, and broadcast receivers dahil olmak üzere multiple app componentler içerir. Bu uygulama componentlerinin çoğunu app manifest dosyasinda bildirirsiniz. Android işletim sistemi daha sonra uygulamanızı cihazın genel kullanıcı deneyimine nasıl entegre edeceğine karar vermek için bu dosyayı kullanır. Tipik bir Android uygulamasının multiple component içerebileceği ve kullanıcıların genellikle kısa bir süre içinde birden çok uygulamayla etkileşime girdiği göz önüne alındığında, uygulamaların farklı türde kullanıcı odaklı iş akışlarına(user-driven workflows) ve tasklere uyum sağlaması gerekir. Mobil cihazlarda kaynaklarin kısıtlı olduğunu unutmayın; bu nedenle, işletim sistemi herhangi bir zamanda yenilerine yer açmak için bazı uygulama processlerini sonlandırabilir. Bu ortamın koşulları göz önüne alındığında, uygulama componentlerinizin ayrı ayrı ve duzensiz olarak başlatılması mümkündür ve işletim sistemi veya kullanıcı bunları herhangi bir zamanda sonlandirabilir. Bu olaylar sizin kontrolünüz altında olmadığından, uygulama componentlerinizdeki herhangi bir uygulama verisini veya state’ini saklamamalı veya bellekte tutmamalısınız ve uygulama componentleriniz birbirine bağimlı olmamalıdır. Common architectural principles . Uygulama verilerini ve state’ini tutumak için uygulama componentlerini kullanmamanız gerekiyorsa,peki uygulamanızı nasıl tasarlamanız gerekir? Android uygulamalarının boyutu büyüdükçe, uygulamanın ölçeklenmesini sağlayan, uygulamanın sağlamlığını artıran ve uygulamanın test edilmesini kolaylaştıran bir mimari tanımlamak önemlidir. Bir uygulama mimarisi, uygulamanın bölümleri arasındaki sınırları ve her bir bölümün sahip olması gereken sorumlulukları tanımlar. Yukarıda belirtilen ihtiyaçları karşılamak için uygulama mimarinizi birkaç belirli ilkeyi takip edecek şekilde tasarlamanız gerekir. Separation of concerns . İzlenecek en önemli ilke, separation of concers. Tüm kodunuzu bir Activity veya Fragment’a yazmak yaygın bir hatadır. Bu UI tabanlı sınıflar yalnızca UI ve işletim sistemi interactionlarini handle eden mantığı(logic) içermelidir. Bu sınıfları olabildiğince yalın tutarak, component yaşam döngüsüyle(lifecycle) ilgili birçok sorunu önleyebilir ve bu sınıfların test edilebilirliğini kolaylastirabilirsiniz. Aktivite ve Fragment implementasyonlari uzerinde bir sahipliginiz olmadığını unutmayın; bunlar yalnızca Android işletim sistemi ile uygulamanız arasındaki sözleşmeyi temsil eden glue classlardir. İşletim sistemi, kullanıcı etkileşimlerine bağlı olarak veya düşük bellek gibi sistem koşulları nedeniyle herhangi bir zamanda bunları yok edebilir. Tatmin edici bir kullanıcı deneyimi ve daha yönetilebilir bir uygulama bakım deneyimi sağlamak için bunlara bağımlılığınızı en aza indirmek en iyisidir. Drive UI from data models . Bir diğer önemli ilke, kullanıcı arayüzünüzü(UI) data modellerinden, tercihen kalıcı(persistent) modellerden olusturmaniz gerektiğidir. Data modelleri, bir uygulamanın verilerini temsil eder. Uygulamanızdaki UI öğelerinden ve diğer componentlerden bağımsızdırlar. Bu, kullanıcı arayüzüne ve uygulama bileşeni yaşam döngüsüne bağlı olmadıkları, ancak işletim sistemi uygulamanın sürecini bellekten kaldırmaya karar verdiğinde yine de yok edilecekleri anlamına gelir. Kalıcı modeller aşağıdaki nedenlerle idealdir: . | Android işletim sistemi, kaynakları boşaltmak için uygulamanızı yok ederse, kullanıcılarınız veri kaybetmez. | Uygulamanız, ağ bağlantısının kesintili olduğu veya kullanılamadığı durumlarda çalışmaya devam eder. | . Uygulama mimarinizi data model sınıflarına(viewmodel gibi) dayandırırsanız, uygulamanızı daha test edilebilir ve sağlam hale getirirsiniz. Single source of truth . Uygulamanızda yeni bir veri türü tanımlandığında, ona Tek Doğruluk Kaynağı (SSOT) atamanız gerekir. SSOT, bu verilerin sahibidir ve yalnızca SSOT onu modifiye edebilir veya değiştirebilir. Bunu başarmak için SSOT, immutable bir tip kullanarak verileri ortaya çıkarır ve verileri değiştirmek için SSOT, diğer tiplerin çağırabileceği fonksiyonlari ortaya çıkarır veya eventleri receive eder. Bu model birden fazla fayda sağlar: . | Belirli bir veri türündeki tüm değişiklikleri tek bir yerde merkezileştirir. | Diğer tiplerin kurcalamaması için verileri korur. | Verilerdeki değişiklikleri daha izlenebilir hale getirir. Böylece buglarin fark edilmesi daha kolaydır. | . Offline-first bir uygulamada, uygulama verilerinin doğruluğunun kaynağı(ssot) tipik olarak bir veritabanıdır. Diğer bazı durumlarda, kaynak bir ViewModel veya hatta UI olabilir. Unidirectional Data Flow . Doğruluğun tek kaynağı ilkesi(single source of truth principle(ssot)), Tek Yönlü Veri Akışı (UDF) modeliyle birlikte kılavuzlarımızda sıklıkla kullanılmaktadır. UDF’de state sadece bir yönde akar. Event ise veri akışını ters yönde değiştirendir. Android’de, state veya veriler genellikle hiyerarşinin yüksek scope türlerinden daha düşük scope türlere doğru akar. Eventler, ilgili veri türü için SSOT’a ulaşana kadar genellikle daha düşük scope türlerden tetiklenir. Örneğin, uygulama verileri genellikle veri kaynaklarından kullanıcı arayüzüne akar. Button basmaları gibi kullanıcı eventleri, uygulama verilerinin değiştirildiği ve immutable bir türde gösterildiği UI’den SSOT’a akar. Bu pattern, veri tutarlılığını daha iyi garanti eder, hatalara daha az eğilimlidir, hata ayıklaması(debug) daha kolaydır ve SSOT patterinin tüm avantajlarını beraberinde getirir . Recommended app architecture . Bu bölüm, önerilen best practiseleri izleyerek uygulamanızı nasıl yapılandıracağınızı gösterir. Not: Bu sayfada sunulan öneriler ve best practiseler, ölçeklenmelerine, kalite ve sağlamlığı artırmalarına ve test edilmelerini kolaylaştırmalarına olanak sağlamak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Bahsedilen ortak mimari ilkeler göz önüne alındığında, her uygulamada en az iki katman olmalıdır: . | Uygulama verilerini ekranda görüntüleyen UI layer. | Uygulamanızın iş mantığını(business logic) içeren ve uygulama verilerini ortaya çıkaran data layer. | . Kullanıcı arabirimi(UI) ve veri katmanları arasındaki etkileşimleri basitleştirmek ve yeniden kullanmak için domain layer adı verilen ek bir katman ekleyebilirsiniz. Tipik bir uygulama mimari diagrami bu sekilde gorunur. Not:Buradaki oklar katmanlar arasi bagimliliklari gostermektedir. Mesela domain layer, data layer a bagimlidir. Modern App Architecture . Bu Modern App Architecture, diğerlerinin yanı sıra aşağıdaki tekniklerin kullanılmasını teşvik eder: . | Reaktif ve katmanlı bir mimari. | Uygulamanın tüm katmanlarında Tek Yönlü Veri Akışı (UDF). | UI’nin karmaşıklığını yönetmek için state holder’ları olan bir UI layer’ı. | Coroutine’ler ve flow’lar. | Dependency injection best practiceleri. | . Daha fazla bilgi için aşağıdaki bölümlere, içindekiler tablosundaki diğer Architecture sayfalarına ve en önemli best practice’lerin bir özetini içeren öneriler sayfasına bakın. UI Layer . UI katmanının (veya presentation katmanının) rolü, uygulama verilerini ekranda görüntülemektir. Veriler, kullanıcı etkileşimi(user interaction) (bir butona basmak gibi) veya external input(network response gibi) nedeniyle değiştiğinde, UI değişiklikleri yansıtacak şekilde güncellenmelidir. UI katmanı iki şeyden oluşur: . | Ekrandaki verileri handle eden UI elementleri. Bu öğeleri Views veya Jetpack Compose fonksiyonlarini kullanarak oluşturursunuz. | Verileri tutan, kullanıcı arayüzüne(UI) sunan ve mantığı(logic) handle eden state holderlar (ViewModel sınıfları gibi). | . Bu katman hakkında daha fazla bilgi edinmek için UI layer sayfasına bakın. Data Layer . Bir uygulamanın veri katmanı, iş mantığını(business logic) içerir. İş mantığı, uygulamanıza değer veren şeydir; uygulamanızın verileri nasıl oluşturduğunu, depoladığını ve değiştirdiğini belirleyen kurallardan oluşur. Veri katmanı, her biri sıfır ila birçok veri kaynağı içerebilen repositorylerden oluşur. Uygulamanızda handle edilen her farklı veri türü için bir repository sınıfı oluşturmalısınız. Örneğin, filmlerle ilgili veriler için bir MoviesRepository sınıfı veya ödemelerle ilgili veriler için bir PaymentsRepository sınıfı oluşturabilirsiniz. Repository sınıfları aşağıdaki görevlerden sorumludur: . | Verileri uygulamanın geri kalanına göstermek. | Verilerdeki değişiklikleri merkezileştirmek. | Birden çok veri kaynağı arasındaki çakışmaları çözmek. | Uygulamanın geri kalanından veri kaynaklarını soyutlamak. | Business logic içermek. | . Her veri kaynağı sınıfı(data source class), yalnızca tek bir veri kaynağıyla çalışma sorumluluğuna sahip olmalıdır ; bu veri kaynaklari dosya, ağ kaynağı(network source) veya yerel veritabanı(local database) olabilir. Veri kaynağı sınıfları, veri işlemleri için uygulama ile sistem arasındaki köprüdür. Bu katman hakkında daha fazla bilgi edinmek için data layer sayfasına bakın. Domain Layer . Domain katmanı(domain layer), kullanıcı arayüzü(UI layer) ve veri katmanları(data layer) arasında bulunan isteğe bağlı bir katmandır. Domain katmanı, karmaşık business logic’in veya birden fazla ViewModel tarafından yeniden kullanılan basit business logic’in enkapsüle edilmesinden sorumludur. Bu katman isteğe bağlıdır çünkü tüm uygulamalar bu gereksinimlere sahip olmayacaktır. Yalnızca gerektiğinde, örneğin karmaşıklığı yönetmek veya yeniden kullanılabilirliği desteklemek için kullanmalısınız. Bu katmandaki sınıflara yaygın olarak use case veya interactors denir. Her use case`in tek bir fonksiyonalite üzerinde sorumluluğu olmalıdır. Örneğin, birden fazla ViewModels, ekranda doğru mesajı görüntülemek için saat dilimlerine ihtiyac duyuyorsa, uygulamanız bir GetTimeZoneUseCase sınıfına sahip olabilir. Bu katman hakkında daha fazla bilgi edinmek için domain layer sayfasına bakın. Manage dependencies between components . Uygulamanızdaki sınıflar, düzgün çalışması için diğer sınıflara bağlıdır. Belirli bir sınıfın bağımlılıklarını toplamak için aşağıdaki design patternlerinden birini kullanabilirsiniz: . Dependency Injection: siniflarin bagimliliklarini olusturmadan tanimlamalarina izin verir. Runtime’da , bu bagimliliklari saglamaktan baska bir sinif sorumludur. Service Locater: siniflarin bagimliliklarini olusturmak yerine elde edebilecekleri registry saglar. Bu patternler, kodu çoğaltmadan veya karmaşıklık eklemeden bağımlılıkları yönetmek için clear pattern sağladıkları için kodunuzu ölçeklendirmenize olanak tanır. Ayrıca bu patternler, test ve production implementasyonlari arasında hızla geçiş yapmanızı sağlar. Android official olarak dependency leri yonetmek icin HILT librarysini onermektedir. Hilt, bağımlılık ağacında dolaşarak nesneleri otomatik olarak oluşturur, bağımlılıklara ilişkin derleme zamanı garantileri sağlar ve Android çerçeve sınıfları için bağımlılık containerlari oluşturur. General Best Practices . Programlama yaratıcı bir alandır ve Android uygulamaları oluşturmak da bir istisna değildir. Bir sorunu çözmenin birçok yolu vardır; verileri birden fazla activity veya fragment arasında iletebilir, uzaktaki verileri alıp offline mod için local olarak tutabilir veya basit olmayan uygulamaların karşılaştığı diğer yaygın senaryoları ele alabilirsiniz. Aşağıdaki öneriler zorunlu olmamakla birlikte, çoğu durumda bunları uygulamak kod tabanınızı uzun vadede daha sağlam, test edilebilir ve sürdürülebilir hale getirir: . Don`t store data in app components. Uygulamanizin activitileri, servisleri ve broadcast receiverlari gibi entry pointlerini veri kaynagi olarak belirlemekten kacinin. Veri kaynagi olarak belirlemek yerine o entry pointler ilgili veri alt kumelerini geri almak icin diger comoponentler ile koordine olmalidir. Her uygulama componenti, kullanıcının cihazıyla etkileşimine ve sistemin genel mevcut durumuna bağlı olarak oldukça kısa ömürlüdür. Reduce dependencies on Android classes. Uygulama componentleriniz, Context veya Toast gibi Android framework SDK API’lerine dayanan tek sınıf olmalıdır. Uygulamanızdaki diğer sınıfları onlardan soyutlamak, test edilebilirliğe yardımcı olur ve uygulamanızdaki coupling i azaltır. Create well-defined boundaries(sinirlari) of responsibility between various(cesitli) modules in your app. Örneğin, ağdan veri yükleyen kodu kod tabanınızdaki birden fazla sınıfa veya pakete yaymayın. Benzer şekilde, aynı sınıfta data caching ve data binding gibi birden fazla ilgisiz sorumluluk tanımlamayın. Önerilen uygulama mimarisini takip etmek bu konuda size yardımcı olacaktır. Modüllere mümkün olduğunca az maruz kalın.( Expose as little as possible from each module.) . Örneğin, bir modülden dahili bir implementasyon ayrıntısını ortaya cikaran bir kısayol oluşturmaya cezbedilmeyin. Kısa vadede biraz zaman kazanabilirsiniz, ancak code baseniz geliştikçe birçok kez teknik borçla karşılaşmanız olasıdır. Focus on the unique core of your app so it stands out from other apps. Ayni boilerplate(basmakalip) kodu tekrar tekrar yazarak tekerlegi yeniden icat etmeye gerek yoktur. Bunun yerine, zamanınızı ve enerjinizi uygulamanızı benzersiz kılan şeylere odaklayın ,Jetpack kutuphanelerinin ve önerilen diğer kutuphanelerin tekrar eden boilerplateleri handle etmesine izin verin. Consider how to make each part of your app testable in isolation.(Uygulamanizin her parcasini nasil ayri ayri test edilebilir hale gelecegini dusunun ) . Örneğin, ağdan veri almak için iyi tanımlanmış bir API’ye sahip olmak, bu verileri yerel bir veritabanında tutan modülün test edilmesini kolaylaştırır. Bunun yerine, bu iki modülün mantığını tek bir yerde mixlerseniz veya ağ kodunuzu tüm cade base e dağıtırsanız, etkili bir şekilde test etmek çok daha zor - imkansız değilse de - olur. Tipler, eşzamanlılık(concurrency) ilkelerinden sorumludur. Bir tip long-running blocking işi yapıyorsa, bu computation’u doğru thread e taşımaktan sorumlu olmalıdır. Bu belirli tip, yaptığı hesaplamanın tipini ve hangi threadde yürütülmesi gerektiğini bilir. Tipler main thread için main safe olmalıdır, yani bloklanmadan main threadden safe call etmektir. Mümkün olduğu kadar alakalı ve yeni verilerde ısrar edin. Bu şekilde kullanıcılar, cihazları çevrimdışı moddayken bile uygulamanızın işlevselliğinin keyfini çıkarabilir. Tüm kullanıcılarınızın sürekli, yüksek hızlı bağlantıya sahip olmadığına, sahip olsalar bile kalabalık yerlerde kötü sinyal alabileceklerini unutmayın. Benefits of Architecture (Mimarinin faydalari) . Uygulamanızda iyi bir Mimarinin uygulanması, proje ve mühendislik ekiplerine birçok fayda sağlar: . | Uygulamanin genel gidisatini, sürdürülebilirliğini, kalitesini ve sağlamlığını artırır. | Uygulamanın ölçeklenmesini sağlar. Daha fazla kişi ve daha fazla takim, minimum kod çakışmasıyla aynı code base e katkıda bulunabilir. | Alışmaya yardımcı olur. Mimari projenize tutarlılık katarken, ekibin yeni üyeleri hızla hızlanabilir ve daha kısa sürede daha verimli olabilir. | Test etmek daha kolaydır. İyi bir Mimari, genellikle test edilmesi daha kolay olan daha basit türleri teşvik eder. | Buglar, iyi tanımlanmış süreçlerle metodik olarak araştırılabilir. | . Mimariye yatırım yapmanın kullanıcılarınız üzerinde de doğrudan bir etkisi vardır. Daha istikrarlı bir uygulamadan ve daha üretken bir mühendislik ekibi sayesinde daha fazla özellikten faydalanırlar. Bununla birlikte, Mimari aynı zamanda öncelikli bir zaman yatırımı gerektirir. Bu zamanı şirketinizin geri kalanına gerekçelendirmenize yardımcı olması için, diğer şirketlerin uygulamalarında iyi bir mimariye sahip olduklarında başarı hikayelerini paylaştıkları bu vaka çalışmalarına bir göz atın. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/about-app-architecture/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/about-app-architecture/"
  },"1": {
    "doc": "About App Bundles",
    "title": "About Android App Bundles",
    "content": "Önemli: Ağustos 2021’den itibaren yeni uygulamaların Google Play’de Android App Bundle ile yayınlanması gerekmektedir. Artık 150 MB’tan büyük yeni uygulamalar Play Feature Delivery veya Play Asset Delivery tarafından desteklenmektedir. Android App Bundle, uygulamanızın tüm derlenmiş kodunu ve kaynaklarını içeren ve APK oluşturma ve imzalama işlemlerini Google Play’e bırakan bir yayınlama biçimidir. Google Play, her cihaz yapılandırması için optimize edilmiş APK’lar oluşturmak ve sunmak için app bundle’ınızı kullanır, böylece uygulamanızı çalıştırmak için yalnızca belirli bir cihaz için gereken kod ve kaynaklar indirilir. Artık farklı cihazlara yönelik desteği optimize etmek için birden fazla APK oluşturmanız, imzalamanız ve yönetmeniz gerekmiyor ve kullanıcılar daha küçük, daha optimize edilmiş indirmeler elde ediyor. Çoğu uygulama projesi, optimize edilmiş APK’ların sunulmasını destekleyen app bundle’ları oluşturmak için fazla çaba gerektirmez. Örneğin, uygulamanızın kodunu ve kaynaklarını zaten yerleşik kurallara göre düzenliyorsanız, Android Studio’yu veya komut satırını kullanarak imzalı Android App Bundle’ları oluşturmanız ve bunları Google Play’e yüklemeniz yeterlidir. Optimize edilmiş APK hizmeti otomatik bir avantaj haline gelir. Uygulamanızı yayınlamak için app bundle biçimini kullandığınızda, isteğe bağlı olarak uygulama projenize feature modülleri eklemenize olanak tanıyan Play Feature Delivery özelliğinden de yararlanabilirsiniz. Bu modüller, yalnızca sizin belirlediğiniz koşullara bağlı olarak uygulamanıza dahil edilen veya daha sonra çalışma zamanında Play Core Library kullanılarak indirilebilen özellikler ve kaynaklar içerir. Uygulamalarını app bundle’larla yayınlayan oyun geliştiricileri Play Asset Delivery’yi kullanabilir: Google Play’in geliştiricilere esnek sunum yöntemleri ve yüksek performans sunan büyük miktarda oyun asset’i sunma çözümü. Uygulamanızı neden Android App Bundle’ları kullanarak yayınlamanız gerektiğine dair genel bir bakış için aşağıdaki videoyu izleyin. Top 7 takeaways for Android App Bundles . Compressed download size restriction . Android App Bundle’lar ile yayınlamak, kullanıcılarınızın uygulamanızı mümkün olan en küçük indirme ile yüklemelerine yardımcı olur ve sıkıştırılmış indirme boyutu sınırını 150 MB’a çıkarır. Yani, bir kullanıcı uygulamanızı indirdiğinde, uygulamanızı yüklemek için gereken sıkıştırılmış APK’ların toplam boyutu (örneğin, temel APK + yapılandırma APK’ları) 150 MB’den fazla olmamalıdır. İsteğe bağlı olarak bir feature modülünün (ve yapılandırma APK’larının) indirilmesi gibi sonraki tüm indirmeler de bu sıkıştırılmış indirme boyutu kısıtlamasını karşılamalıdır. Asset paketleri bu boyut sınırına katkıda bulunmaz, ancak başka boyut kısıtlamaları vardır. Uygulama paketinizi yüklediğinizde, Play Console uygulamanızın veya isteğe bağlı özelliklerinin olası indirmelerinden herhangi birinin 150 MB’tan fazla olduğunu tespit ederse bir hata alırsınız. Android App Bundle’ların APK genişletme (*.obb) dosyalarını desteklemediğini unutmayın. Bu nedenle, app bundle’ınızı yayınlarken bu hatayla karşılaşırsanız, sıkıştırılmış APK indirme boyutlarını azaltmak için aşağıdaki kaynaklardan birini kullanın: . | Her yapılandırma APK’sı türü için enableSplit = true ayarını yaparak tüm yapılandırma APK’larını etkinleştirdiğinizden emin olun. Bu, kullanıcıların yalnızca uygulamanızı cihazlarında çalıştırmak için ihtiyaç duydukları kodu ve kaynakları indirmelerini sağlar. | Kullanılmayan kod ve kaynakları kaldırarak uygulamanızı küçülttüğünüzden emin olun. | Uygulama boyutunu daha da azaltmak için en iyi uygulamaları izleyin. | Yalnızca bazı kullanıcılarınız tarafından kullanılan özellikleri, uygulamanızın daha sonra isteğe bağlı olarak indirebileceği feature modüllerine dönüştürmeyi düşünün. Bunun uygulamanızın yeniden düzenlenmesini gerektirebileceğini unutmayın, bu nedenle önce yukarıda açıklanan diğer önerileri denediğinizden emin olun. | . Other considerations . Aşağıda, uygulamanızı Android App Bundle’lar ile oluştururken veya sunarken şu anda bilinen sorunlar yer almaktadır. Aşağıda açıklanmayan sorunlarla karşılaşırsanız, lütfen bir hata bildirin. | Google Play Store kullanılarak yüklenmeyen ve bir veya daha fazla required split APK’sı eksik olan sideloaded uygulamaların kısmi yüklemeleri, Google onaylı tüm cihazlarda ve Android 10 (API düzeyi 29) veya daha üstünü çalıştıran cihazlarda başarısız olur. Uygulamanızı Google Play Store üzerinden indirirken Google, uygulamanın gerekli tüm bileşenlerinin yüklenmesini sağlar.\\ . | Kaynak tablolarını dinamik olarak değiştiren araçlar kullanırsanız, app bundle’lardan oluşturulan APK’lar beklenmedik şekilde davranabilir. Bu nedenle, bir app bundle oluştururken bu tür araçları devre dışı bırakmanız önerilir. | Şu anda bir feature modülünün derleme yapılandırmasında temel (veya diğer) modüllerdekilerle çakışan özellikler yapılandırmak mümkündür. Örneğin, temel modülde buildTypes.release.debuggable = true olarak ayarlayabilir ve bir feature modülünde bunu false olarak ayarlayabilirsiniz. Bu tür çakışmalar derleme ve çalışma zamanı sorunlarına neden olabilir. Varsayılan olarak, feature modüllerinin bazı derleme yapılandırmalarını temel modülden miras aldığını unutmayın. Bu nedenle, feature modülü derleme yapılandırmanızda hangi yapılandırmaları tutmanız ve hangilerini çıkarmanız gerektiğini anladığınızdan emin olun. | . ",
    "url": "/docs/core-topics/android-app-bundles/about-app-bundles/#about-android-app-bundles",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-app-bundles/#about-android-app-bundles"
  },"2": {
    "doc": "About App Bundles",
    "title": "Additional resources",
    "content": "Android App Bundle’lar hakkında daha fazla bilgi edinmek için aşağıdaki kaynaklara başvurun. Blogs . Videos . ",
    "url": "/docs/core-topics/android-app-bundles/about-app-bundles/#additional-resources",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-app-bundles/#additional-resources"
  },"3": {
    "doc": "About App Bundles",
    "title": "About App Bundles",
    "content": " ",
    "url": "/docs/core-topics/android-app-bundles/about-app-bundles/",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-app-bundles/"
  },"4": {
    "doc": "About app links",
    "title": "About app links",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/about-app-links/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/about-app-links/"
  },"5": {
    "doc": "About app manifests",
    "title": "About app manifests",
    "content": "Her uygulama projesinin, proje kaynak kümesinin rootunda bir AndroidManifest.xml dosyası (tam olarak bu ada sahip) olması gerekir. Manifest dosyası, uygulamanızla ilgili temel bilgileri Android build toollarina, Android işletim sistemine ve Google Play’e açıklar. Diğer birçok şeyin yanı sıra, manifest dosyasının aşağıdakileri bildirmesi gerekir: . | Uygulamanin componentleri, tum activityleri, serviceleri, broadcast receiverlari, ve content providerlari icerir. Her component temel özellikleri tanımlamalıdır; Kotlin veya Java sınıfının adı gibi. Ayrıca, hangi cihaz konfigürasyonlarını destekleyebilecegi ve componentleri nasıl başlatılabileceğini açıklayan intent filterlar gibi yetenekleri de bildirebilir. | Sistemin korumalı bölümlerine veya diğer uygulamalara erişmek için uygulamanın ihtiyaç duyduğu izinler. Ayrıca, bu uygulamadan içeriğe erişmek istiyorlarsa diğer uygulamaların sahip olması gereken izinleri de bildirir. | Uygulamanın gerektirdiği donanım ve yazılım özellikleri, uygulamayı Google Play’den hangi cihazların yükleyebileceğini etkiler. Manifest icerisind bu bilgileride beyan ederiz. | . Uygulamanızı oluşturmak için Android Studio kullanıyorsanız, manifest dosyası sizin için oluşturulur ve temel manifest öğelerinin çoğu, uygulamanızı oluştururken eklenir (özellikle kod şablonlarını kullanırken). ",
    "url": "/docs/app-basics/about-app-manifests/",
    
    "relUrl": "/docs/app-basics/about-app-manifests/"
  },"6": {
    "doc": "About app manifests",
    "title": "File features",
    "content": "Aşağıdaki bölümlerde, uygulamanızın en önemli özelliklerinden bazılarının manifest dosyasına nasıl eklendigi açıklanmaktadır. App components . Uygulamanızda oluşturduğunuz her uygulama componenti için manifest dosyasında karşılık gelen bir XML öğesi bildirmeniz gerekir: . - Activityler için &lt;activity&gt; elementi - Service'ler için &lt;service&gt; elementi - Broadcast receiver'lar için &lt;receiver&gt; elementi - Content provider'lar için &lt;provider&gt; elementi . Bu componentlerden herhangi birini manifest dosyasında bildirmeden alt sınıflara ayırırsanız, sistem onu ​​başlatamaz. Alt sınıfınızın adı, tam paket adi kullanılarak name attribute ile belirtilmelidir. Örneğin, bir Activity alt sınıfı aşağıdaki gibi bildirilebilir: . &lt;manifest ... &gt; &lt;application ... &gt; &lt;activity android:name=\"com.example.myapp.MainActivity\" ... &gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; . Ancak, name değerindeki ilk karakter bir noktaysa, uygulamanın namespace i (modül düzeyindeki build.gradle dosyasının namespace özelliğinden) name in önüne cozumlenirken eklenir. Örneğin, namespace “com.example.myapp” ise, aşağıdaki activity adı “com.example.myapp.MainActivity”` olarak çözümlenir: . &lt;manifest ... &gt; &lt;application ... &gt; &lt;activity android:name=\".MainActivity\" ... &gt; ... &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; . Alt paketlerde (com.example.myapp.purchases gibi) bulunan uygulama componentleriniz varsa, name değeri eksik alt paket adlarını (“.purchases.PayActivity” gibi) eklemeli veya fully qualified (nitelikli) paket adı kullanmalıdır. Intent filters . Uygulama activityleri, serviceleri, and broadcast receiverlari intentlere göre etkinleştirilir. Bir intent, üzerinde işlem(action) yapılacak veriler, işlemi (acton) gerçekleştirmesi gereken component kategorisi ve diğer talimatlar dahil, gerçekleştirilecek bir eylemi tanımlayan bir Intent objesi tarafından tanımlanan bir mesajdır. Bir uygulama sisteme bir intent tanimladiginda, sistem, her uygulamanın manifest dosyasındaki Intent filter bildirimlerine dayalı olarak Intenti handle edebilecek bir uygulama bileşeni bulur. Sistem, eşleşen componentin bir instanceni başlatır ve Intent nesnesini bu componente iletir. Birden fazla uygulama intenti handle edebiliyorsa, kullanıcı hangi uygulamayi kullanılacağını seçebilir. Mesela galerimizden bir fotograf paylasacagiz, fotografi secip paylas butonuna tikladigimizda sistem yukaridaki islemleri yapar ve fb, insta, whatsapp gibi secenekler gosterir. Bir uygulama componenti, her biri o componentin farklı bir yeteneğini tanımlayan herhangi bir sayıda intent filter a ( öğesiyle tanımlanır) sahip olabilir. Icons and labels . Bir dizi manifest elementi, ilgili uygulama componenti için kullanıcılara sırasıyla küçük bir icon ve bir text label görüntülemek için icon ve label attributelerine sahiptir. Her durumda, bir parent elementde set edilen icon ve label, tüm child elementler için varsayılan icon ve label değeri olur. Örneğin, elementinde ayarlanan icon ve label, uygulamanın her bir componenti için (tüm activityler gibi) varsayılan icon ve labeldir. Bir componentin içinde ayarlanan icon ve label, o component bir intenti yerine getirmek için bir seçenek olarak sunulduğunda kullanıcıya gösterilir. Default olarak, bu icon, parent component için bildirilen icondan ( veya elementi) devralanir, seçici iletişim kutusunda(chooser dialog) daha iyi belirtmek istediğiniz unique bir eylem sağlıyorsa, bir intent filterin iconunu değiştirmek isteyebilirsiniz. Permissions . Android uygulamaları, hassas kullanıcı verilerine (kişiler ve SMS gibi) veya belirli sistem özelliklerine (kamera ve internet erişimi gibi) erişmek için izin istemelidir. Her izin unique bir label ile tanımlanır(“android.permission.SEND_SMS“ gibi). Örneğin, SMS mesajları göndermesi gereken bir uygulamanın manifest dosyasinda şu satırı olması gerekir: . &lt;manifest ... &gt; &lt;uses-permission android:name=\"android.permission.SEND_SMS\"/&gt; ... &lt;/manifest&gt; . Android 6.0’dan (API düzeyi 23) başlayarak, kullanıcı runtimeda bazı uygulama izinlerini onaylayabilir veya reddedebilir. Ancak uygulamanızın hangi Android sürümünü desteklediği önemli değil, tüm izin isteklerini manifest dosyasinda bir elementi ile bildirmeniz gerekir. Kullanici izin verirse, uygulama korunan özellikleri kullanabilir. Izin vermezse, bu özelliklere erişme girişimleri başarısız olur. Uygulamanız ayrıca kendi componentilerini izinlerle koruyabilir. Android.Manifest.permission içinde listelendiği gibi Android tarafından tanımlanan izinlerden herhangi birini veya başka bir uygulamada bildirilen bir izni kullanabilir. Uygulamanız kendi izinlerini de tanımlayabilir. elementi ile yeni bir izin bildirilebilir. Device compatibility . Manifest dosyası ayrıca, uygulamanızın ne tür donanım veya yazılım özelliklerini gerektirdiğini ve dolayısıyla uygulamanızın hangi tür cihazlarla uyumlu olduğunu bildirebileceğiniz yerdir. Google Play Store, uygulamanızın gerektirdiği özellikleri veya sistem sürümünü sağlamayan cihazlara uygulamanızın yüklenmesine izin vermez. Uygulamanızın hangi cihazlarla uyumlu olduğunu tanımlayan birkaç manifest tagi vardır. Aşağıdakiler en yaygın etiketlerden sadece birkaçıdır. ***:*** elementi, uygulamanızın ihtiyaç duyduğu donanım ve yazılım özelliklerini bildirmenize olanak tanır. Örneğin, uygulamanız pusula sensörü olmayan bir cihazda temel işlevleri gerçekleştiremezse pusula sensörünü aşağıdaki manifest tagiyle gerektiği gibi bildirebilirsiniz: . &lt;manifest ... &gt; &lt;uses-feature android:name=\"android.hardware.sensor.compass\" android:required=\"true\" /&gt; ... &lt;/manifest&gt; . ***:*** Birbirini izleyen her platform sürümü, genellikle önceki sürümde bulunmayan yeni API'ler ekler. Uygulamanızın uyumlu olduğu minimum sürümü belirtmek için manifestiniz `` tagini ve minSdkVersion attributeni içermelidir. Ancak, elementindeki attributelerin build.gradle dosyasındaki karşılık gelen propertyler tarafından override edildigine dikkat edin. Dolayısıyla, Android Studio kullanıyorsanız, bunun yerine minSdkVersion ve targetSdkVersion değerlerini belirtmelisiniz: . android { defaultConfig { applicationId 'com.example.myapp' // Defines the minimum API level required to run the app. minSdkVersion 21 // Specifies the API level used to test the app. targetSdkVersion 33 ... } } . ",
    "url": "/docs/app-basics/about-app-manifests/#file-features",
    
    "relUrl": "/docs/app-basics/about-app-manifests/#file-features"
  },"7": {
    "doc": "About app manifests",
    "title": "File conventions",
    "content": "Bu bölüm, manifest dosyasındaki tüm elementler ve attributeslere genel olarak uygulanan sözleşmeler ve kurallari açıklar. Elements Yalnızca &lt;manifest&gt; ve &lt;application&gt; elementleri gereklidir. Her biri yalnızca bir kez yazilir. Diğer elementlerin çoğu sıfır veya daha fazla kez oluşabilir. Ancak, manifest dosyasının kullanışlı olması için bazılarının mevcut olması gerekir. Tüm değerler, bir öğe içindeki karakter verileri olarak değil, attributeler aracılığıyla ayarlanır. Aynı seviyedeki elementler genellikle sıralanmaz. Örneğin, &lt;activity&gt;, &lt;provider&gt; ve &lt;service&gt; öğeleri herhangi bir sırada yerleştirilebilir. Bu kuralın iki önemli istisnası vardır: . Bir &lt;activity-alias&gt; öğesi, diğer adı olan &lt;activity&gt; öğesini izlemelidir. &lt;application&gt; öğesi, &lt;manifest&gt; öğesi içindeki son element olmalıdır. Attributes . Teknik olarak, butun attributeler opsiyoneldi. Ancak, bir elementin amacını gerçekleştirebilmesi için bircok attribute belirtilmek zorundadir. Gercekten opsiyonel attributeler, referans dokumantasyonda default degerleri ile gosterilir. Root &lt;manifest&gt; elementinin bazi attributeleri disinda, butun attributelerin adlari android: oneki(prefix) ile baslar. Ornegin, android:alwaysRetainTaskState. Cunku prefixler evrenseldir, bu dokumantasyon, attributelere isimle atıfta bulunurken genellikle prefixi atlar. Multiple Values . Birden fazla değer belirtilebilirse, tek bir element içinde birden çok değerin listelenmesi yerine, element hemen hemen her zaman tekrarlanır. Örneğin, bir intent filter birkaç action listeleyebilir: . &lt;intent-filter ... &gt; &lt;action android:name=\"android.intent.action.EDIT\" /&gt; &lt;action android:name=\"android.intent.action.INSERT\" /&gt; &lt;action android:name=\"android.intent.action.DELETE\" /&gt; ... &lt;/intent-filter&gt; . Resource values . Bazı attributelerin, bir activitynin başlığı veya uygulamanızın iconu gibi kullanıcılara görüntülenen değerleri vardır. Bu attributelerin değeri, kullanıcının diline veya diğer cihaz konfigürasyonlarına (cihazın piksel yoğunluğuna göre farklı bir icon boyutu sağlamak gibi) bağlı olarak farklılık gösterebilir, bu nedenle manifest dosyasına sabit kodlanmış değerler yerine bir kaynaktan veya temadan ayarlanmalıdır. Guncel değer daha sonra farklı cihaz konfigürasyonları için sağladığınız alternatif kaynaklara göre değişebilir. Kaynaklar, aşağıdaki formatta değerler olarak ifade edilir: \"@[package:]type/name\" . Kaynak uygulamanız tarafından sağlanıyorsa paket adını atlayabilirsiniz (library kaynakları sizinkiyle birleştirildiğinden(merge), bir library bağımlılığı tarafından sağlanıp sağlanmadığı dahil). Android frameworkunden bir kaynak kullanmak istediğinizde, tek geçerli paket adı, android dir. Type, string veya drawable gibi bir kaynak türüdür ve name, belirli kaynağı tanımlayan addır. İşte bir örnek: . &lt;activity android:icon=\"@drawable/smallPic\" ... &gt; . String values . Attribute değeri bir string olduğunda, karakterlerden kaçmak için çift ters eğik çizgi (\\) kullanmalısınız, örneğin yeni satır için \\n veya Unicode karakter için \\uxxxx gibi. ## Manifest elements reference . ",
    "url": "/docs/app-basics/about-app-manifests/#file-conventions",
    
    "relUrl": "/docs/app-basics/about-app-manifests/#file-conventions"
  },"8": {
    "doc": "About app manifests",
    "title": "Example manifest file",
    "content": "Aşağıdaki XML, uygulama için iki activity bildiren basit bir AndroidManifest.xml örneğidir. &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:versionCode=\"1\" android:versionName=\"1.0\"&gt; &lt;!-- Beware that these values are overridden by the build.gradle file --&gt; &lt;uses-sdk android:minSdkVersion=\"15\" android:targetSdkVersion=\"26\" /&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;!-- This name is resolved to com.example.myapp.MainActivity based on the namespace property in the build.gradle file --&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".DisplayMessageActivity\" android:parentActivityName=\".MainActivity\" /&gt; &lt;/application&gt; &lt;/manifest&gt; . ",
    "url": "/docs/app-basics/about-app-manifests/#example-manifest-file",
    
    "relUrl": "/docs/app-basics/about-app-manifests/#example-manifest-file"
  },"9": {
    "doc": "About app resources",
    "title": "App resources",
    "content": " ",
    "url": "/docs/app-basics/app-resources/about-app-resources/#app-resources",
    
    "relUrl": "/docs/app-basics/app-resources/about-app-resources/#app-resources"
  },"10": {
    "doc": "About app resources",
    "title": "About app resources",
    "content": "Resources, bitmap’ler, layout tanımları, kullanıcı arabirimi(UI) stringleri, animasyon yönergeleri ve daha fazlası gibi kodunuzun kullandığı ek dosyalar ve statik içeriktir. Imageler ve stringler gibi uygulama resourcelerini her zaman kodunuzdan dışsallaştırmalısınız, böylece bunları bağımsız olarak koruyabilirsiniz. Ayrıca, bunları özel olarak adlandırılan kaynak dizinlerinde gruplayarak belirli aygıt yapılandırmaları için alternatif kaynaklar(resources) sağlamalısınız. Çalışma zamanında Android, geçerli yapılandırmaya göre uygun kaynağı kullanır. Örneğin, ekran boyutuna bağlı olarak farklı bir UI düzeni veya dil ayarına bağlı olarak farklı stringler sağlamak isteyebilirsiniz. Uygulama kaynaklarınızı haricileştirdikten sonra, projenizin R sınıfında oluşturulan resource IDlerini kullanarak bunlara erişebilirsiniz. Bu dokuman, Android projenizde kaynaklarınızı nasıl gruplayacağınızı ve belirli cihaz yapılandırmaları için alternatif kaynaklar nasıl sağlayacağınızı ve ardından bunlara uygulama kodunuzdan veya diğer XML dosyalarından nasıl erişeceğinizi gösterir. Grouping resource types . Her tür kaynağı projenizin res/ dizininin belirli bir alt dizinine yerleştirmelisiniz. Örneğin, basit bir proje için dosya hiyerarşisi şu şekildedir: . MyProject/ src/ MyActivity.java res/ drawable/ graphic.png layout/ main.xml info.xml mipmap/ icon.png values/ strings.xml . Bu örnekte görebileceğiniz gibi, res/ dizini tüm kaynakları (alt dizinlerde) içerir: bir görüntü kaynağı, iki layout kaynağı, launcher iconlar için mipmap/ dizinler ve bir string kaynak dosyası. Kaynak dizini adları önemlidir. Not: Mipmap klasörlerini kullanma hakkında daha fazla bilgi için, bkz. Uygulama simgelerini mipmap dizinlerine yerleştirme. Proje res/ dizini içinde desteklenen kaynak dizinleri: . | Directory | Resource Type | . | animator/ | Property animasyonlarını tanımlayan XML dosyaları. | . | anim/ | Gecis animasyonlarını( tween animations.) tanımlayan XML dosyaları. (Özellik animasyonları da bu dizine kaydedilebilir, ancak özellik animasyonlarının iki türü ayırt etmesi için animatör/ dizini tercih edilir.) | . | color/ | Renklerin state listesini tanımlayan XML dosyaları | . | drawable/ | Aşağıdaki drawable resources alt türlerinde derlenen bitmap dosyaları (.png, .9.png, .jpg, .gif) veya XML dosyaları: Bitmap dosyaları, Nine-Patches (yeniden boyutlandırılabilir bitmapler), State listeleri, Şekiller, Animasyon drawables , Diğer drawabler Bkz. Drawable Resources. | . | mipmap/ | Farklı başlatıcı simge yoğunlukları(densities) için çizilebilir dosyalar. Başlatıcı simgelerini mipmap/klasörlerle yönetme hakkında daha fazla bilgi için, bkz. Put app icons in mipmap directories. | . | layout/ | Bir kullanıcı arabirimi düzenini tanımlayan XML dosyaları. | . | menu/ | Seçenekler Menüsü, Bağlam Menüsü veya Alt Menü gibi uygulama menülerini tanımlayan XML dosyaları. | . | raw/ | Ham formlarında kaydedilecek keyfi dosyalar. Bu kaynakları bir ham InputStream, ile açmak için, R.raw.filename olan kaynak kimliğiyle Resources.openRawResource()’u arayın. Ancak, orijinal dosya adlarına ve dosya hiyerarşisine erişmeniz gerekiyorsa, bazı kaynakları assets/ dizinine (res/raw/ yerine) kaydetmeyi düşünebilirsiniz. assets/ dosyalara bir kaynak kimliği verilmez, bu nedenle bunları yalnızca AssetManager.kullanarak okuyabilirsiniz. | . | values/ | Stirngler, integer ve renkler gibi basit değerler içeren XML dosyaları. Diğer res/ alt dizinlerindeki XML kaynak dosyaları, XML dosya adına dayalı olarak tek bir kaynağı tanımlarken, values/ dizindeki dosyalar birden çok kaynağı tanımlar. Bu dizindeki bir dosya için elementinin her bir alt elementi tek bir kaynak tanımlar. Örneğin, bir elementi bir R.string kaynağı oluşturur ve bir elementi bir R.color kaynağı oluşturur.Her kaynak kendi XML öğesiyle tanımlandığından, dosyayı istediğiniz gibi adlandırabilir ve farklı kaynak türlerini tek bir dosyaya yerleştirebilirsiniz. Ancak, netlik sağlamak için benzersiz kaynak türlerini farklı dosyalara yerleştirmek isteyebilirsiniz. Örneğin, bu dizinde oluşturabileceğiniz kaynaklar için bazı dosya adı kuralları şunlardır:&lt;/br&gt;arrays.xml for resource arrays ([typed arrays](https://developer.android.com/guide/topics/resources/more-resources#TypedArray)).&lt;/br&gt;colors.xml for [color values](https://developer.android.com/guide/topics/resources/more-resources#Color)&lt;/br&gt;dimens.xml for [dimension values](https://developer.android.com/guide/topics/resources/more-resources#Dimension).&lt;/br&gt;strings.xml for [string values](https://developer.android.com/guide/topics/resources/string-resource). &lt;/br&gt;styles.xml for [styles](https://developer.android.com/guide/topics/resources/style-resource).&lt;/br&gt;See [String Resources](https://developer.android.com/guide/topics/resources/string-resource), [Style Resource](https://developer.android.com/guide/topics/resources/style-resource), and [More Resource Types](https://developer.android.com/guide/topics/resources/more-resources). | . | xml/ | Resources.getXML(). çağrılarak çalışma zamanında okunabilen keyfi XML dosyaları. searchable configuration gibi çeşitli XML konfigürasyon dosyaları buraya kaydedilmelidir. | . | font/ | Font/ .ttf, .otf veya .ttc gibi uzantılara sahip yazı tipi dosyaları veya bir öğesi içeren XML dosyaları. Kaynak olarak yazı tipleri hakkında daha fazla bilgi için [Fonts in XML](https://developer.android.com/guide/topics/ui/look-and-feel/fonts-in-xml).'e gidin. | . Dikkat: Kaynak dosyalarını asla doğrudan res/ dizininin içine kaydetmeyin; bu bir derleyici hatasına neden olur. Belirli kaynak türleri hakkında daha fazla bilgi için bkz. Resource Types . Yukarida tanımlanan alt dizinlere kaydettiğiniz kaynaklar, “varsayılan” kaynaklarınızdır. Yani bu kaynaklar, uygulamanız için varsayılan tasarımı ve içeriği tanımlar. Bununla birlikte, farklı Android destekli cihaz türleri, farklı türde kaynaklar gerektirebilir. Örneğin, bir cihazın ekranı normalden daha büyükse, ekstra ekran alanından yararlanan farklı layout kaynakları sağlamalısınız. Veya bir aygıtın farklı bir dil ayarı varsa, metni kullanıcı arabiriminizde çeviren farklı string kaynakları sağlamalısınız. Bu farklı kaynakları farklı cihaz yapılandırmaları için sağlamak için varsayılan kaynaklarınıza ek olarak alternatif kaynaklar sağlamanız gerekir. Providing alternative resources . Hemen hemen her uygulama, belirli cihaz yapılandırmalarını desteklemek için alternatif kaynaklar sağlamalıdır. Örneğin, farklı ekran yoğunlukları için alternatif drawable kaynaklar ve farklı diller için alternatif string kaynakları eklemelisiniz. Çalışma zamanında Android, mevcut cihaz yapılandırmasını algılar ve uygulamanız için uygun kaynakları yükler. Bir dizi kaynağa konfigürasyona özel alternatifler belirtmek için: . | res/ içinde - biçiminde adlandırılmış yeni bir dizin oluşturun. | , karşılık gelen varsayılan kaynakların dizin adıdır | , bu kaynakların kullanılacağı ayri bir yapılandırmayı belirten bir addır. Birden fazla ekleyebilirsiniz. Her birini bir tire ile ayırın. | . Dikkat: Birden çok qualifier eklerken, bunları listelendikleri sırayla yerleştirmelisiniz. Qualifierlar yanlış sıralanırsa kaynaklar yok sayılır. | İlgili alternatif kaynakları bu yeni dizine kaydedin. Kaynak dosyaları, varsayılan kaynak dosyalarıyla tam olarak aynı şekilde adlandırılmalıdır. Örneğin, bazı varsayılan ve alternatif kaynaklar şunlardır: res/ drawable/ icon.png background.png drawable-hdpi/ icon.png background.png . | . hdpi qualifieri, o dizindeki kaynakların yüksek yoğunluklu ekrana sahip cihazlar için olduğunu belirtir. Bu drawable dizinlerinin her birindeki görüntüler, belirli bir ekran yoğunluğu için boyutlandırılmıştır, ancak dosya adları tamamen aynıdır. Bu şekilde, icon.png veya background.png görüntüsüne başvurmak için kullandığınız kaynak ID her zaman aynıdır, ancak Android, cihaz yapılandırma bilgilerini aşağıdaki kaynak dizini adındaki niteleyicilerle karşılaştırarak mevcut cihazla en iyi eşleşen her kaynağın sürümünü seçer. Dikkat: Alternatif bir kaynak tanımlarken, kaynağı varsayılan bir konfigürasyonda da tanımladığınızdan emin olun. Aksi takdirde, cihaz bir yapılandırmayı değiştirdiğinde uygulamanız çalışma zamanı istisnalarıyla karşılaşabilir. Örneğin, values değil, yalnızca values-en diye bir dizin eklerseniz, kullanıcı varsayılan sistem dilini değiştirdiğinde uygulamanız bir Kaynak Bulunamadı istisnasıyla karşılaşabilir. Android birkaç yapılandırma niteleyicisini destekler ve her qualifieri bir tire ile ayırarak bir dizin adına birden çok qualifier ekleyebilirsiniz. Tabloda, geçerli yapılandırma niteleyicilerini öncelik sırasına göre listeler—bir kaynak dizini için birden çok qualifier kullanıyorsanız, bunları tabloda listelendikleri sırayla dizin adına eklemeniz gerekir. Quealifier name rules . Yapılandırma niteleyici adlarını kullanmayla ilgili bazı kurallar şunlardır: . | Tek bir kaynak için tire ile ayrılmış birden çok qualifier belirtebilirsiniz. Örneğin, drawable-en-rUS-land, yatay yöndeki ABD-İngilizce cihazlar için geçerlidir. | Qualifierler tablo 2’de listelenen sırada olmalıdır. Örneğin: Wrong:drawable-hdpi-port/ Correct:drawable-port-hdpi/ | Alternatif kaynak dizinleri iç içe yerleştirilemez. Örneğin, res/drawable/drawable-en/’e sahip olamazsınız. | Değerler büyük/küçük harfe duyarsızdır. Kaynak derleyici, büyük/küçük harfe duyarlı olmayan dosya sistemlerinde sorunları önlemek için işlemden önce dizin adlarını küçük harfe dönüştürür. Adlardaki herhangi bir büyük harf kullanımı yalnızca okunabilirliğe fayda sağlamak içindir. | Her qualifier türü için yalnızca bir değer desteklenir. Örneğin, İspanya ve Fransa için aynı drawable dosyaları kullanmak istiyorsanız, drawable-es-fr/ adlı bir dizine sahip olamazsınız. Bunun yerine, uygun dosyaları içeren drawable-es/ ve drawable-fr/ gibi iki kaynak dizinine ihtiyacınız vardır. Ancak, aynı dosyaları her iki konumda da çoğaltmanız gerekmez. Bunun yerine, bir kaynağa takma ad oluşturabilirsiniz. Aşağıdaki Creating alias resources konusuna bakın. | . Alternatif kaynakları bu qualifierler ile adlandırılmış dizinlere kaydettikten sonra Android, mevcut cihaz yapılandırmasına göre uygulamanızdaki kaynakları otomatik olarak uygular. Bir kaynak her istendiğinde, Android, istenen kaynak dosyasını içeren alternatif kaynak dizinlerini kontrol eder ve ardından en uygun kaynağı bulur (aşağıda tartışılmıştır). Belirli bir cihaz yapılandırmasıyla eşleşen alternatif kaynak yoksa, Android karşılık gelen varsayılan kaynakları kullanır. Creating alias resources . Birden fazla cihaz yapılandırması için kullanmak istediğiniz (ancak varsayılan kaynak olarak olarak kullanmak istemediğiniz) bir kaynağınız olduğunda, aynı kaynağı birden fazla alternatif kaynak dizinine koymanız gerekmez. Bunun yerine (bazı durumlarda) varsayılan kaynak dizininizde kayıtlı bir kaynak için takma ad görevi gören alternatif bir kaynak oluşturabilirsiniz. Not: Tüm kaynaklar, başka bir kaynağa takma ad oluşturabileceğiniz bir mekanizma sunmaz. Özellikle xml/ dizinindeki anim, menu, raw ve diğer belirtilmemiş kaynaklar bu özelliği sunmaz. Örneğin, icon.png adlı bir uygulama simgeniz olduğunu ve bunun farklı yerel bolgeler için benzersiz bir sürümüne ihtiyacınız olduğunu hayal edin. Ancak, İngilizce-Kanada ve Fransızca-Kanada olmak üzere iki yerel bolgenin aynı sürümü kullanması gerekir. Aynı görüntüyü hem İngilizce-Kanada dili hem de Fransızca-Kanada dili için kaynak dizinine kopyalamanız gerektiğini varsayabilirsiniz, ancak bu doğru değildir. Bunun yerine, her ikisi için kullanılan resmi icon_ca.png (icon.png dışında herhangi bir ad) olarak kaydedebilir ve varsayılan res/drawable/ dizinine koyabilirsiniz. Ardından, öğesini kullanarak res/drawable-en-rCA/ ve res/drawable-fr-rCA/ içinde icon_ca.png kaynağına atıfta bulunan bir icon.xml dosyası oluşturun. Bu, PNG dosyasının yalnızca bir sürümünü ve ona işaret eden iki küçük XML dosyasını saklamanıza olanak tanır. (Örnek bir XML dosyası aşağıda gösterilmiştir.) . | Drawable:Mevcut bir drawable elemente bir takma ad oluşturmak için elementini kullanın. Örneğin: ```xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; | . @drawable/icon_ca Bu dosyayı icon.xml (res/values-en-rCA/ gibi alternatif bir kaynak dizininde) olarak kaydederseniz, R.drawable.icon olarak başvurabileceğiniz bir kaynağa derlenir, ancak aslında R.drawable.icon_ca kaynağı için bir aliastir. (res/drawable/ içinde kaydedilir). 2. Layout ```xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;merge&gt; &lt;include layout=\"@layout/main_ltr\"/&gt; &lt;/merge&gt; . | Strings and other simple values: Varolan bir dizeye takma ad oluşturmak için, yeni dizenin değeri olarak istenen dizenin kaynak IDsini kullanmanız yeterlidir. Örneğin: | . &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;resources&gt; &lt;string name=\"hello\"&gt;Hello&lt;/string&gt; &lt;string name=\"hi\"&gt;@string/hello&lt;/string&gt; &lt;/resources&gt; . R.string.hi kaynağı artık R.string.hello için bir takma addır. Diğer basit değerler de aynı şekilde çalışır. Örneğin, bir renk: . &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;resources&gt; &lt;color name=\"red\"&gt;#f00&lt;/color&gt; &lt;color name=\"highlight\"&gt;@color/red&lt;/color&gt; &lt;/resources&gt; . Accessing your app resources . Uygulamanızda bir kaynak sağladıktan sonra, kaynak IDsine başvurarak onu uygulayabilirsiniz. Tüm kaynak IDleri, projenizin aapt toolunun otomatik olarak oluşturduğu R sınıfında tanımlanır. Uygulamanız derlendiğinde aapt, res/ dizininizdeki tüm kaynaklar için kaynak IDlerini içeren R sınıfını oluşturur. Her kaynak türü için bir R alt sınıfı vardır (örneğin, tüm drawable kaynaklar için R.drawable) ve bu türdeki her kaynak için bir statik integer (örneğin, R.drawable.icon) vardır. Bu integer kaynağınızı almak için kullanabileceğiniz kaynak IDsidir. R sınıfı, kaynak IDlerinin belirtildiği yer olsa da, bir kaynak IDsini keşfetmek için asla oraya bakmanız gerekmez. Bir kaynak IDsi her zaman şunlardan oluşur: . | Kaynak tipi: Her kaynak, string, drawable ve layout gibi bir “tip” olarak gruplanır. Farklı tipler hakkında daha fazla bilgi için bkz. Kaynak Tipleri . | Aşağıdakilerden biri olan kaynak adı: uzantı hariç dosya adı veya kaynak basit bir değerse (örneğin bir string) XML android:name attributendeki değer. | . Bir kaynağa erişmenin iki yolu vardır: . | Kodda: R sınıfınızın bir alt sınıfından statik bir integer kullanma, örneğin: R.string.hello string, kaynak tipidir ve hello, kaynak adıdır. Bu biçimde bir kaynak IDsi sağladığınızda kaynaklarınıza erişebilen birçok Android API’si vardır. Bkz. Koddaki Kaynaklara Erişme. | XML’de: R sınıfınızda tanımlanan kaynak IDsine de karşılık gelen özel bir XML syntax kullanma, örneğin: @string/hello . | . Accessing resources in code . Kaynak IDsini method parametresi olarak ileterek koddaki bir kaynağı kullanabilirsiniz. Örneğin, setImageResource() kullanarak res/drawable/myimage.png kaynağını kullanmak için bir ImageView ayarlayabilirsiniz: . val imageView = findViewById(R.id.myimageview) as ImageView imageView.setImageResource(R.drawable.myimage) . getResources() ile bir örneğini alabileceğiniz Resource’daki methodlari kullanarak tek tek kaynakları da alabilirsiniz. Accessing resources from XML . Accessing original files . Accessing platform resources . Providing the best device compatibility with resources . How Android finds the best-matching resources . ",
    "url": "/docs/app-basics/app-resources/about-app-resources/",
    
    "relUrl": "/docs/app-basics/app-resources/about-app-resources/"
  },"11": {
    "doc": "About app shortcuts",
    "title": "About app shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/about-app-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/about-app-shortcuts/"
  },"12": {
    "doc": "About data binding",
    "title": "About data binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/about-data-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/about-data-binding/"
  },"13": {
    "doc": "About dependency injection",
    "title": "About dependency injection",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/about-dependency-injection/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/about-dependency-injection/"
  },"14": {
    "doc": "About fragments",
    "title": "About fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/about-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/about-fragments/"
  },"15": {
    "doc": "About modularization",
    "title": "About modularization",
    "content": " ",
    "url": "/docs/app-architecture/modularization/about-modularization/",
    
    "relUrl": "/docs/app-architecture/modularization/about-modularization/"
  },"16": {
    "doc": "About Paging 2",
    "title": "About Paging 2",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/about-paging-2/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/about-paging-2/"
  },"17": {
    "doc": "About paging",
    "title": "About paging",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/about-paging/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/about-paging/"
  },"18": {
    "doc": "About Play Feature Delivery",
    "title": "Overview of Play Feature Delivery",
    "content": "Google Play’in uygulama sunma modeli, her kullanıcının cihaz yapılandırması için optimize edilmiş APK’lar oluşturmak ve sunmak için Android App Bundle‘ları kullanır, böylece kullanıcılar yalnızca uygulamanızı çalıştırmak için ihtiyaç duydukları kodu ve kaynakları indirir. Play Feature Delivery, app bundle’ların gelişmiş özelliklerini kullanarak uygulamanızın belirli özelliklerinin koşullu olarak sunulmasına veya isteğe bağlı olarak indirilmesine olanak tanır. Bunu yapmak için öncelikle bu özellikleri base app’inizden feature modüllerine ayırmanız gerekir. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#overview-of-play-feature-delivery",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#overview-of-play-feature-delivery"
  },"19": {
    "doc": "About Play Feature Delivery",
    "title": "Feature module build configuration",
    "content": "Android Studio kullanarak yeni bir feature modülü oluşturduğunuzda, IDE aşağıdaki Gradle eklentisini modülün build.gradle dosyasına uygular. // The following applies the dynamic-feature plugin to your feature module. // The plugin includes the Gradle tasks and properties required to configure and build // an app bundle that includes your feature module. plugins { id 'com.android.dynamic-feature' } . Standart application plugin için kullanılabilen özelliklerin çoğu feature modülünüz için de kullanılabilir. Aşağıdaki bölümlerde, feature modülünüzün build configuration’ına dahil etmeniz ve etmemeniz gereken özellikler açıklanmaktadır. What not to include in the feature module build configuration . Her feature modülü base modüle bağlı olduğundan, belirli yapılandırmaları da miras alır. Bu nedenle, feature modülünün build.gradle dosyasında aşağıdakileri eklememelisiniz: . | Signing configurations: App bundle’lar, base modülde belirttiğiniz signing configurations kullanılarak imzalanır. | The minifyEnabled property: Tüm uygulama projeniz için kod küçültmeyi yalnızca base modülün build configuration’undan etkinleştirebilirsiniz. Bu nedenle, bu özelliği feature modüllerinden çıkarmanız gerekir. Bununla birlikte, her feature modülü için ek ProGuard kuralları belirleyebilirsiniz. | versionCode ve versionName: Gradle, app bundle’ınızı oluştururken base modülün sağladığı app versiyon bilgilerini kullanır. Bu özellikleri feature modülünüzün build.gradle dosyasından çıkarmanız gerekir. | . Establish a relationship to the base module . Android Studio feature modülünüzü oluşturduğunda, aşağıda gösterildiği gibi base modülün build.gradle dosyasına android.dynamicFeatures property’sini ekleyerek onu base modül için görünür hale getirir: . // In the base module’s build.gradle file. android { ... // Specifies feature modules that have a dependency on // this base module. dynamicFeatures = [\":dynamic_feature\", \":dynamic_feature2\"] } . Ayrıca Android Studio, aşağıda gösterildiği gibi base modülü feature modülünün bir bağımlılığı olarak içerir: . // In the feature module’s build.gradle file: ... dependencies { ... // Declares a dependency on the base module, ':app'. implementation project(':app') } . Specify additional ProGuard rules . Yalnızca base modülün build configuration’ı uygulama projeniz için kod küçültmeyi etkinleştirebilse de, aşağıda gösterildiği gibi proguardFiles özelliğini kullanarak her feature modülüyle birlikte özel ProGuard kuralları sağlayabilirsiniz. android.buildTypes { release { // You must use the following property to specify additional ProGuard // rules for feature modules. proguardFiles 'proguard-rules-dynamic-features.pro' } } . Bu ProGuard kurallarının derleme sırasında diğer modüllerdekilerle (base modül dahil) birleştirildiğini unutmayın. Dolayısıyla, her feature modülü yeni bir kural kümesi belirleyebilse de, bu kurallar uygulama projesindeki tüm modüller için geçerlidir. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#feature-module-build-configuration",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#feature-module-build-configuration"
  },"20": {
    "doc": "About Play Feature Delivery",
    "title": "Deploy your app",
    "content": "Uygulamanızı feature modülleri desteğiyle geliştirirken, menü çubuğundan Run &gt; Run’ı seçerek (veya araç çubuğunda Run’a tıklayarak) uygulamanızı normalde yaptığınız gibi bağlı bir cihaza deploy edebilirsiniz. Uygulama projeniz bir veya daha fazla feature modülü içeriyorsa, mevcut run/debug configuration‘nızı aşağıdaki gibi değiştirerek uygulamanızı deploy ederken hangi özelliklerin dahil edileceğini seçebilirsiniz: . | Menü çubuğundan Run (Çalıştır) &gt; Edit Configurations (Yapılandırmaları Düzenle) öğesini seçin. | Çalıştır/Debug Yapılandırmaları iletişim kutusunun sol panelinden istediğiniz Android App configuration seçin. | Genel sekmesindeki Dağıtılacak dinamik özellikler altında, uygulamanızı dağıtırken dahil etmek istediğiniz her özellik modülünün yanındaki kutuyu işaretleyin. | Tamam’a tıklayın. | . Varsayılan olarak, Android Studio uygulamanızı deploy etmek için app bundle’ları kullanmaz. Bunun yerine IDE, APK boyutu yerine deployment hızı için optimize edilmiş APK’lar oluşturur ve cihazınıza yükler. Android Studio’yu bunun yerine APK’ları ve anlık deneyimleri bir app bundle’dan derleyip deploy edecek şekilde yapılandırmak için run/debug configuration’ınızı değiştirin. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#deploy-your-app",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#deploy-your-app"
  },"21": {
    "doc": "About Play Feature Delivery",
    "title": "Use feature modules for custom delivery",
    "content": "Feature modüllerinin benzersiz bir avantajı, uygulamanızın farklı özelliklerinin Android 5.0 (API düzeyi 21) veya daha yüksek sürümleri çalıştıran cihazlara nasıl ve ne zaman indirileceğini özelleştirebilmenizdir. Örneğin, uygulamanızın ilk indirme boyutunu azaltmak için, belirli özellikleri isteğe bağlı olarak indirilecek şekilde ya da yalnızca fotoğraf çekme veya artırılmış gerçeklik özelliklerini destekleme gibi belirli özellikleri destekleyen cihazlar tarafından indirilecek şekilde yapılandırabilirsiniz. Uygulamanızı bir app bundle olarak yüklediğinizde varsayılan olarak son derece optimize edilmiş indirmeler elde etseniz de, daha gelişmiş ve özelleştirilebilir feature delivery seçenekleri, feature modülleri kullanarak uygulamanızın özelliklerinin ek yapılandırılmasını ve modüler hale getirilmesini gerektirir. Yani feature modülleri, her biri gerektiğinde indirilecek şekilde yapılandırabileceğiniz modüler özellikler oluşturmak için yapı taşları sağlar. Kullanıcılarınızın çevrimiçi bir pazarda mal alıp satmasına olanak tanıyan bir uygulama düşünün. Uygulamanın aşağıdaki işlevlerinin her birini ayrı feature modülleri halinde makul bir şekilde modüler hale getirebilirsiniz: . | Hesap girişi ve oluşturma | Pazaryerinde gezinme | Satış için bir ürün yerleştirme | Ödemelerin işlenmesi | . Aşağıdaki tabloda feature modüllerinin desteklediği farklı teslimat seçenekleri ve bunların örnek market uygulamasının ilk indirme boyutunu optimize etmek için nasıl kullanılabileceği açıklanmaktadır. | Delivery option | Behavior | Sample use-case | Getting started | . | Install-time delivery | Yukarıda açıklanan teslim seçeneklerinden herhangi birini yapılandırmayan feature modülleri, varsayılan olarak uygulama yüklendiğinde indirilir. Bu önemli bir davranıştır çünkü gelişmiş teslimat seçeneklerini kademeli olarak benimseyebileceğiniz anlamına gelir. Örneğin, uygulamanızın özelliklerini modüler hale getirmekten faydalanabilir ve isteğe bağlı teslimi(on-demand delivery) ancak Play Feature Delivery Library’yi kullanarak isteğe bağlı indirmeleri tam olarak uyguladıktan sonra etkinleştirebilirsiniz. Buna ek olarak, uygulamanız özellikleri daha sonra kaldırmayı talep edebilir. Yani, uygulama yüklenirken belirli özelliklere ihtiyaç duyuyor ancak sonrasında ihtiyaç duymuyorsanız, özelliğin cihazdan kaldırılmasını talep ederek yükleme boyutunu azaltabilirsiniz. | Uygulamanın, pazaryerinde nasıl ürün alınıp satılacağına ilişkin etkileşimli bir kılavuz gibi belirli eğitim activityleri varsa, bu özelliği varsayılan olarak uygulama yüklemesine dahil edebilirsiniz.&lt;/br&gt;Ancak, uygulamanın yüklü boyutunu azaltmak için, kullanıcı eğitimi tamamladıktan sonra uygulama feature’ı silmeyi talep edebilir. | Gelişmiş delivery seçeneklerini yapılandırmayan feature modüllerini kullanarak Modularize your app.&lt;/br&gt;Kullanıcının artık ihtiyaç duymayabileceği belirli feature modüllerini kaldırarak uygulamanızın yüklü boyutunu nasıl azaltacağınızı öğrenmek için Manage installed modules bölümünü okuyun. | . | On demand delivery | Uygulamanızın gerektiğinde feature modülleri talep etmesini ve indirmesini sağlar. | Pazaryeri uygulamasını kullananların yalnızca %20’si satış için ürün gönderiyorsa, kullanıcıların çoğunluğu için ilk indirme boyutunu azaltmak için iyi bir strateji, fotoğraf çekme, ürün açıklaması ekleme ve satış için bir ürün yerleştirme işlevlerini isteğe bağlı indirme olarak kullanılabilir hale getirmektir. Yani, uygulamanın satış işlevi için feature modülünü yalnızca bir kullanıcı pazaryerine satılık ürün yerleştirmeye ilgi gösterdiğinde indirilecek şekilde yapılandırabilirsiniz.&lt;/br&gt;Ek olarak, kullanıcı belirli bir süre sonra artık ürün satmazsa, uygulama özelliği kaldırmayı talep ederek yüklü boyutunu azaltabilir. | Bir feature modülü ve configure on demand delivery oluşturun. Uygulamanız daha sonra modülü on demand(talep uzerine) indirmeyi istemek için Play Feature Delivery Library kullanabilir. | . | Conditional delivery | Modülerleştirilmiş bir özelliğin uygulama yüklemesinde indirilip indirilmeyeceğini belirlemek için donanım özellikleri, yerel ayar ve minimum API düzeyi gibi belirli kullanıcı cihazı gereksinimlerini belirtmenize olanak tanır. | Pazaryeri uygulaması küresel erişime sahipse, yalnızca belirli bölgelerde veya yerel halkta popüler olan ödeme yöntemlerini desteklemeniz gerekebilir. İlk uygulama indirme boyutunu azaltmak için, belirli ödeme yöntemlerini işlemek üzere ayrı feature modülleri oluşturabilir ve bunların kayıtlı yerel ayarlarına göre kullanıcının cihazına koşullu olarak yüklenmesini sağlayabilirsiniz. | Bir feature modülü oluşturun ve conditional delivery‘i yapılandırın. | . | Instant delivery | Google Play Instant, kullanıcıların uygulamayı cihazlarına yüklemelerine gerek kalmadan uygulamanızla etkileşime geçmelerini sağlar. Bunun yerine, Google Play Store’daki “Şimdi Dene” düğmesi veya sizin oluşturduğunuz bir URL aracılığıyla uygulamanızı deneyimleyebilirler. Bu içerik sunma biçimi, uygulamanızla etkileşimi artırmanızı kolaylaştırır. &lt;/br&gt;Instant delivery ile, kullanıcılarınızın uygulamanızın belirli özelliklerini yükleme yapmadan anında deneyimlemelerini sağlamak için Google Play Instant’ı kullanabilirsiniz. | Oyunun ilk birkaç seviyesini hafif bir feature modülüne dahil eden bir oyun düşünün. Bu modülü instant-enable edeblirsiniz, böylece kullanıcılar uygulama yüklemeden bir URL bağlantısı veya “Şimdi Dene” düğmesi aracılığıyla oyunu anında deneyimleyebilirler. | Bir feature modülü oluşturun ve instant delivery’i yapılandırın. Uygulamanız daha sonra modülü talep üzerine(on demand) indirmeyi istemek için Play Feature Delivery Library’yi kullanabilir.&lt;/br&gt;Uygulama özelliklerinizi feature modülleri kullanarak modüler hale getirmenin yalnızca ilk adım olduğunu unutmayın. Google Play Instant’ı desteklemek için, uygulamanızın temel modülünün ve instant-enabled özelliğinin indirme boyutunun katı boyut kısıtlamalarını karşılaması gerekir. Daha fazla bilgi edinmek için Uygulama veya oyun boyutunu küçülterek anlık deneyimleri etkinleştirin başlıklı makaleyi okuyun. | . ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#use-feature-modules-for-custom-delivery",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#use-feature-modules-for-custom-delivery"
  },"22": {
    "doc": "About Play Feature Delivery",
    "title": "Buildig a URI for a resource",
    "content": "Bir URI kullanarak bir feature modülünde depolanan bir kaynağa erişmek istiyorsanız, Uri.Builder() kullanarak bir feature modülü kaynak URI’sinin nasıl oluşturulacağı aşağıda açıklanmıştır: . val uri = Uri.Builder() .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE) .authority(context.getPackageName()) // Look up the resources in the application with its splits loaded .appendPath(resources.getResourceTypeName(resId)) .appendPath(String.format(\"%s:%s\", resources.getResourcePackageName(resId), // Look up the dynamic resource in the split namespace. resources.getResourceEntryName(resId) )) .build() . Kaynağa giden yolun her bir parçası çalışma zamanında oluşturulur ve split APK’lar yüklendikten sonra doğru namespace’in oluşturulmasını sağlar. URI’nin nasıl oluşturulduğuna bir örnek olarak, aşağıdaki adlara sahip bir uygulamanız ve feature modülleriniz olduğunu varsayalım: . | Uygulama paketinin adı: com.example.my_app_package | Özelliğin kaynak paket adı: com.example.my_app_package.my_dynamic_feature | . Yukarıdaki kod parçasında resId, feature modülünüzde “my_video” adlı bir ham dosya kaynağını ifade ediyorsa, yukarıdaki Uri.Builder() kodu aşağıdaki çıktıyı verecektir: . android.resource://com.example.my_app_package/raw/com.example.my_app_package.my_dynamic_feature:my_video . Bu URI daha sonra uygulamanız tarafından feature modülünün kaynağına erişmek için kullanılabilir. URI’nizdeki yolları doğrulamak için, feature modülü APK’nızı incelemek ve paket adını belirlemek üzere APK Analyzer kullanabilirsiniz: . Şekil 2. Derlenmiş bir kaynak dosyasındaki paket adını incelemek için APK Analyzer’ı kullanın. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#buildig-a-uri-for-a-resource",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#buildig-a-uri-for-a-resource"
  },"23": {
    "doc": "About Play Feature Delivery",
    "title": "Considerations for feature modules",
    "content": "Feature modülleri ile derleme hızını ve mühendislik hızını artırabilir ve uygulamanızın boyutunu küçültmek için uygulamanızın özelliklerinin dağıtımını kapsamlı bir şekilde özelleştirebilirsiniz. Ancak feature modüllerini kullanırken akılda tutulması gereken bazı kısıtlamalar ve istisnai durumlar vardır: . | Koşullu(conditional) veya isteğe bağlı(on-demand) dağıtım yoluyla tek bir cihaza 50 veya daha fazla feature modülü yüklemek performans sorunlarına yol açabilir. Kaldırılabilir olarak yapılandırılmayan yükleme zamanı(install-time) modülleri otomatik olarak base modüle dahil edilir ve her cihazda yalnızca bir feature modülü olarak sayılır. | Yükleme zamanı(install-time) delivery için kaldırılabilir olarak yapılandırdığınız modül sayısını 10 veya daha az ile sınırlandırın. Aksi takdirde, uygulamanızın indirme ve yükleme süresi artabilir. | Yalnızca Android 5.0 (API düzeyi 21) ve üzeri sürümleri çalıştıran cihazlar talep üzerine(on-demand) özellik indirmeyi ve yüklemeyi destekler. Özelliğinizi Android’in önceki sürümlerinde kullanılabilir hale getirmek için, bir feature modülü oluşturduğunuzda [Fusing] özelliğini etkinleştirin. | SplitCompat‘ı etkinleştirin, böylece uygulamanız talep üzerine teslim edilen (on-demand delivery)indirilmiş feature modüllerine erişebilir. | Feature modülleri, manifestolarında android:exported true olarak ayarlanmış activityleri belirtmemelidir. Bunun nedeni, başka bir uygulama activity’yi başlatmaya çalıştığında cihazın feature modülünü indirdiğine dair bir garanti olmamasıdır. Ayrıca, uygulamanız koduna ve kaynaklarına erişmeye çalışmadan önce bir özelliğin indirildiğini onaylamalıdır. Daha fazla bilgi edinmek için Managed Installed modules bölümünü okuyun. | Play Feature Delivery, uygulamanızı bir app bundle kullanarak yayınlamanızı gerektirdiğinden, app bundle’ın bilinen sorunlarından haberdar olduğunuzdan emin olun. | . ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#considerations-for-feature-modules",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#considerations-for-feature-modules"
  },"24": {
    "doc": "About Play Feature Delivery",
    "title": "Feature module manifest reference",
    "content": "Android Studio kullanarak yeni bir feature module oluştururken, IDE modülün bir feature module gibi davranması için gereken manifesto niteliklerinin çoğunu içerir. Ayrıca, bazı özellikler derleme sırasında derleme sistemi tarafından enjekte edilir, bu nedenle bunları sizin belirtmeniz veya değiştirmeniz gerekmez. Aşağıdaki tabloda feature modüller için önemli olan manifesto attributeleri açıklanmaktadır. | Attribute | Description | . | &lt;manifest&lt;/br&gt; … | - | . | xmlns:dist=”http://schemas.android.com/apk/distribution” | - | . | split=”split_name” | - | . | android:isFeatureSplit=”true | false”&gt; | - | . | &lt;dist:module | - | . | dist:instant=”true | false” | - | . | dist:title=”@string/feature_name” | - | . | &lt;/dist:module&gt; | - | . | | - | . | | - | . | | - | . | &lt;/dist:install-time&gt; | - | . | | - | . | &lt;/dist:delivery&gt; | - | . | ... | - | . Not: Feature modülleri, manifestolarında android:exported değeri true olarak ayarlanmış aktiviteleri belirtmemelidir. Bunun nedeni, başka bir uygulama activity’yi başlatmaya çalıştığında cihazın feature modülünü indirdiğine dair bir garanti olmamasıdır. Ayrıca, uygulamanız koduna ve kaynaklarına erişmeye çalışmadan önce bir özelliğin indirildiğini onaylamalıdır. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#feature-module-manifest-reference",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#feature-module-manifest-reference"
  },"25": {
    "doc": "About Play Feature Delivery",
    "title": "Additional resources",
    "content": "Feature modüllerini kullanma hakkında daha fazla bilgi edinmek için aşağıdaki kaynakları deneyin. Blog posts . Videos . ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#additional-resources",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#additional-resources"
  },"26": {
    "doc": "About Play Feature Delivery",
    "title": "About Play Feature Delivery",
    "content": " ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/"
  },"27": {
    "doc": "About resource types",
    "title": "About resource types",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/about-resource-types/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/about-resource-types/"
  },"28": {
    "doc": "About The Android App Bundle format",
    "title": "The Android App Bundle format",
    "content": "Android App Bundle, Google Play’e yüklediğiniz bir dosyadır (.aab dosya uzantılı). App bundle’lar, uygulamanızın kodunu ve kaynaklarını şekil 1’de gösterildiği gibi modüller halinde düzenleyen imzalı binary’lerdir. Her modülün kodu ve kaynakları, bir APK’da bulacağınıza benzer şekilde düzenlenir ve bu mantıklıdır çünkü bu modüllerin her biri ayrı APK’lar olarak oluşturulabilir. Google Play daha sonra base APK, feature APK’ları, configuration APK’ları ve ( split APK’ları desteklemeyen cihazlar için) multi-APK’lar gibi kullanıcılara sunulan çeşitli APK’ları oluşturmak için app bundle’ı kullanır. Drawable/, values/ ve lib/ dizinleri gibi mavi renkli dizinler, Google Play’in her modül için konfigürasyon APK’ları oluşturmak için kullandığı kod ve kaynakları temsil eder. Şekil 1. Android App Bundle. Bir base modül, iki feature modülü ve iki asset paketi içeren bir Android App Bundle’ın içeriği. Not: Her benzersiz uygulama veya applicationID için bir app bundle oluşturursunuz. Yani, tek bir uygulama projesinden uygulamanızın birden çok sürümünü oluşturmak için product flavors kullanıyorsanız ve bu sürümlerin her biri benzersiz bir applicationID kullanıyorsa, uygulamanızın her sürümü için ayrı bir app bundle oluşturmanız gerekir. Aşağıdaki listede app bundle’ın bazı dosya ve dizinleri daha ayrıntılı olarak açıklanmaktadır: . | base/, feature1/ ve feature2/: Bu top-level dizinlerin her biri uygulamanızın farklı bir modülünü temsil eder. Uygulamanızın base modülü her zaman app bundle’ın base dizininde bulunur. Ancak her bir feature modülünün dizinine, modülün manifestosundaki split attribute’i tarafından belirtilen ad verilir. Daha fazla bilgi edinmek için feature module manifest hakkında bilgi edinin. | asset_pack_1/ ve asset_pack_2/: Büyük, grafik gerektiren uygulamalar veya oyunlar için assetleri asset paketleri halinde modülerleştirebilirsiniz. Asset paketleri, büyük boyut sınırları nedeniyle oyunlar için idealdir. Her bir asset paketinin bir cihaza nasıl ve ne zaman indirileceğini üç teslim moduna göre özelleştirebilirsiniz: yükleme zamanı(install-time), hızlı takip(fast-follow) ve talep üzerine(on-demand). Tüm asset paketleri Google Play’de barındırılır ve buradan sunulur. App bundle’ınıza asset paketlerini nasıl ekleyeceğiniz hakkında daha fazla bilgi edinmek için Play Asset Delivery‘ye genel bakış bölümüne bakın. | BUNDLE-METADATA/: Bu dizin, araçlar veya uygulama mağazaları için yararlı bilgiler içeren meta data dosyalarını içerir. Bu tür meta data dosyaları ProGuard eşlemelerini ve uygulamanızın DEX dosyalarının tam listesini içerebilir. Bu dizindeki dosyalar uygulamanızın APK’larında paketlenmez. | Module Protocol Buffer (.pb) dosyaları:* Bu dosyalar, Google Play gibi uygulama mağazalarına her bir uygulama modülünün içeriğini açıklamaya yardımcı olan meta datalar sağlar. Örneğin, BundleConfig.pb, app bundle’ı oluşturmak için derleme araçlarının hangi sürümünün kullanıldığı gibi bundle’ın kendisi hakkında bilgi sağlar ve native.pb ve resources.pb, Google Play APK’ları farklı cihaz yapılandırmaları için optimize ederken yararlı olan her modüldeki kodu ve kaynakları açıklar. | manifest/: APK’ların aksine, app bundle’lar her modülün AndroidManifest.xml dosyasını bu ayrı dizinde saklar. | dex/: APK’ların aksine, app bundle’lar her modül için DEX dosyalarını bu ayrı dizinde saklar. | res/, lib/ ve assets/: Bu dizinler tipik bir APK’daki dizinlerle aynıdır. App bundle’ınızı yüklediğinizde, Google Play bu dizinleri inceler ve dosya yollarını koruyarak yalnızca hedef cihaz yapılandırmasını karşılayan dosyaları paketler. | root/: Bu dizin, daha sonra bu dizinin bulunduğu modülü içeren herhangi bir APK’nın root’una taşınacak dosyaları depolar. Örneğin, bir app bundle’ın base/root/ dizini, uygulamanızın Class.getResource() kullanarak yüklediği Java tabanlı kaynakları içerebilir. Bu dosyalar daha sonra uygulamanızın base APK’sının ve Google Play’in oluşturduğu her çoklu APK’nın root dizinine taşınır. Bu dizin içindeki path’ler de korunur. Yani, dizinler (ve alt dizinleri) de APK’nın root dizinine taşınır. | . Dikkat: Bu dizindeki içerik APK’nın root dizinindeki diğer dosya ve dizinlerle çakışırsa, Play Console yükleme sırasında tüm app bundle’ı reddeder. Örneğin, bir root/lib/ dizini ekleyemezsiniz çünkü bu, her APK’nın zaten içerdiği lib diziniyle çakışır. ",
    "url": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/#the-android-app-bundle-format",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/#the-android-app-bundle-format"
  },"29": {
    "doc": "About The Android App Bundle format",
    "title": "Overview of split APKs",
    "content": "Optimize edilmiş uygulamalar sunmanın temel bileşenlerinden biri Android 5.0 (API seviyesi 21) ve üzeri sürümlerde bulunan split APK mekanizmasıdır. Split APK’lar normal APK’lara çok benzer; derlenmiş DEX bytecode, kaynaklar ve bir Android manifestosu içerirler. Ancak, Android platformu birden fazla yüklü split APK’yı tek bir uygulama olarak değerlendirebilir. Yani, ortak kod ve kaynaklara erişimi olan birden fazla split APK yükleyebilir ve cihazda yüklü tek bir uygulama olarak görünebilirsiniz. Split APK’ların avantajı, monolitik bir APK’yı (yani uygulamanızın desteklediği tüm özellikler ve cihaz yapılandırmaları için kod ve kaynaklar içeren bir APK), kullanıcının cihazına gerektiği gibi yüklenen daha küçük, ayrı paketlere ayırma yeteneğidir. Örneğin, bir split APK yalnızca birkaç kullanıcınızın ihtiyaç duyduğu ek bir özelliğin kodunu ve kaynaklarını içerirken, başka bir split APK yalnızca belirli bir dil veya ekran yoğunluğu için kaynakları içerebilir. Bu split APK’ların her biri, kullanıcı talep ettiğinde veya cihaz tarafından gerekli görüldüğünde indirilir ve yüklenir. Aşağıda, tam uygulama deneyiminizi oluşturmak için bir cihaza birlikte yüklenebilecek farklı APK türleri açıklanmaktadır. Uygulama projenizi bu APK’ları destekleyecek şekilde nasıl yapılandıracağınızı bu sayfanın ilerleyen bölümlerinde öğreneceksiniz. | Base APK: Bu APK, diğer tüm split APK’ların erişebileceği kod ve kaynakları içerir ve uygulamanız için temel işlevselliği sağlar. Bir kullanıcı uygulamanızı indirmek istediğinde, ilk olarak bu APK indirilir ve yüklenir. Bunun nedeni, yalnızca base APK’nın manifestosunun uygulamanızın servisleri, content providerlari, izinleri, platform sürümü gereksinimleri ve sistem özelliklerine olan bağımlılıklarının tam bir bildirimini içermesidir. Google Play, uygulamanız için base APK’yı projenizin app (veya base) modülünden oluşturur. Uygulamanızın ilk indirme boyutunu küçültmekle ilgileniyorsanız, bu modüle dahil edilen tüm kod ve kaynakların uygulamanızın base APK’sına dahil edildiğini aklınızda bulundurmanız önemlidir. | Configuration APKs: Bu APK’ların her biri belirli bir ekran yoğunluğu, CPU mimarisi veya dil için yerel kütüphaneler ve kaynaklar içerir. Bir kullanıcı uygulamanızı indirdiğinde, cihazı yalnızca kendi cihazını hedefleyen configuration APK’ları indirir ve yükler. Her configuration APK, bir base APK veya feature module APK’nın bağımlılığıdır. Yani, kod ve kaynak sağladıkları APK ile birlikte indirilir ve yüklenirler. Base ve feature modüllerinin aksine, configuration APK’lar için ayrı bir modül oluşturmazsınız. Base ve feature modülleriniz için alternatif, configuration’a özgü kaynakları düzenlemek üzere standart pratikler kullanırsanız, Google Play sizin için configuration APK’ları otomatik olarak oluşturur. | Feature module APKs: Bu APK’ların her biri, feature modülleri kullanarak modüler hale getirdiğiniz uygulamanızın bir özelliği için kod ve kaynaklar içerir. Daha sonra bu özelliğin bir cihaza nasıl ve ne zaman indirileceğini özelleştirebilirsiniz. Örneğin, Play Core Library kullanılarak, kullanıcıya ek işlevsellik sağlamak için base APK cihaza yüklendikten sonra özellikler isteğe bağlı olarak yüklenebilir. Fotoğraf çekme ve gönderme özelliğini yalnızca kullanıcı bu işlevi kullanmayı talep ettiğinde indirip yükleyen bir sohbet uygulaması düşünün. Feature modülleri yükleme sırasında mevcut olmayabileceğinden, tüm ortak kod ve kaynakları base APK’ya dahil etmelisiniz. Yani, feature modülünüz yükleme sırasında yalnızca base APK’nın kod ve kaynaklarının mevcut olduğunu varsaymalıdır. Google Play, projenizin feature modüllerinden uygulamanız için feature modül APK’ları oluşturur. | . Üç feature modülüne sahip ve birden fazla cihaz yapılandırmasını destekleyen bir uygulama düşünün. Aşağıdaki Şekil 1, uygulamanın çeşitli APK’ları için bağımlılık ağacının nasıl görünebileceğini göstermektedir. Base APK’nın ağacın başını oluşturduğunu ve diğer tüm APK’ların base APK’ya bağlı olduğunu unutmayın. (Bu APK’lar için modüllerin bir Android App Bundle’da nasıl temsil edildiğini merak ediyorsanız, Android App Bundle formatına bakın) . Şekil 1. Split APK’lar kullanılarak sunulan bir uygulama için bağımlılık ağacı . Unutmayın, bu APK’ları kendiniz oluşturmanıza gerek yoktur; Google Play, Android Studio ile oluşturduğunuz tek bir imzalı app bundle kullanarak bunu sizin için yapar. App Bundle formatı ve nasıl oluşturulacağı hakkında daha fazla bilgi edinmek için Android App Bundle’ları oluşturma, dağıtma ve yükleme bölümü ne gidin. Devices running Android 4.4 (API level 19) and lower . Android 4.4 (API düzeyi 19) ve daha düşük sürümleri çalıştıran cihazlar split APK’ların indirilmesini ve yüklenmesini desteklemediğinden, Google Play bunun yerine bu cihazlara multi-APK adı verilen ve cihazın yapılandırması için optimize edilmiş tek bir APK sunar. Yani, multi-APK’ler tam uygulama deneyiminizi temsil eder ancak diğer ekran yoğunlukları ve CPU mimarileri için olanlar gibi gereksiz kod ve kaynakları içermez. Bununla birlikte, uygulamanızın desteklediği tüm diller için kaynaklar içerirler. Bu, örneğin kullanıcıların farklı bir multi-APK indirmek zorunda kalmadan uygulamanızın tercih ettiği dil ayarını değiştirmesine olanak tanır. Multi-APK’ler, feature modüllerini daha sonra isteğe bağlı olarak indirme özelliğine sahip değildir. Bu APK’ya bir feature modülü eklemek için, feature modülünü oluştururken Talep Üzerine(On-demand) özelliğini devre dışı bırakmanız veya Fusing özelliğini etkinleştirmeniz gerekir. App Bundle’larda uygulamanızın desteklediği her cihaz yapılandırması için APK oluşturmanız, imzalamanız, yüklemeniz ve yönetmeniz gerekmediğini unutmayın. Yine de tüm uygulamanız için tek bir app bundle oluşturup yüklüyorsunuz ve gerisini Google Play sizin için hallediyor. Dolayısıyla, Android 4.4 veya daha düşük sürümleri çalıştıran cihazları desteklemeyi planlasanız da planlamasanız da, Google Play hem siz hem de kullanıcılarınız için esnek bir hizmet mekanizması sağlar. User language changes . App bundle’lar ile cihazlar yalnızca uygulamanızı çalıştırmak için ihtiyaç duydukları kodu ve kaynakları indirir. Dolayısıyla, dil kaynakları için, kullanıcının cihazı yalnızca cihaz ayarlarında seçili olan bir veya daha fazla dille eşleşen uygulamanızın dil kaynaklarını indirir. Bir kullanıcı cihaz ayarlarında dilini değiştirdiğinde, uygulamanın yeni dilde görüntülenebilmesi için Google Play’in bazı ek split APK’ları indirmesi ve yüklemesi gerekebilir. Google Play, geçişten hemen sonra ek dilleri indirmeye çalışır. Kullanıcı cihazı çevrimdışıysa, indirme başarısız olursa veya kaynaklar çok büyükse Google Play, cihaz koşulları daha uygun olduğunda arka planda indirmeyi tekrar dener. Android 9.0 (API seviyesi 28) veya daha düşük bir cihazda çalışırken, yeni language split APK’ların yüklenmesi sırasında uygulamanız ön plandaysa, uygulama öldürülür. Uygulamanız tüm dillerin cihazda her zaman kullanılabilir olmasını gerektiriyorsa, derleme yapılandırmanızda language split’i devre dışı bırakabilirsiniz. Uygulamanız cihaz ayarlarında seçilen kullanıcı dillerinden bağımsız olarak ek dillerin indirilmesini gerektiriyorsa ( örneğin uygulama içi bir dil seçici uygulamak için), bunları isteğe bağlı olarak indirmek için Play Core kütüphanesini kullanabilirsiniz. ",
    "url": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/#overview-of-split-apks",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/#overview-of-split-apks"
  },"30": {
    "doc": "About The Android App Bundle format",
    "title": "About The Android App Bundle format",
    "content": " ",
    "url": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/"
  },"31": {
    "doc": "About the data layer",
    "title": "Data Layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer/#data-layer",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer/#data-layer"
  },"32": {
    "doc": "About the data layer",
    "title": "About the data layer",
    "content": "UI katmanı UI ile ilgili state ve UI logic’i içerirken, data katmanı uygulama verilerini ve business logic’i içerir. Business logic (iş mantığı) uygulamanıza değer katan şeydir; uygulama verilerinin nasıl oluşturulması, saklanması ve değiştirilmesi gerektiğini belirleyen gerçek dünya iş kurallarından oluşur. Separation of concerns ilkesinin bu sekilde olması, veri katmanının birden fazla ekranda kullanılmasına, uygulamanın farklı bölümleri arasında bilgi paylaşılmasına ve birim testi için iş mantığının kullanıcı arayüzünün dışında yeniden üretilmesine olanak tanır. Data katmanının faydaları hakkında daha fazla bilgi için Architecture Overview sayfasına göz atın. ot: Bu sayfada yer alan öneriler ve best practiceler, ölçeklenmelerini sağlamak, kaliteyi ve sağlamlığı artırmak ve test edilmelerini kolaylaştırmak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Architecture: The data layer - MAD Skills . Data layer architecture . Data katmanı, her biri sıfır ila çok sayıda veri kaynağı içerebilen repository’lerden oluşur. Uygulamanızda işlediğiniz her farklı veri türü için bir repository sınıfı oluşturmalısınız. Örneğin, filmlerle ilgili veriler için bir MoviesRepository sınıfı veya ödemelerle ilgili veriler için bir PaymentsRepository sınıfı oluşturabilirsiniz. Repository sınıfları aşağıdaki görevlerden sorumludur: . | Verilerin uygulamanın geri kalanına sunulması. | Verilerdeki değişiklikleri merkezileştirme. | Birden fazla veri kaynağı arasındaki çakışmaları çözme. | Uygulamanın geri kalanından veri kaynaklarını soyutlama. | Business logic’i içermek. | . Her veri kaynağı sınıfı(data source class) , bir dosya, bir network kaynağı veya local veritabanı olabilen sadece tek bir veri kaynağı ile çalışma sorumluluğuna sahip olmalıdır. Veri kaynağı sınıfları, veri işlemleri için uygulama ile sistem arasındaki köprüdür. Hiyerarşideki diğer katmanlar veri kaynaklarına asla doğrudan erişmemelidir; data katmanına entry pointler her zaman repository sınıflarıdır. State holder sınıfları (UI katmanı kılavuzuna bakın) veya use case sınıfları (domain katmanı kılavuzuna bakın) hiçbir zaman doğrudan bir bağımlılık olarak bir veri kaynağına sahip olmamalıdır. Repository sınıflarının entry point olarak kullanılması, mimarinin farklı katmanlarının bağımsız olarak ölçeklenebilmesini sağlar. Bu katman tarafından açığa çıkarılan veriler immutable olmalıdır, böylece diğer sınıflar tarafından kurcalanamaz, bu da değerlerini tutarsız bir duruma sokma riski taşır. Immutable veriler birden fazla thread tarafından da güvenli bir şekilde işlenebilir. Daha fazla ayrıntı için thread bölümüne bakın. Dependency injection best practices‘i takiben, repository veri kaynaklarını constructor’ında dependency olarak alır: . class ExampleRepository( private val exampleRemoteDataSource: ExampleRemoteDataSource, // network private val exampleLocalDataSource: ExampleLocalDataSource // database ) { /* ... */ } . Not: Genellikle, bir repository yalnızca tek bir veri kaynağı içerdiğinde ve diğer repository’lere bağlı olmadığında, geliştiriciler repository’lerin ve veri kaynaklarının sorumluluklarını repository sınıfında birleştirir. Bunu yaparsanız, uygulamanızın sonraki bir sürümünde repository’nin başka bir kaynaktan gelen verileri işlemesi gerekiyorsa fonksiyonları bölmeyi unutmayın. Expose APIs . Data katmanındaki sınıflar genellikle tek seferlik Create, Read, Update ve Delete (CRUD) çağrıları gerçekleştirmek veya zaman içindeki veri değişikliklerinden haberdar olmak için fonksiyonları kullanıma sunar. Data katmanı bu durumların her biri için aşağıdakileri sağlamalıdır: . | Tek seferlik işlemler: Data katmanı Kotlin’de suspend fonksiyonlarını kullanıma sunmalıdır; ve Java programlama dili için, data katmanı işlemin sonucunu bildirmek için bir callback sağlayan fonksiyonları veya RxJava Single, Maybe veya Completable tiplerini kullanıma sunmalıdır. | Zaman içindeki veri değişikliklerinden haberdar olmak için: Data katmanı Kotlin’de flow‘ları kullanıma sunmalıdır; ve Java programlama dili için data katmanı yeni veriyi veya RxJava Observable veya Flowable türünü yayınlayan bir callback’i kullanıma sunmalıdır. | . class ExampleRepository( private val exampleRemoteDataSource: ExampleRemoteDataSource, // network private val exampleLocalDataSource: ExampleLocalDataSource // database ) { val data: Flow&lt;Example&gt; = ... suspend fun modifyData(example: Example) { ... } } . Naming conventions in this guide . Bu kılavuzda, repository sınıfları sorumlu oldukları verilere göre adlandırılmıştır. Kurallar aşağıdaki gibidir: . veri türü + Repository. Örneğin: NewsRepository, MoviesRepository veya PaymentsRepository. Veri kaynağı sınıfları, sorumlu oldukları verilerden ve kullandıkları kaynaktan sonra adlandırılır. Kurallar aşağıdaki gibidir: . veri türü + kaynak türü + DataSource. Veri türü için, uygulamalar değişebileceğinden daha genel olması için Remote veya Local kullanın. Örneğin: NewsRemoteDataSource veya NewsLocalDataSource. Kaynağın önemli olması durumunda daha spesifik olmak için kaynağın türünü kullanın. Örneğin: NewsNetworkDataSource veya NewsDiskDataSource. Veri kaynağını bir uygulama detayına göre adlandırmayın (örneğin UserSharedPreferencesDataSource) çünkü bu veri kaynağını kullanan repository’ler verilerin nasıl kaydedildiğini bilmemelidir. Bu kurala uyarsanız, veri kaynağının uygulamasını, bu kaynağı çağıran katmanı etkilemeden değiştirebilirsiniz ( örneğin, SharedPreferences’ tan DataStore‘a geçiş). Not: Bir veri kaynağının yeni bir implementasyonuna geçerken, veri kaynağı için bir interface oluşturabilir ve veri kaynağının iki implementasyonuna sahip olabilirsiniz: biri eski backing teknolojisi için, diğeri de yenisi için. Bu durumda, veri kaynağı sınıf adları için teknolojinin adını kullanmanızda bir sakınca yoktur (bu bir uygulama ayrıntısı olsa bile) çünkü repository veri kaynağı sınıflarının kendisini değil yalnızca interface'i görür. Taşıma işlemini tamamladığınızda, yeni sınıfı, adında uygulama ayrıntısı içermeyecek şekilde yeniden adlandırabilirsiniz. Multiple levels of repositories . Daha karmaşık iş gereksinimlerini içeren bazı durumlarda, bir repository’nin diğer repository’lere bağımlı olması gerekebilir. Bunun nedeni, ilgili verilerin birden fazla veri kaynağından toplanması veya sorumluluğun başka bir repository sınıfında encapsulated edilmesi gerekliligi olabilir. Örneğin, kullanıcı kimlik doğrulama verilerini işleyen bir repository, UserRepository, gereksinimlerini yerine getirmek için LoginRepository ve RegistrationRepository gibi diğer repository’lere bağımlı olabilir. Not: Geleneksel olarak, bazı geliştiriciler diğer repository sınıflarına bağlı olan repository sınıflarını manager olarak adlandırırlar; örneğin UserRepository yerine UserManager. İsterseniz bu adlandırma kuralını kullanabilirsiniz. Source of truth . Her repository’nin tek bir doğruluk kaynağı(single source of truth) tanımlaması önemlidir. Doğruluk kaynağı her zaman tutarlı, doğru ve güncel veriler içerir. Aslında, repository’den açığa çıkan veriler her zaman doğrudan doğruluk kaynağından gelen veriler olmalıdır. Doğruluk kaynağı bir veri kaynağı (örneğin veri tabanı) ya da repository’nin içerebileceği bir in-memory cache olabilir. Repository’ler farklı veri kaynaklarını birleştirir ve veri kaynakları arasındaki olası çakışmaları çözerek tek doğruluk kaynağını düzenli olarak veya bir user input event nedeniyle günceller. Uygulamanızdaki farklı veri repositoryleri farklı doğruluk kaynaklarına sahip olabilir. Örneğin, LoginRepository sınıfı doğruluk kaynağı olarak cache’ini kullanabilir ve PaymentsRepository sınıfı network veri kaynağını kullanabilir. Offline-first desteği sağlamak için, veritabanı gibi local bir veri kaynağı önerilen doğruluk kaynağıdır. Threading . Veri kaynaklarını ve repository’leri çağırmak, main thread’den çağırmak için main-safe/güvenli olmalıdır. Bu sınıflar, uzun süreli bloklama operasyonları gerçekleştirirken logiclerinin yürütülmesini uygun thread’e taşımaktan sorumludur. Örneğin, bir veri kaynağının bir dosyadan okuma yapması ya da bir veri repository’sinin büyük bir liste üzerinde yüklü filtreleme yapması main-safe olmalıdır. Çoğu veri kaynağının Room, Retrofit veya Ktor tarafından sağlanan suspend metot çağrıları gibi main-safe API’leri zaten sağladığını unutmayın. Repositoryniz, kullanılabilir olduklarında bu API’lerden yararlanabilir. Threading hakkında daha fazla bilgi edinmek için background processing kılavuzuna bakın. Kotlin kullanıcıları için coroutine’ler önerilen seçenektir. Java programlama dili için önerilen seçenekler için Android task’larını background thread’lerde çalıştırma bölümüne bakın. Lifecycle . Data katmanındaki sınıfların instance’ları, bir garbage collection root’undan (genellikle uygulamanızdaki diğer nesnelerden referans alınarak) erişilebilir oldukları sürece bellekte kalırlar. Bir sınıf in-memory veriler içeriyorsa (örneğin bir cache), bu sınıfın aynı instance’ını belirli bir süre için yeniden kullanmak isteyebilirsiniz. Bu, sınıf instance’ının yaşam döngüsü olarak da adlandırılır. Sınıfın sorumluluğu tüm uygulama için çok önemliyse, bu sınıfın bir instance’ını Application sınıfına scope edebilirsiniz. Bu, instance’ın uygulamanın yaşam döngüsünü takip etmesini sağlar. Alternatif olarak, aynı instance’ı yalnızca uygulamanızdaki belirli bir akışta (örneğin, kayıt veya oturum açma akışı) yeniden kullanmanız gerekiyorsa, instance’ı bu akışın yaşam döngüsüne sahip olan sınıfa scope etmelisiniz. Örneğin, in-memory veriler içeren bir RegistrationRepository’yi RegistrationActivity’ye veya kayıt akışının navigation graph’ine scope edebilirsiniz. Her bir instance’ın yaşam döngüsü, uygulamanızda bağımlılıkları nasıl sağlayacağınıza karar vermede kritik bir faktördür. Bağımlılıkların yönetildiği ve bağımlılık contaitnerlarina scop edilebildiği dependency injection best practicelerini takip etmeniz önerilir. Android’de scoping hakkında daha fazla bilgi edinmek için Android’de Scoping ve Hilt blog gönderisine bakın. Represent business models . Data katmanından göstermek istediğiniz veri modelleri, farklı veri kaynaklarından aldığınız bilgilerin bir alt kümesi olabilir. İdeal olarak, farklı veri kaynakları (hem network hem de local) yalnızca uygulamanızın ihtiyaç duyduğu bilgileri döndürmelidir; ancak durum genellikle böyle değildir. Örneğin, yalnızca makale bilgilerini değil, aynı zamanda düzenleme geçmişini, kullanıcı yorumlarını ve bazı meta verileri de döndüren bir News API sunucusu düşünün: . data class ArticleApiModel( val id: Long, val title: String, val content: String, val publicationDate: Date, val modifications: Array&lt;ArticleApiModel&gt;, val comments: Array&lt;CommentApiModel&gt;, val lastModificationDate: Date, val authorId: Long, val authorName: String, val authorDateOfBirth: Date, val readTimeMin: Int ) . Uygulama, makale hakkında çok fazla bilgiye ihtiyaç duymaz çünkü ekranda yalnızca makalenin içeriğini ve yazarıyla ilgili temel bilgileri görüntüler. Model sınıflarını ayırmak ve repository’lerinizin yalnızca hiyerarşinin diğer katmanlarının ihtiyaç duyduğu verileri göstermesini sağlamak iyi bir pratiktir. Örneğin, bir Article model sınıfını domain ve UI katmanlarına göstermek için ArticleApiModel’i ağdan şu şekilde kırpabilirsiniz: . data class Article( val id: Long, val title: String, val content: String, val publicationDate: Date, val authorName: String, val readTimeMin: Int ) . Model sınıflarını ayırmak aşağıdaki şekillerde faydalıdır: . | Verileri yalnızca ihtiyaç duyulana indirgeyerek uygulama belleğinden tasarruf sağlar. | Harici veri türlerini uygulamanız tarafından kullanılan veri türlerine uyarlar - örneğin, uygulamanız tarihleri temsil etmek için farklı bir veri türü kullanabilir. | Separation of concers ilkesini daha iyi sağlar; örneğin, model sınıfı önceden tanımlanırsa büyük bir ekibin üyeleri bir feature’in network ve UI katmanları üzerinde ayrı ayrı çalışabilir. | . Bu pratiği genişletebilir ve uygulama mimarinizin diğer bölümlerinde de ayrı model sınıfları tanımlayabilirsiniz; örneğin veri kaynağı sınıflarında ve ViewModel’lerde. Ancak bu, düzgün bir şekilde belgelemeniz ve test etmeniz gereken ekstra sınıflar ve logic tanımlamanızı gerektirir. En azından, bir veri kaynağının uygulamanızın geri kalanının beklediği verilerle eşleşmeyen veriler aldığı her durumda yeni modeller oluşturmanız önerilir. Types of daya operations . Data katmanı, ne kadar kritik olduklarına bağlı olarak değişen işlem türleriyle çalışabilir:UI-oriented, app-oriented, and business-oriented operations. UI-oriented operations . UI odaklı işlemler yalnızca kullanıcı belirli bir ekrandayken geçerlidir ve kullanıcı o ekrandan ayrıldığında iptal edilirler. Veritabanından elde edilen bazı verilerin görüntülenmesi buna bir örnektir. UI odaklı işlemler genellikle UI katmanı tarafından tetiklenir ve çağıranın yaşam döngüsünü (örneğin ViewModel’in yaşam döngüsü) takip eder. UI odaklı bir işlem örneği için Network isteği yapma bölümüne bakın. App-oriented operations . Uygulama odaklı işlemler, uygulama açık olduğu sürece geçerlidir. Uygulama kapatılırsa veya işlem öldürülürse, bu işlemler iptal edilir. Bir network isteğinin sonucunun, gerektiğinde daha sonra kullanılabilmesi için önbelleğe alınması buna bir örnektir. Daha fazla bilgi için in-memory data caching bölümüne bakın. Bu işlemler genellikle Application sınıfının veya data katmanının yaşam döngüsünü takip eder. Bir örnek için, Bir işlemi ekrandan daha uzun süre yaşatın bölümüne bakın. Business-oriented operations . İş odaklı işlemler iptal edilemez. İşlem ölümünden sağ çıkmalıdırlar. Kullanıcının profiline göndermek istediği bir fotoğrafın yüklemesini bitirmek buna bir örnektir. İş odaklı işlemler için öneri WorkManager kullanmaktır. Daha fazla bilgi edinmek için WorkManager kullanarak görevleri zamanlama bölümüne bakın. Expose errors . Repositorylerle ve veri kaynaklarıyla etkileşimler başarılı olabilir veya bir hata oluştuğunda bir exception fırlatabilir. Coroutine’ler ve flow’lar için Kotlin’in yerleşik hata işleme mekanizmasını kullanmalısınız. Suspend fonksiyonları tarafından tetiklenebilecek hatalar için, uygun olduğunda try/catch bloklarını kullanın; ve flow’larda catch operatörünü kullanın. Bu yaklaşımla, UI katmanının data katmanını çağırırken exception’ları ele alması beklenir. Data katmanı farklı hata türlerini anlayabilir ve işleyebilir ve bunları özel exception’lar (örneğin UserNotAuthenticatedException) kullanarak gösterebilir. Not: Data katmanı ile etkileşimlerin sonucunu modellemenin bir başka yolu da bir Result sınıfı kullanmaktır. Bu model, sonucun işlenmesinin bir parçası olarak ortaya çıkabilecek hataları ve diğer sinyalleri modeller. Bu modelde, data katmanı T yerine bir Result tipi döndürerek UI'nin belirli senaryolarda oluşabilecek bilinen hatalardan haberdar olmasını sağlar. Bu, [LiveData]gibi uygun exception handling'e sahip olmayan reaktif programlama API'leri için gereklidir. Coroutine’lerdeki hatalar hakkında daha fazla bilgi edinmek için Exceptions in coroutines blog gönderisine bakın. Common tasks . Aşağıdaki bölümlerde, Android uygulamalarında yaygın olan belirli görevleri gerçekleştirmek için data katmanının nasıl kullanılacağına ve tasarlanacağına dair örnekler sunulmaktadır. Örnekler, kılavuzun önceki bölümlerinde bahsedilen tipik News uygulamasını temel almaktadır. Make a network request . Ağ isteği yapmak, bir Android uygulamasının gerçekleştirebileceği en yaygın görevlerden biridir. News uygulamasının kullanıcıya ağdan alınan en son haberleri sunması gerekir. Bu nedenle, uygulamanın ağ işlemlerini yönetmek için bir veri kaynağı sınıfına ihtiyacı vardır: NewsRemoteDataSource. Bilgileri uygulamanın geri kalanına göstermek için, haber verileri üzerindeki işlemleri gerçekleştiren yeni bir repository oluşturulur: NewsRepository. Gereklilik, kullanıcı ekranı açtığında en son haberlerin her zaman güncellenmesi gerektiğidir. Dolayısıyla, bu UI odaklı(UI-oriented) bir operasyondur. Create the data source . Veri kaynağının en son haberleri döndüren bir fonksiyon sunması gerekir: ArticleHeadline instancelarının bir listesi. Veri kaynağının ağdan en son haberleri almak için main-safe bir yol sağlaması gerekir. Bunun için, task’in çalıştırılacağı CoroutineDispatcher ya da Executor’a dependency(bağımlılık) alması gerekir. Bir ağ isteği yapmak, yeni bir fetchLatestNews() metodu tarafından yürütülen tek seferlik bir çağrıdır: . class NewsRemoteDataSource( private val newsApi: NewsApi, private val ioDispatcher: CoroutineDispatcher ) { /** * Fetches the latest news from the network and returns the result. * This executes on an IO-optimized thread pool, the function is main-safe. */ suspend fun fetchLatestNews(): List&lt;ArticleHeadline&gt; = // Move the execution to an IO-optimized thread since the ApiService // doesn't support coroutines and makes synchronous requests. withContext(ioDispatcher) { newsApi.fetchLatestNews() } } // Makes news-related network synchronous requests. interface NewsApi { fun fetchLatestNews(): List&lt;ArticleHeadline&gt; } . NewsApi interface’i network API client’ının implementasyonunu gizler; interface’in Retrofit veya HttpURLConnection tarafından desteklenmesi fark etmez. Interface’lere güvenmek, API implementasyonlarını uygulamanızda değiştirilebilir hale getirir. Püf Noktası: Interface’lere güvenmek, API implementasyonlarını uygulamanızda değiştirilebilir hale getirir. Ölçeklenebilirlik sağlamanın ve bağımlılıkları daha kolay değiştirmenize izin vermenin yanı sıra, testlere sahte veri kaynağı uygulamaları ekleyebildiğiniz için test edilebilirliği de destekler. Create the repository . Bu görev için repository sınıfında ekstra bir mantık gerekmediğinden, NewsRepository network veri kaynağı için bir proxy görevi görür. Bu ekstra soyutlama katmanını eklemenin faydaları in-memory caching bölümünde açıklanmıştır. // NewsRepository is consumed from other layers of the hierarchy. class NewsRepository( private val newsRemoteDataSource: NewsRemoteDataSource ) { suspend fun fetchLatestNews(): List&lt;ArticleHeadline&gt; = newsRemoteDataSource.fetchLatestNews() } . Repository sınıfını doğrudan UI katmanından nasıl kullanacağınızı öğrenmek için UI layer kılavuzuna bakın. Implement in-memory data caching . News uygulaması için yeni bir gereksinim getirildiğini varsayalım: kullanıcı ekranı açtığında, daha önce bir istek yapılmışsa cache’lenmiş haberler kullanıcıya sunulmalıdır. Aksi takdirde, uygulama en son haberleri almak için bir network isteği yapmalıdır. Yeni gereksinim göz önüne alındığında, uygulama, kullanıcı uygulamayı açık tuttuğu sürece en son haberleri bellekte tutmalıdır. Dolayısıyla, bu app-oriented operation (uygulama odaklı işlem)dur. Caches . In-memory data caching (bellek içi veri önbellekleme) ekleyerek kullanıcı uygulamanızdayken verileri koruyabilirsiniz. Cache’ler, bazı bilgileri belirli bir süre boyunca (bu durumda kullanıcı uygulamada olduğu sürece) bellekte saklamak içindir. Cache implementasyonları farklı şekillerde olabilir. Basit bir değiştirilebilir değişkenden, birden fazla thread üzerinde okuma/yazma işlemlerinden koruyan daha sofistike bir sınıfa kadar değişebilir. Kullanım durumuna bağlı olarak, caching repository’de veya veri kaynağı sınıflarında uygulanabilir. Cache the result of the network request . Basitlik açısından NewsRepository, en son haberleri cache’lemek için mutable bir değişken kullanır. Farklı thread’lerden gelen okuma ve yazmaları korumak için bir Mutex kullanılır. Paylaşılan mutable state ve concurrency hakkında daha fazla bilgi edinmek için Kotlin belgelerine bakın. Aşağıdaki implementasyon, en son haber bilgilerini repository’de bir Mutex ile yazma korumalı bir değişkene cache’ler. Network isteğinin sonucu başarılı olursa, veriler latestNews değişkenine atanır. class NewsRepository( private val newsRemoteDataSource: NewsRemoteDataSource ) { // Mutex to make writes to cached values thread-safe. private val latestNewsMutex = Mutex() // Cache of the latest news got from the network. private var latestNews: List&lt;ArticleHeadline&gt; = emptyList() suspend fun getLatestNews(refresh: Boolean = false): List&lt;ArticleHeadline&gt; { if (refresh || latestNews.isEmpty()) { val networkResult = newsRemoteDataSource.fetchLatestNews() // Thread-safe write to latestNews latestNewsMutex.withLock { this.latestNews = networkResult } } return latestNewsMutex.withLock { this.latestNews } } } . Make an operation live longer than the screen . Ağ isteği devam ederken kullanıcı ekrandan uzaklaşırsa, istek iptal edilir ve sonuç cache’lenmez. NewsRepository bu logici gerçekleştirmek için Caller’ın CoroutineScope’unu kullanmamalıdır. Bunun yerine, NewsRepository kendi yaşam döngüsüne bağlı bir CoroutineScope kullanmalıdır. En son haberleri getirmenin app-oriented bir operasyon olması gerekir. Dependency injection best practicelerini takip etmek için NewsRepository kendi CoroutineScope’unu oluşturmak yerine constructor’ında parametre olarak bir scope almalıdır. Repository’lerin işlerinin çoğunu background thread’lerde yapması gerektiğinden, CoroutineScope’u Dispatchers.Default ya da kendi thread havuzunuz ile yapılandırmalısınız. class NewsRepository( ..., // This could be CoroutineScope(SupervisorJob() + Dispatchers.Default). private val externalScope: CoroutineScope ) { ... } . NewsRepository harici CoroutineScope ile app oriented operasyonlar gerçekleştirmeye hazır olduğundan, veri kaynağına çağrıyı gerçekleştirmeli ve sonucunu bu scope tarafından başlatılan yeni bir coroutine ile kaydetmelidir: . class NewsRepository( private val newsRemoteDataSource: NewsRemoteDataSource, private val externalScope: CoroutineScope ) { /* ... */ suspend fun getLatestNews(refresh: Boolean = false): List&lt;ArticleHeadline&gt; { return if (refresh) { externalScope.async { newsRemoteDataSource.fetchLatestNews().also { networkResult -&gt; // Thread-safe write to latestNews. latestNewsMutex.withLock { latestNews = networkResult } } }.await() } else { return latestNewsMutex.withLock { this.latestNews } } } } . async, coroutine’i harici scope’da başlatmak için kullanılır. await, network isteği geri gelene ve sonuç cache’e kaydedilene kadar askıya almak için yeni coroutine üzerinde çağrılır. O zamana kadar kullanıcı hala ekrandaysa, en son haberleri görecektir; kullanıcı ekrandan uzaklaşırsa, await iptal edilir ancak async içindeki logic çalışmaya devam eder. CoroutineScope patternleri hakkında daha fazla bilgi edinmek için bu blog yazısına bakın. Save and retrieve data from disk . Bookmark edilmiş haberler ve kullanıcı tercihleri gibi verileri kaydetmek istediğinizi varsayalım. Bu tür verilerin process death’den kurtulması ve kullanıcı network’e bağlı olmasa bile erişilebilir olması gerekir. Üzerinde çalıştığınız verilerin process death’den kurtulması gerekiyorsa, aşağıdaki yollardan biriyle diskte saklamanız gerekir: . -Sorgulanması gereken, referans bütünlüğüne ihtiyaç duyan veya kısmi güncellemelere ihtiyaç duyan büyük veri kümeleri için verileri bir Room veritabanına kaydedin. News uygulaması örneğinde, haber makaleleri veya yazarları veritabanına kaydedilebilir. -Yalnızca alınması ve ayarlanması gereken (sorgulanmayan veya kısmen güncellenmeyen) küçük veri kümeleri için DataStore kullanın. News uygulaması örneğinde, kullanıcının tercih ettiği tarih biçimi veya diğer görüntüleme tercihleri DataStore’a kaydedilebilir. -JSON nesnesi gibi veri parçaları için bir dosya kullanın. Source of truth bölümünde belirtildiği gibi, her veri kaynağı yalnızca bir kaynakla çalışır ve belirli bir veri türüne karşılık gelir (örneğin, News, Authors, NewsAndAuthors veya UserPreferences). Veri kaynağını kullanan sınıflar, verilerin nasıl kaydedildiğini bilmemelidir (örneğin, bir veritabanına veya bir dosyaya). Room as a data source . Her veri kaynağının belirli bir veri türü için yalnızca bir kaynakla çalışma sorumluluğuna sahip olması gerektiğinden, bir Room veri kaynağı parametre olarak ya bir veri erişim nesnesi (DAO) ya da veritabanının kendisini alacaktır. Örneğin, NewsLocalDataSource parametre olarak NewsDao’nun bir instance’ını alabilir ve AuthorsLocalDataSource AuthorsDao’nun bir instance’ını alabilir. Bazı durumlarda, ekstra bir lojik gerekmiyorsa, DAO testlerde kolayca değiştirebileceğiniz bir interface olduğundan, DAO’yu doğrudan repository’ye enjekte edebilirsiniz. Room API’leri ile çalışma hakkında daha fazla bilgi edinmek için Room kılavuzlarına bakın. DataStore as a data source . DataStore, kullanıcı ayarları gibi key-value çiftlerini saklamak için mükemmeldir. Örnekler arasında zaman biçimi, bildirim tercihleri ve kullanıcı okuduktan sonra haber öğelerinin gösterilip gösterilmeyeceği veya gizlenip gizlenmeyeceği yer alabilir. DataStore aynı zamanda protocol buffer‘ları olan tiplendirilmiş nesneleri de depolayabilir. Diğer tüm nesnelerde olduğu gibi, DataStore tarafından desteklenen bir veri kaynağı, belirli bir türe veya uygulamanın belirli bir bölümüne karşılık gelen verileri içermelidir. Bu durum DataStore için daha da geçerlidir çünkü DataStore okumaları, bir değer her güncellendiğinde yayılan bir akış olarak açığa çıkar. Bu nedenle, ilgili tercihleri aynı DataStore’da saklamalısınız. Örneğin, yalnızca bildirimle ilgili tercihleri işleyen bir NotificationsDataStore’a ve yalnızca haber ekranıyla ilgili tercihleri işleyen bir NewsPreferencesDataStore’a sahip olabilirsiniz. Bu şekilde, newsScreenPreferencesDataStore.data akışı yalnızca o ekranla ilgili bir tercih değiştirildiğinde yayıldığı için güncellemeleri daha iyi kapsamlandırabilirsiniz. Bu aynı zamanda nesnenin yaşam döngüsünün daha kısa olabileceği anlamına gelir çünkü yalnızca haber ekranı görüntülendiği sürece yaşayabilir. DataStore API’leri ile çalışma hakkında daha fazla bilgi edinmek için DataStore kılavuzlarına bakın. A file as a data source . JSON nesnesi veya bitmap gibi büyük nesnelerle çalışırken, bir File nesnesiyle çalışmanız ve thread’leri değiştirmeniz gerekir. Storage ile çalışma hakkında daha fazla bilgi edinmek için Storage oveview sayfasına bakın. Schedule tasks using WorkManager . News uygulaması için yeni bir gereksinim daha getirildiğini varsayalım: Uygulama, kullanıcıya cihaz şarjda olduğu ve kesintisiz bir ağa bağlı olduğu sürece en son haberleri düzenli ve otomatik olarak alma seçeneği sunmalıdır. Bu da bunu business-oriented operation haline getiriyor. Bu gereklilik, kullanıcı uygulamayı açtığında cihazın bağlantısı olmasa bile kullanıcının en son haberleri görebilmesini sağlar. WorkManager, asenkron ve güvenilir iş planlamayı kolaylaştırır ve kısıtlama yönetimiyle ilgilenebilir. Kalıcı işler için önerilen kütüphanedir. Yukarıda tanımlanan görevi gerçekleştirmek için bir Worker sınıfı oluşturulur: RefreshLatestNewsWorker. Bu sınıf, en son haberleri getirmek ve diske cache’lemek için NewsRepository’yi dependency olarak alır. class RefreshLatestNewsWorker( private val newsRepository: NewsRepository, context: Context, params: WorkerParameters ) : CoroutineWorker(context, params) { override suspend fun doWork(): Result = try { newsRepository.refreshLatestNews() Result.success() } catch (error: Throwable) { Result.failure() } } . Bu tür görevler için business logic kendi sınıfında kapsüllenmeli ve ayrı bir veri kaynağı olarak ele alınmalıdır. WorkManager daha sonra yalnızca tüm kısıtlamalar karşılandığında işin bir background thread üzerinde yürütülmesini sağlamaktan sorumlu olacaktır. Bu kalıba bağlı kalarak, gerektiğinde farklı ortamlardaki uygulamaları hızlı bir şekilde değiştirebilirsiniz. Bu örnekte, haberlerle ilgili bu görev, bağımlılık olarak yeni bir veri kaynağı alacak olan NewsRepository’den çağrılmalıdır: NewsTasksDataSource, aşağıdaki gibi implemente edilmiştir: . private const val REFRESH_RATE_HOURS = 4L private const val FETCH_LATEST_NEWS_TASK = \"FetchLatestNewsTask\" private const val TAG_FETCH_LATEST_NEWS = \"FetchLatestNewsTaskTag\" class NewsTasksDataSource( private val workManager: WorkManager ) { fun fetchNewsPeriodically() { val fetchNewsRequest = PeriodicWorkRequestBuilder&lt;RefreshLatestNewsWorker&gt;( REFRESH_RATE_HOURS, TimeUnit.HOURS ).setConstraints( Constraints.Builder() .setRequiredNetworkType(NetworkType.TEMPORARILY_UNMETERED) .setRequiresCharging(true) .build() ) .addTag(TAG_FETCH_LATEST_NEWS) workManager.enqueueUniquePeriodicWork( FETCH_LATEST_NEWS_TASK, ExistingPeriodicWorkPolicy.KEEP, fetchNewsRequest.build() ) } fun cancelFetchingNewsPeriodically() { workManager.cancelAllWorkByTag(TAG_FETCH_LATEST_NEWS) } } . Bu tür sınıflar sorumlu oldukları verilere göre adlandırılır; örneğin NewsTasksDataSource veya PaymentsTasksDataSource. Belirli bir veri türüyle ilgili tüm görevler aynı sınıfta kapsüllenmelidir. Görevin uygulama başlangıcında tetiklenmesi gerekiyorsa, repository’i bir Initializer‘dan çağıran App Startup kütüphanesini kullanarak WorkManager isteğini tetiklemeniz önerilir. WorkManager API’leri ile çalışma hakkında daha fazla bilgi edinmek için WorkManager kılavuzlarına bakın. Testing . Dependency injection best practiceleri, uygulamanızı test ederken yardımcı olur. Harici kaynaklarla iletişim kuran sınıflar için interface’lere güvenmek de faydalıdır. Bir birimi test ederken, testi deterministik ve güvenilir hale getirmek için bağımlılıklarının sahte sürümlerini enjekte edebilirsiniz. Unit tests . Veri katmanını test ederken genel test yönergeleri geçerlidir. Birim testleri için, gerektiğinde gerçek nesneler kullanın ve bir dosyadan okuma veya ağdan okuma gibi harici kaynaklara ulaşan bağımlılıkları taklit edin. Integration tests . Harici kaynaklara erişen entegrasyon testleri, gerçek bir cihaz üzerinde çalıştırılmaları gerektiğinden daha az deterministik olma eğilimindedir. Entegrasyon testlerini daha güvenilir hale getirmek için bu testleri kontrollü bir ortamda yürütmeniz önerilir. Room, veritabanları için testlerinizde tamamen kontrol edebileceğiniz bir in-memory database oluşturmanıza olanak tanır. Daha fazla bilgi edinmek için Test and debug your database sayfasına bakın. Networking için, WireMock veya MockWebServer gibi HTTP ve HTTPS çağrılarını taklit etmenize ve isteklerin beklendiği gibi yapıldığını doğrulamanıza olanak tanıyan popüler kütüphaneler vardır. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer/"
  },"33": {
    "doc": "About the navigation components",
    "title": "About the navigation components",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/about-the-navigation-components/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/about-the-navigation-components/"
  },"34": {
    "doc": "About the UI layer",
    "title": "UI Layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer/#ui-layer",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer/#ui-layer"
  },"35": {
    "doc": "About the UI layer",
    "title": "About the UI layer",
    "content": "Kullanıcı arayüzünün(UI) rolü, uygulama verilerini ekranda görüntülemek ve ayrıca kullanıcı etkileşiminin(user interaction) birincil noktası olarak hizmet etmektir. Veriler, kullanıcı etkileşimi (bir butona basmak gibi) veya harici giriş (bir network response gibi) nedeniyle değiştiğinde, kullanıcı arayüzü bu değişiklikleri yansıtacak şekilde güncellenmelidir. Yani, UI, data katmanından alınan uygulama state’inin görsel bir temsilidir. Ancak data katmanından aldığınız uygulama verileri genellikle görüntülemeniz gereken bilgilerden farklı bir formattadır. Örneğin, UI için verilerin yalnızca bir kısmına ihtiyacınız olabilir veya kullanıcıyla ilgili bilgileri sunmak için iki farklı veri kaynağını birleştirmeniz gerekebilir. Uyguladığınız logic ne olursa olsun, tam olarak işlemesi için ihtiyaç duyduğu tüm bilgileri UI’ye iletmeniz gerekir. UI katmanı, uygulama veri değişikliklerini UI’in sunabileceği bir forma dönüştüren ve ardından bunu görüntüleyen piplinedir. Şekil 1. Uygulama mimarisinde UI katmanının rolü; . Not: Bu sayfada sunulan öneriler ve best practiceler, ölçeklenmelerine, kalite ve sağlamlığı artırmalarına ve test edilmelerini kolaylaştırmalarına olanak sağlamak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Architecture: The UI Layer - MAD Skills . A basic case study . Bir kullanıcının okuması için haber makaleleri getiren bir uygulama düşünün. Uygulama, okunabilecek makaleler sunan bir makaleler ekranına sahiptir ve ayrıca oturum açmış kullanıcıların gerçekten öne çıkan makalelere yer işareti koymasına olanak tanır. Her an çok sayıda makale olabileceği göz önüne alındığında, okuyucunun makalelere kategorilere göre göz atabilmesi gerekir. Özetle, uygulama, kullanıcıların aşağıdakileri yapmasına izin verir: . | Okunabilecek makaleleri görüntüleyin. | Makalelere kategoriye göre göz atın. | Oturum açın ve belirli makalelere yer işareti koyun. | Uygunsa bazı premium özelliklere erişin. | . Aşağıdaki bölümler, bu örneği, tek yönlü veri akışı ilkelerini tanıtmak ve bu ilkelerin UI katmanı için uygulama mimarisi bağlamında çözmeye yardımcı olduğu sorunları göstermek için bir use case olarak kullanır. UI layer Architecture . UI terimi, bunu yapmak için hangi API’leri kullandıklarından bağımsız olarak (Views veya Jetpack Compose) verileri görüntüleyen activity ve fragment gibi UI elementlerini ifade eder. Data katmanının rolü uygulama verilerini tutmak, yönetmek ve bunlara erişim sağlamak olduğundan, UI katmanı aşağıdaki adımları gerçekleştirmelidir: . | Uygulama verilerini tüketin(consume etmek) ve UI’in kolayca render edilebilecegi verilere dönüştürün. | UI ile render edilebilir verileri tüketin ve kullanıcıya sunulmak üzere UI elementlerine dönüştürün. | Bu birleştirilmiş UI elementlerinden kullanıcı input eventlerini tüketin ve etkilerini gerektiği gibi UI verilerine yansıtın. | 1’den 3’e kadar olan adımları gerektiği kadar tekrarlayın. | . Bu kılavuzun geri kalanı, bu adımları gerçekleştiren bir UI katmanının nasıl implementasyonunu gösterir. Bu kılavuz özellikle aşağıdaki görevleri ve kavramları kapsar: . | UI state nasıl tanımlanır. | UI state’ini üretme(produce) ve yönetme aracı olarak tek yönlü veri akışı ((Undirectional Data Flow)UDF). | UDF ilkelerine göre observable veri türleriyle UI state’i nasıl ortaya çıkar. | Observable UI state’ini tüketen UI nasıl implement edilir. Bunlardan en temel olanı UI state’inin tanımıdır. | . Define UI State . Daha önce özetlenen case study üzerinden devam edelim. Kısacası, kullanıcı arayüzü her makale için bazı metadata ile birlikte bir makale listesi gösterir. Uygulamanın kullanıcıya sunduğu bu bilgiler, UI state’dir. Başka bir deyişle: UI, kullanıcının gördüğü şeyse, UI state, uygulamanın görmeleri gerektiğini söylediği şeydir. Aynı madalyonun iki yüzü gibi, UI da UI state’in görsel temsilidir. UI state’indeki herhangi bir değişiklik, hemen UI’ye yansıtılır. Use case incelemesini düşünün; News uygulamasının gereksinimlerini karşılamak için, kullanıcı arayüzünü tam olarak oluşturmak için gereken bilgiler, aşağıdaki gibi tanımlanan bir NewsUiState data classda encapsule edilebilir: . data class NewsUiState( val isSignedIn: Boolean = false, val isPremium: Boolean = false, val newsItems: List&lt;NewsItemUiState&gt; = listOf(), val userMessages: List&lt;Message&gt; = listOf() ) data class NewsItemUiState( val title: String, val body: String, val bookmarked: Boolean = false, ... ) . Immutability . Yukarıdaki örnekteki UI state tanımı immutabledir(degismez). Bunun en önemli faydası, immutable nesnelerin zamanın bir anında uygulamanın state’ine ilişkin garantiler sağlamasıdır. Bu, UI’i tek bir role odaklanmak için serbest bırakır: state’i okumak ve UI elementlerini buna göre güncellemek. Sonuç olarak, UI verilerinin tek kaynağı(ssot) UI’nin kendisi olmadığı sürece UI state’ini asla doğrudan UI’de değiştirmemelisiniz. Bu ilkeyi ihlal etmek, aynı bilgi parçası için birden fazla doğruluk kaynağına(multiple source of truth istenmeyen durumdur) yol açarak veri tutarsızlıklarına ve ince hatalara neden olur. Örneğin, use casedeki UI state’ten bir NewsItemUiState nesnesindeki bookmarked flag’i Activity sınıfında güncellenseydi, bu flag bir makalenin bookmarked statüsünün kaynağı olarak data katmanı ile rekabet halinde olacaktı. Immutable data class’lar bu tür antipattern’leri önlemek için çok kullanışlıdır. Kilit Nokta: Yalnızca veri kaynakları veya ownerlari, ortaya koydukları verilerin güncellenmesinden sorumlu olmalıdır. Naming conventions in this guide . Bu kılavuzda, UI state sınıfları, ekranın veya tanımladıkları ekranın bir bölümünün fonksiyonalitesine göre adlandırılır. Sözleşme şu şekildedir: fonksiyonalite + UiState. Örneğin, haberleri görüntüleyen bir ekranın state’i NewsUiState olarak adlandırılabilir ve haber öğeleri listesindeki bir haber öğesinin state’i NewsItemUiState olabilir. Manage State with Undirectional Data Flow . Önceki bölüm, UI state’inin, UI’in oluşturması için gereken ayrıntıların immutable bir snapshot olduğunu belirttik. Ancak, uygulamalardaki verilerin dinamik doğası geregi, bu state’in zaman içinde değişebileceği anlamına gelir. Bunun nedeni, uygulamayı doldurmak(populate) için kullanılan temel verileri değiştiren kullanıcı etkileşimi(user interaction) veya diğer eventlar olabilir. Bu etkileşimler, bunları işlemek, her event’e uygulanacak logic’i tanımlamak ve UI state ini oluşturmak için backing data resource lerine gerekli transformationlari gerçekleştirmek için bir arabulucudan(mediator) yararlanabilir. Bu etkileşimler ve bunların logici kullanıcı arayüzünün kendisinde barındırılabilir, ancak kullanıcı arayüzü adından da anlaşılacağı gibi data owner, producer, transformer ve daha fazlası haline gelmeye başladıkça bu durum hızla hantallaşabilir. Ayrıca, ortaya çıkan kod, ayırt edilebilir sınırları olmayan tightly coupled bir karışım olduğundan, bu durum test edilebilirliği etkileyebilir. Sonuç olarak, kullanıcı arayüzü azaltılmış yükten faydalanmaya hazırdır. UI state’i çok basit olmadığı sürece, UI’nin tek sorumluluğu UI state’ini kullanmak ve görüntülemek olmalıdır. Bu bölümde, healthy separation of responsibility uygulanmasına yardımcı olan bir mimari model olan Tek Yönlü Veri Akışı (unidirectional data flow (UDF) ele alınmaktadır. State Holders . UI state’inin üretilmesinden sorumlu olan ve o görev için gerekli logici içeren sınıflara state holder denir. State Holderlar, yönettikleri ilgili UI elementlerinin scope una bağlı olarak, bottom appbar gibi tek bir widget öğesinden tüm ekrana veya bir navigation hedefine kadar çeşitli boyutlarda gelir. İkinci durumda, tipik uygulama bir ViewModel örneğidir, ancak uygulamanın gereksinimlerine bağlı olarak basit bir sınıf yeterli olabilir. Yukarıdaki case study deki News uygulaması, örneğin, o bölümde görüntülenen ekran için UI state oluşturmak üzere state holder olarak bir NewsViewModel sınıfını kullanır. Kilit Nokta: ViewModel türü, veri katmanına erişimle birlikte ekran düzeyinde Ui state’inin yönetimi için önerilen implementasyondur. Ayrıca, yapılandırma değişikliklerinden(configuration changes) otomatik olarak kurtulur. ViewModel sınıfları, uygulamadaki eventlara uygulanacak logic’i tanımlar ve sonuç olarak güncellenmiş state’i üretir. UI ile state producer arasındaki karşılıklı bağımlılığı modellemenin birçok yolu vardır. Bununla birlikte,UI ile ViewModel sınıfı arasındaki etkileşim, büyük ölçüde event input ve ardından gelen state output olarak anlaşılabileceğinden, ilişki aşağıdaki şemada gösterildiği gibi gösterilebilir: State’in aşağı doğru aktığı ve eventlarin yukarı doğru aktığı patterne tek yönlü veri akışı(unidirectional data flow) ( UDF) denir. Uygulama mimarisi için bu modelin sonuçları aşağıdaki gibidir: . | ViewModel, UI tarafından tüketilecek state’i tutar ve gösterir. UI state’i,ViewModel tarafından dönüştürülen uygulama verileridir. | UI, kullanıcı eventlerini ViewModel’e bildirir. | ViewModel, kullanıcı eylemlerini işler ve state’i günceller. | Güncellenen state, işlenmek üzere kullanıcı arayüzüne(UI) geri beslenir. | Yukarıdaki durum, bir state değişimine neden olan herhangi bir event için tekrarlanır. | . Navigation destinations veya ekranlar için ViewModel, veri almak ve bunları UI state’ine dönüştürmek için repository’ler veya use case sınıfları ile birlikte çalışır ve aynı zamanda state’in değişmesine neden olabilecek event’lerin etkilerini de dahil eder. Daha önce bahsedilen case study, her biri bir başlık, açıklama, kaynak, yazar adı, yayın tarihi ve bookmarked olup olmadığına sahip bir makale listesi içerir. Her bir makale öğesi için UI aşağıdaki gibi görünür: . Bir makaleye bookmark koymak isteyen bir kullanıcı, state değişimlerine neden olabilecek bir event’a örnektir. State producer olarak, ViewModel’in sorumluluğundaki sey; UI state’in deki tüm alanları doldurmak ve UI’in tam olarak işlemesi için gereken eventlari handle etmek amaciyla gereken tüm logici tanımlamaktır. Aşağıdaki bölümlerde, state değişikliklerine neden olan eventlere ve bunların UDF kullanılarak nasıl handle edilebilecegine daha yakından bakılmaktadır. Types of Logic . Bir makaleyi bookmarklamak, uygulamanıza değer kattığı için bir iş mantığı(business logic) örneğidir. Bununla ilgili daha fazla bilgi edinmek için veri katmanı(data layer) sayfasına bakın. Ancak, tanımlanması önemli olan farklı logic türleri vardır: . | Business logic, uygulama verileri için ürün gereksinimlerinin implement edilmesidir. Daha önce belirtildiği gibi, case study uygulamasında bir makaleye bookmark koymaktır. Business logic genellikle domain veya data katmanlarına yerleştirilir, ancak asla UI katmanına yerleştirilmez. | UI behavior logic veya UI logic, state değişikliklerinin ekranda nasıl görüntüleneceğidir. Örnekler arasında, Android Resourcelerini kullanarak ekranda gösterilecek doğru metni elde etmek, kullanıcı bir butonu tıkladığında belirli bir ekrana gitmek veya bir toast veya snackbar kullanarak ekranda bir kullanıcı mesajı görüntülemek yer alır. | . UI logici, özellikle Context gibi UI türlerini içerdiğinde, ViewModel’de değil UI’de yaşamalıdır. UI’in karmaşıklığı artarsa ve UI logicini test edilebilirliği ve endişelerin ayrılmasını(separation of concerns) desteklemek için başka bir sınıfa devretmek istiyorsanız, state holder olarak basit bir sınıf oluşturabilirsiniz. UI’de oluşturulan basit sınıflar, UI’nin yaşam döngüsünü takip ettikleri için Android SDK bağımlılıklarını alabilir; ViewModel nesnelerinin ömrü daha uzundur. State holderlar ve bunların UI oluşturmaya yardımcı olma bağlamına nasıl uydukları hakkında daha fazla bilgi için Jetpack Compose State kılavuzuna bakın. Why use UDF? . UDF, state değişimlerinin başladığı yeri, dönüştüğü yeri ve nihai olarak tüketildiği yeri de ayırır. Bu ayrım, kullanıcı arayüzünün tam olarak adının ima ettiği şeyi yapmasına olanak tanır yani state değişikliklerini gözlemleyerek(observe) bilgileri görüntüleyin ve bu değişiklikleri ViewModel’e ileterek user’in amacını iletin. Başka bir deyişle, UDF aşağıdakilere izin verir: . | Veri tutarlılığı. Kullanıcı arayüzü için tek bir doğruluk kaynağı(ssot) vardır. | Test edilebilirlik. State kaynağı yalıtılmıştır ve bu nedenle kullanıcı arabiriminden bağımsız olarak test edilebilir. | Bakım kolaylığı. State degisikligi, degisikliklerin hem kullanıcı eventlerinin hem de çektikleri veri kaynaklarının bir sonucu olduğu iyi tanımlanmış bir model izler. | . Expose UI State . UI state’inizi tanımlayıp, o state’in üretimini(produce) nasıl yöneteceğinizi belirledikten sonra sıra, üretilen state’i UI’ye sunmaktır. State’in üretimini yönetmek için UDF kullandığınız için, üretilen state’i bir stream olarak düşünebilirsiniz; başka bir deyişle, state’in birden çok sürümü zaman içinde üretilecektir. Sonuç olarak, UI state’ini LiveData veya StateFlow gibi gözlemlenebilir bir data holderla göstermelisiniz. Bunun nedeni, kullanıcı arabiriminin, verileri doğrudan ViewModel’den manuel olarak çekmek zorunda kalmadan state’de yapılan herhangi bir değişikliğe tepki verebilmesidir. Bu tipler ayrıca, yapılandırma değişikliklerinden sonra hızlı durum geri yüklemesi için yararlı olan, kullanıcı arayüzü state’inin her zaman en son sürümünün önbelleğe alınması avantajına sahiptir. //views class NewsViewModel(...) : ViewModel() { val uiState: StateFlow&lt;NewsUiState&gt; = … } . //compose class NewsViewModel(...) : ViewModel() { val uiState: NewsUiState = … } . Observable bir data holder olarak LiveData’ya giriş için bu codelab‘e bakın. Kotlin flowlara benzer bir giriş için bkz. Android’de Kotlin flows. Not: Jetpack Compose uygulamalarında, UI state’inin gösterilmesi için Compose'un mutableStateOf veya snapshotFlow gibi gözlemlenebilir State API'lerini kullanabilirsiniz. Bu kılavuzda gördüğünüz StateFlow veya LiveData gibi her türlü gözlemlenebilir data holder, uygun extensionlar kullanılarak Compose'da kolayca tüketilebilir. UI’ye maruz kalan verilerin nispeten basit olduğu durumlarda, state holderin yayılımı(emission) ile ilişkili ekran veya UI elementi arasındaki ilişkiyi aktardığı için genellikle verileri bir UI state tipine sarmaya değer. Ayrıca, UI elementi daha karmaşık hale geldikçe, UI elementini render etmek için gereken ekstra bilgileri barındırmak için UI state tanımına ekleme yapmak her zaman daha kolaydır. Bir UiState akışı oluşturmanın yaygın bir yolu, backing mutable stream’i ViewModel’den immutable stream olarak göstermektir; örneğin, MutableStateFlow'i StateFlow olarak göstermek gibi. //views class NewsViewModel(...) : ViewModel() { private val _uiState = MutableStateFlow(NewsUiState()) val uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow() ... } //compose class NewsViewModel(...) : ViewModel() { var uiState by mutableStateOf(NewsUiState()) private set ... } . ViewModel daha sonra state’i dahili olarak değiştiren methodlari expose edebilir ve UI’in tüketmesi için güncellemeler yayınlayabilir. Örneğin, asenkron bir action’in gerçekleştirilmesi gereken durumu ele alalım; viewModelScope kullanılarak bir coroutine başlatılabilir ve mutable state tamamlandıktan sonra güncellenebilir. //views class NewsViewModel( private val repository: NewsRepository, ... ) : ViewModel() { private val _uiState = MutableStateFlow(NewsUiState()) val uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow() private var fetchJob: Job? = null fun fetchArticles(category: String) { fetchJob?.cancel() fetchJob = viewModelScope.launch { try { val newsItems = repository.newsItemsForCategory(category) _uiState.update { it.copy(newsItems = newsItems) } } catch (ioe: IOException) { // Handle the error and notify the UI when appropriate. _uiState.update { val messages = getMessagesFromThrowable(ioe) it.copy(userMessages = messages) } } } } } //compose class NewsViewModel( private val repository: NewsRepository, ... ) : ViewModel() { var uiState by mutableStateOf(NewsUiState()) private set private var fetchJob: Job? = null fun fetchArticles(category: String) { fetchJob?.cancel() fetchJob = viewModelScope.launch { try { val newsItems = repository.newsItemsForCategory(category) uiState = uiState.copy(newsItems = newsItems) } catch (ioe: IOException) { // Handle the error and notify the UI when appropriate. val messages = getMessagesFromThrowable(ioe) uiState = uiState.copy(userMessages = messages) } } } } . Yukarıdaki örnekte, NewsViewModel sınıfı, belirli bir kategori için makaleleri getirmeye çalışır ve ardından, girişimin sonucunu (başarılı veya başarısız) UI’in buna uygun şekilde tepki verebileceği UI state’inde yansıtır. Hata handle etme hakkında daha fazla bilgi edinmek için Show errors on the screen bölümüne bakın . Not: State’in ViewModel’deki fonksiyonlar aracılığıyla değiştirildiği yukarıdaki örnekte gösterilen pattern, tek yönlü veri akışının(UDF) en popüler uygulamalarından biridir. Additional considerations . Önceki kılavuza ek olarak, UI state’ini gösterirken aşağıdakileri göz önünde bulundurun: . | Bir UI state object, birbiriyle ilişkili stateleri handle edebilmelidir. Bu, daha az tutarsızlığa yol açar ve kodun anlaşılmasını kolaylaştırır. News item listesini ve bookmarlarin sayısını iki farklı streamde gösterirseniz, birinin güncellenip diğerinin güncellenmediği bir durumla karşılaşabilirsiniz. Tek bir stream kullandığınızda, her iki element de güncel tutulur. Ayrıca, bazı business logic, resourcelerin bir kombinasyonunu gerektirebilir. Örneğin, yalnızca kullanıcı oturum açmışsa ve bu kullanıcı bir premium haber hizmetine aboneyse, bir bookmark butonunu göstermeniz gerekebilir. Bir UI state sınıfını aşağıdaki gibi tanımlayabilirsiniz: | . data class NewsUiState( val isSignedIn: Boolean = false, val isPremium: Boolean = false, val newsItems: List&lt;NewsItemUiState&gt; = listOf() ) val NewsUiState.canBookmarkNews: Boolean get() = isSignedIn &amp;&amp; isPremium . Bu bildirimde, bookmark butonunun görünürlüğü diğer iki propertynin türetilmiş bir propertysidir. Business logic daha karmaşık hale geldikçe, tüm propertylerin anında kullanılabilir olduğu tek bir UiState sınıfına sahip olmak giderek daha önemli hale geliyor. | Ui stateleri: tek stream mı yoksa multiple stream mı? UI stateinin tek bir akışta veya birden çok akışta göstermek arasında seçim yapmak için temel yol gösterici ilke, previous bullet pointtir: emit edilmis itemler arasındaki ilişki. Tek akış gosteriminin en büyük avantajı kolaylık ve veri tutarlılığıdır: statedeki tüketiciler her zaman her an en son bilgilere sahiptir. Ancak, ViewModel’den ayrı state akışlarının uygun olabileceği durumlar vardır: . | İlişkisiz veri türleri: Kullanıcı arayüzünü oluşturmak için gereken bazı stateler birbirinden tamamen bağımsız olabilir. Bu gibi durumlarda, özellikle bu statelerden biri diğerinden daha sık güncelleniyorsa, bu farklı stateleri bir araya getirmenin maliyeti faydalarından daha ağır basabilir. | UiState diffing: Bir UiState nesnesinde ne kadar çok field varsa, fieldlarindan birinin güncellenmesi sonucunda akışın emit etme(yayilma) olasılığı o kadar yüksektir. Viewlerin, ardışık yaymalari farklı mı yoksa aynı mı olduğunu anlamak için farklılaştırma mekanizması olmadığından, her yayma, viewde bir güncellemeye neden olur. Bu, LiveData’da Flow API’lerini veya distinctUntilChanged() gibi methodlari kullanarak hafifletmenin gerekli olabileceği anlamına gelir. | . | . Consume UI State . UI’deki UiState objelerinin streamini tüketmek için, kullandığınız gözlemlenebilir veri türü için terminal operatorunu kullanırsınız. Örneğin, LiveData için observe() methodunu, Kotlin flowlar için ise collect() methodunu veya onun varyasyonlarını kullanırsınız. UI’da observable data holder kullanırken, UI’in yaşam döngüsünü dikkate aldığınızdan emin olun. View kullanıcıya gösterilmediğinde UI’ in state’ini gözlemlememesi gerektiğinden bu önemlidir. Bu konu hakkında daha fazla bilgi edinmek için bu blog gönderisine bakın. LifecycleOwner, LiveData’yı kullanırken implicit olarak yaşam döngüsü endişelerini giderir. Flowlari kullanırken, bunu uygun coroutine kapsamı ve repeatOnLifecycle API’si ile halletmek en iyisidir: . //views class NewsActivity : AppCompatActivity() { private val viewModel: NewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { ... lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { // Update UI elements } } } } } //compose @Composable fun LatestNewsScreen( viewModel: NewsViewModel = viewModel() ) { // Show UI elements based on the viewModel.uiState } . Not: Bu örnekte kullanılan belirli StateFlow objectleri, active collectorleri olmadığında çalışmayı durdurmaz, ancak flowlarla çalışırken bunların nasıl uygulandığını bilmeyebilirsiniz. Yaşam döngüsüne duyarlı flow collection kullanmak, daha sonra downstream collector kodunu tekrar ziyaret etmeden ViewModel flowlarinda bu tür değişiklikleri yapmanızı sağlar. Show in-progress operations . Bir UiState sınıfında yükleme statelerini temsil etmenin basit bir yolu, bir boole alanı kullanmaktır: . data class NewsUiState( val isFetchingArticles: Boolean = false, ... ) . Bu flag’in değeri, UI’de bir progress bar’in varlığını veya yokluğunu temsil eder. //views class NewsActivity : AppCompatActivity() { private val viewModel: NewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { ... lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { // Bind the visibility of the progressBar to the state // of isFetchingArticles. viewModel.uiState .map { it.isFetchingArticles } .distinctUntilChanged() .collect { progressBar.isVisible = it } } } } } //compose @Composable fun LatestNewsScreen( modifier: Modifier = Modifier, viewModel: NewsViewModel = viewModel() ) { Box(modifier.fillMaxSize()) { if (viewModel.uiState.isFetchingArticles) { CircularProgressIndicator(Modifier.align(Alignment.Center)) } // Add other UI elements. For example, the list. } } . Show errors on the screen . UI’de hataların gösterilmesi, devam eden işlemleri göstermeye benzer çünkü her ikisi de varlıklarını veya yokluklarını gösteren boolean değerlerle kolayca temsil edilir. Ancak hatalar, kullanıcıya geri iletmek için ilişkili bir mesajı veya başarısız işlemi yeniden deneyen bunlarla ilişkili bir action de içerebilir. Bu nedenle, devam eden bir işlem yüklenirken veya yüklenmezken, hata durumlarının, hatanın bağlamına uygun meta verileri barındıran data classlar ile modellenmesi gerekebilir. Örneğin, makaleler getirilirken bir progress bar gösteren önceki bölümdeki örneği ele alalım. Bu işlem bir hatayla sonuçlanırsa, kullanıcıya neyin yanlış gittiğini açıklayan bir veya daha fazla mesaj görüntülemek isteyebilirsiniz. data class Message(val id: Long, val message: String) data class NewsUiState( val userMessages: List&lt;Message&gt; = listOf(), ... ) . Hata mesajları daha sonra kullanıcıya snackbar gibi UI elementleri biçiminde sunulabilir. Bu, UI eventlerinin nasıl üretildiği ve tüketildiği ile ilgili olduğundan, daha fazla bilgi edinmek için UI eventleri sayfasına bakın. Threading and concurrency . Bir ViewModel’de gerçekleştirilen herhangi bir çalışma, main threadden çağrı yapmak için main-safe olmalıdır. Bunun nedeni, işi farklı bir threade taşımaktan data ve domain layerlarin sorumlu olmasıdır. Bir ViewModel uzun süren işlemler gerçekleştiriyorsa, bu logici bir background threade taşımaktan da sorumludur. Kotlin coroutineler, concurrent operasyonlari yönetmenin harika bir yoludur ve Jetpack Architecture Components, bunlar için yerleşik destek sağlar. Android uygulamalarında coroutineleri kullanma hakkında daha fazla bilgi edinmek için bkz. Kotlin coroutines on Android. Navigation . Uygulama navigationdaki değişiklikler genellikle event benzeri yayilmalardan(emission) kaynaklanır. Örneğin, bir SignInViewModel sınıfı bir oturum açma gerçekleştirdikten sonra, UiState’in isSignedIn fieldi true olarak ayarlanmış olabilir. Bunun gibi tetikleyiciler, consumption implementasyonunun Navigation componentini ertelemesi dışında, yukarıdaki Consume UI State bölümünde kapsananlar gibi tüketilmelidir. Paging . Paging library, UI’de PagingData adlı bir tip ile tüketilir. PagingData, zaman içinde değişebilen öğeleri temsil ettiğinden ve içerdiğinden - başka bir deyişle immutable bir tip değildir - sabit bir UI state’inde temsil edilmemelidir. Bunun yerine, ViewModel’den bağımsız olarak kendi akışında göstermelisiniz. Bunun belirli bir örneği için Android Paging codelab bakın. Animations . Akıcı ve sorunsuz top level navigation transitions sağlamak için, animasyona başlamadan önce ikinci ekranın veri yüklemesini beklemek isteyebilirsiniz. Android view framework, postponeEnterTransition() ve startPostponedEnterTransition() API’leri ile fragment destinationslari arasındaki geçişleri(transitions) geciktirmek için hook sağlar. Bu API’ler, ikinci ekrandaki UI elementleri (genellikle ağdan getirilen bir görüntü), kullanıcı arabirimi bu ekrana geçişi animate etmeden önce görüntülenmeye hazır olmasını sağlamanın bir yolunu sağlar. Daha fazla ayrıntı ve uygulama özellikleri için Android Motion örneğine bakın. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer/"
  },"36": {
    "doc": "About view binding",
    "title": "About view binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/about-view-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/about-view-binding/"
  },"37": {
    "doc": "About ViewModel",
    "title": "About ViewModel",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/about-viewmodel/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/about-viewmodel/"
  },"38": {
    "doc": "About WorkManager",
    "title": "About WorkManager",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/about-workmanager/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/about-workmanager/"
  },"39": {
    "doc": "Activities",
    "title": "Activities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/activities/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/activities/"
  },"40": {
    "doc": "Activity state changes",
    "title": "Activity state changes",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/activity-state-changes/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/activity-state-changes/"
  },"41": {
    "doc": "Add capabilities",
    "title": "Add capabilities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/add-capabilities/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/add-capabilities/"
  },"42": {
    "doc": "Add new destination types",
    "title": "Add new destination types",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/add-new-destination-types/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/add-new-destination-types/"
  },"43": {
    "doc": "Add support for back navigation",
    "title": "Add support for back navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/add-support-for-back-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/add-support-for-back-navigation/"
  },"44": {
    "doc": "Advanced concepts",
    "title": "Advanced concepts",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/advanced-concepts/advanced-concepts/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/advanced-concepts/advanced-concepts/"
  },"45": {
    "doc": "Android App Bundles",
    "title": "Android App Bundles",
    "content": " ",
    "url": "/docs/core-topics/android-app-bundles/android-app-bundles/",
    
    "relUrl": "/docs/core-topics/android-app-bundles/android-app-bundles/"
  },"46": {
    "doc": "Animate transitions between destinations",
    "title": "Animate transitions between destinations",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/animate-transitions-between-destinations/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/animate-transitions-between-destinations/"
  },"47": {
    "doc": "Animate transitions between fragments",
    "title": "Animate transitions between fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/animate-transitions-between-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/animate-transitions-between-fragments/"
  },"48": {
    "doc": "Animation",
    "title": "Animation",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/animation/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/animation/"
  },"49": {
    "doc": "App architecture",
    "title": "App architecture",
    "content": " ",
    "url": "/docs/app-architecture",
    
    "relUrl": "/docs/app-architecture"
  },"50": {
    "doc": "App basics",
    "title": "App basics",
    "content": " ",
    "url": "/docs/app-basics",
    
    "relUrl": "/docs/app-basics"
  },"51": {
    "doc": "App basics",
    "title": "Introduction",
    "content": "Google Codelabs . Training Courses | Android Developers . ",
    "url": "/docs/app-basics#introduction",
    
    "relUrl": "/docs/app-basics#introduction"
  },"52": {
    "doc": "App entry points",
    "title": "App entry points",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-entry-points/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-entry-points/"
  },"53": {
    "doc": "App fundamentals",
    "title": "Application fundamentals",
    "content": "Android uygulamaları Kotlin, Java ve C++ dilleri kullanılarak yazılabilir. Android SDK araçları, kodunuzu herhangi bir veri ve kaynak dosyasıyla birlikte bir APK veya Android App Bundle’da derler. Android dosyalari derlendikten sonra .apk dosya uzantisina sahip olarak paketlenirler. Bu uzanti sayesinde uygulama Android destekli bütün cihazlara yüklenebilir hale gelir. Android App Bundle ise .aab uzantisi ile derlenirler. Apk dosyalarına göre daha küçük boyutlara sahiptirler içinde gereksiz kullanilmamis yapilar bulunmaz. Google play’de uygulamalari yayınlamak için bu formatta yuklenir. Android cihazlara direkt olarak yuklenemez. Google play kendisi içerde uygulamalari apk ya çevirip indirilmeye hazir hale getirir. Örneğin, uygulamanızı Google Play üzerinden yayinlarken, Google Play’in sunucuları, yalnızca uygulamanın yüklenmesini isteyen belirli bir cihazın gerektirdiği kaynakları ve kodu içeren optimize edilmiş APK’lar oluşturur. Her android uygulamasi kendi guvenli sanal alaninda(sandbox) yasar, bu alanlar Androidin bazi ozellikleri sayesinde korunur: . | Android işletim sistemi her uygulamayi(app) farkli bir kullanici olarak goren multi user Linux sistemidir. | Sistem her uygulamaya bir Linux user ID si atar. Bu ID sadece sistemin kendisi tarafindan bilinir diğer uygulamalar bilmez. Sistem otomatik olarak uygulamadaki tüm dosyalara erisebilmesi icin o uygulamaya atanan ID ye özel izin ayarlar. | Her işlemin kendi sanal makinesi(VM) olusturulur, bu nedenle bir uygulamanin kodu diğer uygulamalardan ayri olarak calisir. | Yani her uygulama kendi linux surecinde calisir, Android sistemi uygulama açıldığında uygulamanın componentlerini baslatir ve artık ihtiyaç kalmadığında veya sistemin diğer uygulamalar için belleği kurtarması gerektiğinde işlemi kapatır. | . Android sistemi, principle of least privilege (en az ayricalik ilkesini) uygular. Yani her uygulama isini yapmak icin gerekli islemlere ulaşabilir , fazlasina ulaşamaz. Böylece uygulamaya izin verildigi olcude sistemin bölümlerine erişebilir. Bu da guvenli bir ortam yaratmis olur. Ancak bir uygulamanin diger uygulamalara ulasmasi gereken veya sistem servislerine ulasmasini gerektirecek durumlar vardir. Bu durumlarda: . | Aynı Linux kullanıcı kimliğini paylaşacak iki uygulama ayarlamak mümkündür, bu durumda birbirlerinin dosyalarına erişebilirler. Sistem kaynaklarını korumak için, aynı kullanıcı kimliğine sahip uygulamalar aynı Linux sürecinde çalışacak ve aynı VM(sanal makineyi)’yi paylaşacak şekilde düzenlenebilir. Uygulamalar da aynı sertifika ile imzalanmalıdır. | Bir uygulama, cihazın konumu, kamerası ve Bluetooth bağlantısı gibi cihaz verilerine erişmek için izin isteyebilir. Kullanıcının bu izinleri açıkça vermesi gerekir. Daha fazla bilgi için bkz. Sistem İzinleriyle Çalışma. | . ",
    "url": "/docs/app-basics/app-fundamentals/#application-fundamentals",
    
    "relUrl": "/docs/app-basics/app-fundamentals/#application-fundamentals"
  },"54": {
    "doc": "App fundamentals",
    "title": "App components",
    "content": "Uygulama componentleri, bir Android uygulamasının temel yapı taşlarıdır. Her component, sistemin veya kullanıcının uygulamanıza girebileceği bir giriş noktasıdır. Bazı componentler diğerlerine bağlıdır. Dört farklı türde uygulama componenti vardır: . | Activities | Services | Broadcast receivers | Content providers Her component farklı bir amaca hizmet eder, her biri nasıl oluşturulacağını ve yok edileceğini tanımlayan farklı bir yaşam döngüsüne sahiptir. Bu 4 componenti daha yakından tanıyalım: | . Activities . Bir activity, kullanıcı ile etkileşim için giriş noktasıdır. Kullanıcı arayüzü olarak tek bir ekranı temsil eder. Örneğin, bir e-posta uygulamasının; yeni e-postaların listesini gösteren bir activitysi, bir e-posta oluşturmak için başka bir activitysi ve e-postaları okumak için başka bir activitysi olabilir. Activityler, e-posta uygulamasında uyumlu bir kullanıcı deneyimi oluşturmak için birlikte çalışsa da, her biri diğerlerinden bağımsızdır. Bu nedenle, e-posta uygulaması izin veriyorsa, farklı bir uygulama bu activitylerden herhangi birini başlatabilir. Örneğin, bir kamera uygulaması, kullanıcının mailden bir resim paylaşmasına izin vermek için yeni posta oluşturan activityi, e-posta uygulamasında başlatabilir. Bir activity, sistem ve uygulama arasında aşağıdaki temel etkileşimleri kolaylaştırır: . | Sistemin activiteyi barındıran(hosting) süreci çalıştırmaya devam etmesini sağlamak için kullanıcının şu anda neyle ilgilendiğini (ekranda ne olduğunu) takip etmek. | Kullanıcının uygulama icinde farkli activityler arasında geçişler yapip geri dönebileceği şeyler (onStop a alinan activitler gibi) içerdiğini bilmek ve bu nedenle bu süreçleri takip altinda tutmaya daha fazla önem vermek. | Kullanici uygulama içinde gezinirken activitlerin oldurulmesi tekrar restore edilmesi gibi süreçlerden gecer, sistemin bu durumlarla basa cikmasina yardimci olmak | Uygulamaların birbirleri arasında kullanıcı akışları olmasi ve sistemin bu akışları koordine etmesi için bir rota sağlamak. (Buradaki en klasik örnek paylaşımdır.). | . Bir activity class i olusturmak icin Activity classini miras almanız gereklidir. Activity hakkinda daha fazla bilgi almak icin, Activities kılavuzu’na bakabilirsiniz. Services . Service, bir uygulamayı her türlü nedenden dolayı arka planda çalışır durumda tutmak için genel amaçlı bir entry pointtir. Uzun süren işlemleri gerçekleştirmek veya remote işlemler için arka planda çalışan bir componentdir. Bir kullanıcı arabirimi(UI) sağlamaz. Örneğin service, kullanıcı farklı bir uygulamadayken arka planda müzik çalabilir veya kullanıcının bir activity ile etkileşimini engellemeden ağ üzerinden veri çekebilir. Activity gibi başka bir componentde, service’i başlatabilir ve çalışmasına izin verebilir, ya da service ile etkileşime geçmek için ona bağlanabilir.. Sisteme bir uygulamanın nasıl yönetileceğini söyleyen iki tür service vardır: started services ve bound services. Started services, sisteme işleri tamamlanana kadar onları çalışır durumda tutmasını söyler. Bu, arka planda bazı verileri senkronize etmek veya kullanıcı uygulamadan ayrıldıktan sonra bile müzik çalmak olabilir. Arka planda verileri senkronize etmek veya müzik çalmak, sistemin bunları işleme şeklini değiştiren iki farklı started service türünü de temsil eder: . | Müzik çalma, kullanıcının doğrudan farkında olduğu bir şeydir, bu nedenle uygulama, bunu kullanıcıya bildirmek için bir bildirimle ön planda olmak istediğini söyleyerek sisteme bildirir; bu durumda sistem, bu servicein sürecini çalışır durumda tutmak için gerçekten çok uğraşması gerektiğini bilir, çünkü bu serivein ortadan kalkması durumunda kullanıcı mutsuz olacaktır. | Normal bir arka plan servicei, kullanıcının çalıştığının doğrudan farkında olduğu bir şey değildir, bu nedenle sistem sürecini yönetmede daha fazla özgürlüğe sahiptir. Kullanıcıyı daha yakından ilgilendiren şeyler için RAM’e ihtiyaç duyarsa, öldürülmesine (ve bir süre sonra serviei yeniden başlatmasına) izin verebilir. | . Bound sevices, başka bir uygulama (veya sistem) servicei kullanmak istediğini söylediği durumlarda çalışır. Bu temelde başka bir process için API sağlayan servicedir. Böylece sistem, bu processler arasında bir bağımlılık olduğunu bilir, dolayısıyla A process’i B process’ndeki bir service’e bağlı ise, B process’ini (ve service’ini) A için çalışır durumda tutması gerektiğini bilir. Ayrıca, eğer A process’i kullanıcıyla ilgili bir şeyse, o zaman B process’ini kullanıcının da bildigi bir şey olarak ele almayı da bilir. Esneklikleri nedeniyle (iyi ya da kötü), serviceler her türlü üst düzey sistem konsepti için gerçekten yararlı bir yapı taşı haline gelir. Live wallpapers, notification listeners, screen savers, input methods, accessibility services, ve diğer birçok core sistem özellikleri uygulamaların uyguladığı ve sistemin çalışması gerektiğinde bağlandığı serviceler olarak oluşturulmuştur. Bir service, Service sınıfından miras olarak olusturulur. Service sınıfı hakkında daha fazla bilgi için Services kılavuzuna bakın. Not: Uygulamanız Android 5.0 (API düzeyi 21) veya sonraki bir sürümünü hedefliyor ise, eylemleri planlamak için JobScheduler sınıfını kullanın. JobScheduler, güç tüketimini azaltmak için işleri en uygun şekilde planlayarak ve Doze API ile çalışarak pil tasarrufu avantajına sahiptir. Bu sınıfı kullanma hakkında daha fazla bilgi için JobScheduler referans belgelerine bakın. Broadcast receivers . Broadcast receivers, sistemin eventlari app’e normal bir kullanıcı akışından farkli olarak iletilmesini sağlayan ve app’in sistem genelindeki yayın(broadcast) duyurularına yanıt vermesini sağlayan bir componentdir. Broadcast receiverlar ile sistem şu anda çalışmayan uygulamalara bile yayınlar sunabilir. Örneğin, bir uygulama, kullanıcıya yaklaşan bir etkinlik hakkında bilgi vermek için bir bildirim göndermek üzere bir alarm planlayabilir, ve bu alarmı uygulamanın BroadcastReceiver’ına ileterek, alarm kapanana kadar uygulamanın çalışır durumda kalmasına gerek kalmaz. Birçok yayın sistem tarafindan yapilir; örneğin, ekranın kapandığını, pilin azaldığını veya bir fotoğrafın çekildiğini belirten bir yayın. Uygulamalar yayın başlatabilir; örneğin, diğer uygulamalara bazı verilerin cihaza indirildiğini ve kullanımları için hazır olduğunu bildirmek için. Broadcast receiverlar bir kullanıcı arabirimi görüntülemesede, bir yayın eventi meydana geldiğinde kullanıcıyı uyarmak için bir durum çubuğu bildirimi oluşturabilirler. Daha yaygın olarak, bir broadcast receiver yalnızca diğer componentlere açılan bir geçittir ve çok az miktarda iş yapması amaçlanmıştır. Örneğin, JobScheduler ile evente dayalı olarak bazı işleri gerçekleştirmek için bir JobService planlayabilir. Bir broadcast receiver, BroadcastReceiver‘ın bir alt sınıfı olarak uygulanir ve her yayın bir Intent nesnesi olarak teslim edilir. Daha fazla bilgi için BroadcastReceiver sınıfına bakın. Content providers . Bir content provider, dosya sisteminde, bir SQLite veritabanında, web’de veya uygulamanızın erişebileceği diğer herhangi bir kalıcı depolama konumunda paylaşılan depolayabileceğiniz bir app veri grubunu yönetir. Content provider izin veriyorsa, diğer uygulamalar, content provider aracılığıyla verileri sorgulayabilir veya değiştirebilir. Örneğin, Android sistemi, kullanıcının iletişim bilgilerini yöneten bir content provider sağlar. Bu nedenle, uygun izinlere sahip herhangi bir uygulama, belirli bir kişi hakkında bilgi okumak ve yazmak için ContactsContract.Data gibi bir content provideri sorgulayabilir. Bir content provideri herhangi bir veri tabanındaki abstract yapi olarak düşünmek cezbedicidir, çünkü bu yaygın durum için çok sayıda API ve destek halihazırda mevcuttur. Ancak, sistem tasarımı perspektifinden farklı bir temel amacı vardır. Sistem için bir content provider, bir URI şeması tarafından tanımlanan adlandırılmış veri öğelerini yayınlamak için bir uygulamaya giriş noktasıdır. Böylece bir uygulama, içerdiği verileri bir URI namespace’e nasıl map etmek istediğine karar verebilir ve bu URI’leri, verilere erişmek için bunları kullanabilecek diğer varlıklara(entity) dağıtabilir. Bunun sistemin bir uygulamayı yönetirken yapmasına izin verdiği birkaç özel şey vardır: . | Bir URI atamak uygulamanın çalışır durumda kalmasını gerektirmez, bu nedenle URI’lar sahip oldukları uygulamalar çıktıktan sonra da kalabilir. Sistemin, yalnızca ilgili URI’den uygulamanın verilerini alması gerektiğinde uygulamanın hala çalıştığından emin olması gerekir. | Bu URI’ler ayrıca önemli bir fine-grained güvenlik modeli sağlar. Örneğin, bir uygulama sahip olduğu bir resmin URI’sini panoya yerleştirebilir, ancak content providerı kilitli bırakarak diğer uygulamaların buna serbestçe erişememesini sağlayabilir. İkinci bir uygulama panodaki bu URI’ye erişmeye çalıştığında, sistem bu uygulamanın geçici bir URI izin verme yoluyla verilere erişmesine izin verebilir, böylece yalnızca bu URI’nin arkasındaki verilere erişmesine izin verilir, ancak ikinci uygulamada başka hiçbir şeye izin verilmez. | . İçerik sağlayıcılar(Content providers), uygulamanıza özel olan ve paylaşılmayan verileri okumak ve yazmak için de kullanışlıdır. Bir content provider, ContentProvider‘ın bir alt sınıfı olarak uygulanır ve diğer uygulamaların işlem gerçekleştirmesini sağlayan standart bir API kümesi uygulamalıdır. Daha fazla bilgi için Content Providers kılavuzuna bakın. Android sistem tasarımının benzersiz bir yönü, herhangi bir uygulamanın başka bir uygulamanın componentini başlatabilmesidir. Örneğin, kendi uygulamanizda kullanıcının cihazın kamerasıyla bir fotoğraf çekmesini istiyorsanız, telefonda bulunan kamera uygulamasini başlatabilirsiniz. Kamera uygulamasındaki kodu eklemeniz veya hatta bağlamanız gerekmez. Bunun yerine, fotoğraf çeken kamera uygulamasındaki activityi başlatabilirsiniz. Tamamlandığında, fotoğraf uygulamanıza yollanir, böylece onu kullanabilirsiniz. Kullanıcıya, kamera aslında uygulamanızın bir parçası gibi görünür. Sistem bir componenti başlattığında, halihazırda çalışmıyorsa o uygulama Özelinde processi başlatır ve component için gereken sınıfları başlatır. Örneğin, uygulamanız fotoğraf çeken kamera uygulamasında activity başlatırsa, bu activity sizin uygulamanızın processinde değil, kamera uygulamasına ait süreçte çalışır. Bu nedenle, diğer çoğu sistemdeki uygulamaların aksine, Android uygulamalarının tek bir entry point yoktur (main() işlevi yoktur). Sistem, diğer uygulamalara erişimi kısıtlayan dosya izinleriyle her uygulamayı ayrı bir processde çalıştırdığından(application fundamentals basligi altinda anlatmıştık), uygulamanız başka bir uygulamadan bir componenti doğrudan etkinleştiremez. Ancak, Android sistemi kendisi yapabilir. Bir componenti başka bir uygulamada etkinleştirmek için sisteme belirli componenti başlatma intent’inizi belirten bir mesaj iletin. Sistem daha sonra componenti sizin için baslatacaktir. Activate components . Dört component türünden üçü—activityler, services ve broadcast receivers—intent adı verilen asenkron bir mesajla etkinleştirilir. Intentler, çalışma zamanında(runtime) birbirinden bagimsiz componentleri birbirine bağlar. Intentleri kendi uygulamanıza veya başka bir uygulamaya ait olabilen, diğer componentlerden bir action talep eden haberciler olarak düşünebilirsiniz. Bir intent, belirli bir componenti (explicit intent) veya belirli bir component türünü (implicit intent) etkinleştirmek için bir mesaj tanımlayan bir Intent nesnesiyle oluşturulur. Activityler ve serviceler için, intent; gerçekleştirilecek eylemi tanımlar(örneğin, bir şeyi görüntülemek veya göndermek için) ve başlatılmakta olan component bilmesi gerekebilecek diğer şeylerin yanı sıra üzerinde işlem yapılacak verilerin URI’sini belirtebilir. Örneğin intent, bir activitynin bir resmi göstermesi veya bir web sayfasını açması için talep iletebilir. Bazı durumlarda, bir sonuç almak için bir activity başlatabilirsiniz, bu durumda activity aynı zamanda sonucu bir Intent olarak döndürür. Örneğin, kullanıcının personal contact seçmesine ve size geri göndermesine izin vermek için bir intent yayınlayabilirsiniz. Dönen intent, seçilen kişiye işaret eden bir URI içerir. Broadcast receiverlar için intent, basitçe yayınlanmakta olan duyuruyu tanımlar. Örnek olarak; intent, aygıtın pilinin zayıf olduğunu belirten cok bilinen bir eylem olan “battery is low” stringidir. Activitylerin, servicelerin ve broadcast receiverlarin aksine, content providerlar intentler ile etkinleştirilmez. Bunun yerine, bir ContentResolver‘dan gelen bir istek tarafından hedeflendiğinde etkinleştirilirler. Content Resolver, content provider ile olan tüm doğrudan işlemleri gerçekleştirir, böylece provider ile işlem gerçekleştiren componentin buna ihtiyacı olmaz ve bunun yerine ContentResolver nesnesindeki methodlari çağırır. Bu, content provider ile bilgi talep eden component arasında bir soyutlama katmanı bırakır(güvenlik için). Her component türünü etkinleştirmek için ayrı methodlar vardır: . | startActivity() veya startActivityForResult() methodlarina Intent paslayarak, | Android 5.0 (API düzeyi 21) ve sonraki sürümlerde, eylemleri(action) planlamak için JobScheduler sınıfını kullanabilirsiniz. Daha önceki Android sürümleri için, bir Intent öğesini startService() methoduna ileterek bir service başlatabilir (veya devam eden bir servise yeni talimatlar verebilirsiniz). BindService()‘e bir Intent ileterek service bağlanabilirsiniz. | sendBroadcast(), sendOrderedBroadcast(), veya sendStickyBroadcast() gibi yöntemlere bir Intent paslayarak bir broadcast başlatabilirsiniz. | Bir ContentResolver üzerinde query() methodunu çağırarak bir content providera sorgu gerçekleştirebilirsiniz. | . Intentleri kullanma hakkında daha fazla bilgi için Intents and Intent Filters belgesine bakın. ",
    "url": "/docs/app-basics/app-fundamentals/#app-components",
    
    "relUrl": "/docs/app-basics/app-fundamentals/#app-components"
  },"55": {
    "doc": "App fundamentals",
    "title": "The manifest file",
    "content": "Android sistemi bir uygulama componentini başlatmadan önce, sistem, uygulamanın manifest dosyası AndroidManifest.xml’yi okuyarak bileşenin var olduğunu bilmelidir. Uygulamanız, uygulama proje dizininin rootunda olması gereken tüm componentleri bu dosya icinde bildirmelidir. Manifest dosyasi, uygulamanın bileşenlerini bildirmenin yanı sıra aşağıdakiler gibi birkaç şey daha yapar: . | İnternet erişimi veya kullanıcının kişilerine okuma erişimi gibi uygulamanın gerektirdiği tüm kullanıcı izinlerini tanımlar. | Uygulamanın kullandığı API’lere bağlı olarak, uygulamanın gerektirdiği minimum API Düzeyini bildirir. | Kamera, bluetooth hizmetleri veya çoklu dokunmatik ekran gibi uygulama tarafından kullanılan veya gerekli olan donanım ve yazılım özelliklerini bildirir. | Uygulamanın Google Haritalar librarysi gibi (Android framework API’leri dışında) bağlanması gereken API librarylerini bildirir. | . Declare components . Manifestin birincil görevi, sistemi uygulamanın componentleri hakkında bilgilendirmektir. Örneğin, bir manifest dosyası aşağıdaki gibi bir activity bildirebilir: . &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest ... &gt; &lt;application android:icon=\"@drawable/app_icon.png\" ... &gt; &lt;activity android:name=\"com.example.project.ExampleActivity\" android:label=\"@string/example_label\" ... &gt; &lt;/activity&gt; ... &lt;/application&gt; &lt;/manifest&gt; . [](https://developer.android.com/guide/topics/manifest/application-element) öğesinde, android:icon attribute, uygulamayı tanımlayan bir icon için kaynaklara işaret eder. [](https://developer.android.com/guide/topics/manifest/activity-element) öğesinde, android:name attiribute, [Activity](https://developer.android.com/reference/android/app/Activity) alt sınıfının tam nitelikli sınıf adını belirtir ve android:label attribute, activity için kullanıcı tarafından görülebilen label olarak kullanılacak bir string belirtir. Aşağıdaki öğeleri kullanarak tüm uygulama bileşenlerini bildirmelisiniz: . &lt;activity&gt; activityler icin. &lt;service&gt; serviceler icin. &lt;receiver&gt; broadcast receiver icin . &lt;provider&gt; content provider icin . Kodlariniza dahil ettiğiniz ancak manifestte beyan etmediğiniz activityler, seviceler ve content providerlar sistem tarafından görülmez ve sonuç olarak hiçbir zaman çalıştırılamaz. Ancak, broadcast receiverlari manifestte bildirilebilir veya bunun yerine kodda dinamik olarak BroadcastReceiver nesneleri olarak oluşturulabilir ve registerReceiver() çağrılarak sisteme kaydedilebilirsiniz. Uygulamanız için manifest dosyasının nasıl yapılandırılacağı hakkında daha fazla bilgi için AndroidManifest.xml dosyası belgelerine bakın. Declare component capabilities . Yukarıda tartışıldığı gibi, Activating Components bölümünde, activityleri, serviceleri ve broadcast receiverlari başlatmak için bir Intent kullanabilirsiniz. Intentde hedef bileşeni explicit adlandırarak (component sınıfı adını kullanarak) bir intent kullanabilirsiniz. Ayrıca, gerçekleştirilecek eylemin türünü ve isteğe bağlı olarak eylemi gerçekleştirmek istediğiniz verileri açıklayan implicit bir intentde kullanabilirsiniz. Implicit intent, sistemin cihazda eylemi gerçekleştirebilecek ve başlatabilecek bir component bulmasını sağlar. Intent tarafından açıklanan eylemi gerçekleştirebilecek birden fazla component varsa, kullanıcı hangisini kullanacağını seçer. Dikkat: Bir Service başlatmak için bir intent kullanırsanız, explicit bir intent kullanarak uygulamanızın güvenli olduğundan emin olun. Bir service başlatmak için implicit bir intent kullanmak bir güvenlik tehlikesidir, çünkü intent’e hangi hizmetin yanıt vereceğinden emin olamazsınız ve kullanıcı hangi service’in başladığını göremez. Android 5.0’dan (API düzeyi 21) başlayarak, bindService() öğesini implicit bir intent ile çağırırsanız sistem bir exception firlatir. Serviceleriniz için intent filterlar beyan etmeyin. Sistem, alınan intenti cihazdaki diğer uygulamaların manifest dosyasında sağlanan intent filterlar ile karşılaştırarak bir intente yanıt verebilecek componentleri tanımlar. Uygulamanızın manifest dosyasinda bir activity bildirdiğinizde, isteğe bağlı olarak, diğer uygulamalardan gelen intentlere yanıt verebilmesi için activitynin yeteneklerini bildiren intent filterleri ekleyebilirsiniz. Componentin manifest elementinin alt öğesi olarak bir elementi ekleyerek componentiniz için bir intent filter bildirebilirsiniz. Örneğin, yeni bir e-posta oluşturma activitysi olan bir e-posta uygulaması oluşturursanız, aşağıdaki örnekte gösterildiği gibi “gönderme(send)” intentlerine yanıt vermek için (yeni bir e-posta göndermek için) bir intent filter bildirebilirsiniz: . &lt;manifest ... &gt; ... &lt;application ... &gt; &lt;activity android:name=\"com.example.project.ComposeEmailActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\" /&gt; &lt;data android:type=\"*/*\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; . Başka bir uygulama, ACTION_SEND action ile bir intent oluşturur ve bunu startActivity() methoduna iletirse, sistem, kullanıcının bir e-posta taslağı oluşturabilmesi ve gönderebilmesi için activitynizi başlatabilir. Intent filterleri oluşturma hakkında daha fazla bilgi için Intents ve Intent Filters belgesine bakın. Declare app requirements . Android tarafından desteklenen çeşitli cihazlar vardır ve bunların hepsi aynı özellikleri ve yetenekleri sağlamaz. Uygulamanızın, uygulamanızın ihtiyaç duyduğu özelliklere sahip olmayan cihazlara yüklenmesini önlemek için, manifest dosyanızda cihaz ve yazılım gereksinimlerini bildirerek uygulamanızın desteklediği cihaz türleri için açık bir şekilde bir profil tanımlamanız önemlidir. Bu bildirimlerin çoğu yalnızca bilgi amaçlıdır ve sistem bunları okumaz, ancak Google Play gibi harici hizmetler, kullanıcıların cihazlarından uygulama aradıklarında filtreleme sağlamak için bunları okur. Örneğin, uygulamanız bir kamera gerektiriyorsa ve Android 8.0’da (API Düzeyi 26) sunulan API’leri kullanıyorsa, bu gereksinimleri beyan etmeniz gerekir. minSdkVersion ve targetSdkVersion değerleri, uygulama modülünüzün build.gradle dosyasında ayarlanır: . android { ... defaultConfig { ... minSdkVersion 26 targetSdkVersion 29 } } . Not: MinSdkVersion ve targetSdkVersion’ı doğrudan manifest dosyasında ayarlamayın, çünkü derleme işlemi sırasında Gradle bunların üzerine yazılacaktır. Daha fazla bilgi için bkz. API düzeyi gereksinimlerini belirtme. Kamera özelliğini doğrudan uygulamanızın bildirim dosyasında bildirin: . &lt;manifest ... &gt; &lt;uses-feature android:name=\"android.hardware.camera.any\" android:required=\"true\" /&gt; ... &lt;/manifest&gt; . Bu örneklerde gösterilen bildirimler ile kamerası olmayan veya Android sürümü 8.0’dan düşük olan cihazlar, uygulamanızı Google Play’den yükleyemez. Ancak, uygulamanızın kamerayı kullandığını, ancak bunu gerektirmediğini beyan edebilirsiniz. Bu durumda, uygulamanız required attribute false olarak ayarlamalı ve çalışma zamanında cihazın bir kamerası olup olmadığını kontrol etmeli ve uygun şekilde tüm kamera özelliklerini devre dışı bırakmalıdır. Uygulamanızın farklı cihazlarla uyumluluğunu nasıl yönetebileceğiniz hakkında daha fazla bilgi Device Compatibility (Cihaz Uyumluluğu) dokumaninda sağlanır. ",
    "url": "/docs/app-basics/app-fundamentals/#the-manifest-file",
    
    "relUrl": "/docs/app-basics/app-fundamentals/#the-manifest-file"
  },"56": {
    "doc": "App fundamentals",
    "title": "App resources",
    "content": "Bir Android uygulaması koddan daha fazlasını içerir; görüntüler, ses dosyaları ve uygulamanın görsel sunumuyla ilgili her şey gibi kaynak koddan ayrı kaynaklar gerektirir. Örneğin, XML dosyalarıyla animasyonları, menüleri, stilleri, renkleri ve etkinlik kullanıcı arabirimlerinin düzenini tanımlayabilirsiniz. Uygulama kaynaklarını kullanmak, kodu değiştirmeden uygulamanızın çeşitli özelliklerini güncellemeyi kolaylaştırır. Alternatif kaynak grupları sağlamak, uygulamanızı farklı diller ve ekran boyutları gibi çeşitli cihaz yapılandırmaları için optimize etmenize olanak tanır. Android projenize dahil ettiğiniz her kaynak için, SDK oluşturma toollari, uygulama kodunuzdan veya XML’de tanımlanan diğer kaynaklardan, kaynağa başvurmak için kullanabileceğiniz unique bir integer ID tanımlar. Örneğin, uygulamanız logo.png (res/drawable/ dizinine kaydedilmiş) adlı bir resim dosyası içeriyorsa, SDK araçları R.drawable.logo adlı bir resources ID oluşturur. Bu ID, resme referans vermek ve onu kullanıcı arayüzünüze eklemek için kullanabileceğiniz uygulamaya özel bir integer ile eşlenir. Kaynak kodunuzdan ayrı kaynaklar sağlamanın en önemli yönlerinden biri, farklı cihaz yapılandırmaları için alternatif kaynaklar sağlama yeteneğidir. Örneğin, UI stringlerini XML’de tanımlayarak, stringleri diğer dillere çevirebilir ve bu stringleri ayrı dosyalara kaydedebilirsiniz. Ardından Android, kaynak dizinin adına (Fransızca dize değerleri için res/values-fr/ gibi) ve kullanıcının dil ayarına eklediğiniz bir dil niteleyicisine(qualifier) dayalı olarak kullanıcı arabiriminize uygun dil stringlerini bastirabilirsiniz. Android, alternatif kaynaklarınız için birçok farklı niteleyiciyi(qualifier) destekler. Niteleyici(qualifier), bu kaynakların kullanılacağı aygıt yapılandırmasını tanımlamak için kaynak dizinlerinizin adına eklediğiniz kısa bir dizedir. Örneğin, cihazın ekran yönüne ve boyutuna bağlı olarak activityleirniz için farklı layoutlar oluşturmalısınız. Aygıt ekranı dikey yönde (uzun) olduğunda, buttonlarin dikey olmasını isteyebilirsiniz, ancak ekran yatay yönde (geniş) olduğunda buttonlar yatay olarak hizalanabilir. Oryantasyona bağlı olarak layoutu değiştirmek için iki farklı layout tanımlayabilir ve her bir layoutun dizin adına uygun niteleyiciyi(qualifier) uygulayabilirsiniz. Ardından sistem, mevcut cihaz yönüne bağlı olarak uygun layoutu otomatik olarak uygular. For more about the different kinds of resources you can include in your application and how to create alternative resources for different device configurations, read Providing Resources. To learn more about best practices and designing robust, production-quality apps, see Guide to App Architecture. Additional resources . ",
    "url": "/docs/app-basics/app-fundamentals/#app-resources",
    
    "relUrl": "/docs/app-basics/app-fundamentals/#app-resources"
  },"57": {
    "doc": "App fundamentals",
    "title": "App fundamentals",
    "content": " ",
    "url": "/docs/app-basics/app-fundamentals/",
    
    "relUrl": "/docs/app-basics/app-fundamentals/"
  },"58": {
    "doc": "App links",
    "title": "App links",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/app-links/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/app-links/"
  },"59": {
    "doc": "App navigation",
    "title": "App navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-navigation/"
  },"60": {
    "doc": "App resources",
    "title": "App resources",
    "content": " ",
    "url": "/docs/app-basics/app-resources/app-resources/",
    
    "relUrl": "/docs/app-basics/app-resources/app-resources/"
  },"61": {
    "doc": "App shortcuts",
    "title": "App shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/app-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/app-shortcuts/"
  },"62": {
    "doc": "App startup",
    "title": "App startup",
    "content": " ",
    "url": "/docs/app-architecture/app-startup/",
    
    "relUrl": "/docs/app-architecture/app-startup/"
  },"63": {
    "doc": "Architectural Layering",
    "title": "Jetpack Compose architectural layering",
    "content": "Bu sayfa, Jetpack Compose’u oluşturan mimari katmanlara ve bu tasarımı bilgilendiren temel ilkelere üst düzey bir genel bakış sağlar. Jetpack Compose tek bir monolitik proje değildir; eksiksiz bir stack oluşturmak için bir araya getirilen bir dizi modülden oluşturulur. Jetpack Compose’u oluşturan farklı modülleri anlamak şunları yapmanızı sağlar: . | Uygulamanızı veya kütüphanenizi oluşturmak için uygun soyutlama seviyesini kullanın . | Daha fazla kontrol veya özelleştirme için ne zaman daha düşük bir seviyeye ‘inebileceğinizi’ anlayın . | Bağımlılıklarınızı en aza indirin . | . ",
    "url": "/docs/jetpack-compose/ui-architecture/architectural-layering/#jetpack-compose-architectural-layering",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/architectural-layering/#jetpack-compose-architectural-layering"
  },"64": {
    "doc": "Architectural Layering",
    "title": "Layers",
    "content": "Jetpack Compose’un başlıca katmanları şunlardır: . Şekil 1. Jetpack Compose’un ana katmanları . Her katman, daha üst düzey bileşenler oluşturmak için işlevselliği birleştirerek alt düzeyler üzerine inşa edilmiştir. Her katman, modül sınırlarını doğrulamak ve gerektiğinde herhangi bir katmanı değiştirmenize olanak sağlamak için alt katmanların genel API’lerini temel alır. Şimdi bu katmanları aşağıdan yukarıya doğru inceleyelim. Runtime . Bu modül, remember, mutableStateOf, @Composable annotation ve SideEffect gibi Compose çalışma zamanının temellerini sağlar. Compose’un UI’sine değil, yalnızca ağaç yönetimi yeteneklerine ihtiyacınız varsa, doğrudan bu katman üzerine inşa etmeyi düşünebilirsiniz. UI . UI katmanı birden fazla modülden oluşur (ui-text, ui-graphics, ui-tooling, vb.). Bu modüller LayoutNode, Modifier, input handlers, custom layouts ve çizim gibi UI araç setinin temellerini uygular. Yalnızca UI araç setinin temel kavramlarına ihtiyacınız varsa bu katman üzerine inşa etmeyi düşünebilirsiniz. Foundation . Bu modül, Compose UI için Row and Column, LazyColumn, belirli hareketlerin tanınması gibi tasarım sisteminden bağımsız yapı taşları sağlar. Kendi tasarım sisteminizi oluşturmak için bu katman üzerine inşa etmeyi düşünebilirsiniz. Material . Bu modül, Compose UI için Material Design sisteminin bir implementasyonunu sağlayarak bir tema sistemi, stilize bileşenler, dalgalanma göstergeleri ve ikonlar sunar. Uygulamanızda Materyal Tasarımı kullanırken bu katmanı temel alın. ",
    "url": "/docs/jetpack-compose/ui-architecture/architectural-layering/#layers",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/architectural-layering/#layers"
  },"65": {
    "doc": "Architectural Layering",
    "title": "Design principles",
    "content": "Jetpack Compose için yol gösterici bir prensip, birkaç monolitik bileşen yerine bir araya getirilebilen (veya oluşturulabilen) küçük, odaklanmış işlevsellik parçaları sağlamaktır. Bu yaklaşımın bir dizi avantajı vardır. Control . Daha yüksek seviyeli komponentler sizin için daha fazlasını yapma eğilimindedir, ancak sahip olduğunuz doğrudan kontrol miktarını sınırlar. Daha fazla kontrole ihtiyacınız varsa, daha düşük seviyeli bir komponent kullanmak için ‘aşağı inebilirsiniz’. Örneğin, bir komponentin rengini canlandırmak istiyorsanız animateColorAsState API’sini kullanabilirsiniz: . val color = animateColorAsState(if (condition) Color.Green else Color.Red) . Ancak daha sonra komponentin her zaman gri renkte başlamasını isterseniz, bunu bu API ile yapamazsınız. Bunun yerine daha düşük seviyeli Animatable API’yi kullanmak için aşağı inebilirsiniz: . val color = remember { Animatable(Color.Gray) } LaunchedEffect(condition) { color.animateTo(if (condition) Color.Green else Color.Red) } . Üst düzey animateColorAsState API’si, alt düzey Animatable API’si üzerine inşa edilmiştir. Alt seviye API’yi kullanmak daha karmaşıktır ancak daha fazla kontrol sunar. İhtiyaçlarınıza en uygun soyutlama seviyesini seçin. Customization . Daha küçük yapı taşlarından daha üst düzey komponentleri bir araya getirmek, ihtiyaç duyduğunuzda komponentleri özelleştirmeyi çok daha kolay hale getirir. Örneğin, Material katmanı tarafından sağlanan Button implementasyonunu düşünün: . @Composable fun Button( // … content: @Composable RowScope.() -&gt; Unit ) { Surface(/* … */) { CompositionLocalProvider(/* … */) { // set LocalContentAlpha ProvideTextStyle(MaterialTheme.typography.button) { Row( // … content = content ) } } } } . Bir Buton 4 komponentten bir araya getirilir: . | Arka plan, şekil, tıklama yönetimi vb. sağlayan bir Material Surface. | Buton etkinleştirildiğinde veya devre dışı bırakıldığında içeriğin alfasını değiştiren bir CompositionLocalProvider . | ProvideTextStyle, kullanılacak varsayılan metin stilini ayarlar . | Row, butonun içeriği için varsayılan layout ilkesini sağlar . | . Yapıyı daha net hale getirmek için bazı parametreleri ve açıklamaları çıkardık, ancak tüm komponent sadece yaklaşık 40 satır koddan oluşuyor çünkü butonu gerçekleştirmek için sadece bu 4 bileşeni bir araya getiriyor. Button gibi komponentler hangi parametreleri açığa çıkaracakları konusunda fikir sahibidirler ve bir komponentin kullanımını zorlaştırabilecek bir parametre patlamasına karşı ortak özelleştirmeleri mümkün kılmayı dengelerler. Örneğin Material komponentleri, Material Design sisteminde belirtilen özelleştirmeleri sunarak material tasarım ilkelerini takip etmeyi kolaylaştırır. Bununla birlikte, bir komponentin parametrelerinin ötesinde bir özelleştirme yapmak isterseniz, bir seviye ‘aşağı inebilir’ ve bir komponenti forklayabilirsiniz. Örneğin, Materyal Tasarım butonların düz renkli bir arka plana sahip olması gerektiğini belirtir. Gradyan bir arka plana ihtiyacınız varsa, bu seçenek Button parametreleri tarafından desteklenmez. Bu durumda Material Button implementasyonunu referans olarak kullanabilir ve kendi komponentinizi oluşturabilirsiniz: . @Composable fun GradientButton( // … background: List&lt;Color&gt;, modifier: Modifier = Modifier, content: @Composable RowScope.() -&gt; Unit ) { Row( // … modifier = modifier .clickable(onClick = {}) .background( Brush.horizontalGradient(background) ) ) { CompositionLocalProvider(/* … */) { // set material LocalContentAlpha ProvideTextStyle(MaterialTheme.typography.button) { content() } } } } . Yukarıdaki implementasyon, materyalin geçerli content alpha ve geçerli metin stili kavramları gibi materyal katmanındaki bileşenleri kullanmaya devam eder. Ancak material Surface’i bir Row ile değiştirir ve istenen görünümü elde etmek için onu stilize eder. Dikkat: Bir komponenti özelleştirmek için daha düşük bir katmana inerken, örneğin erişilebilirlik desteğini ihmal ederek herhangi bir işlevselliği azaltmadığınızdan emin olun. Forking yaptığınız komponenti bir rehber olarak kullanın. Material kavramlarını hiç kullanmak istemiyorsanız, örneğin kendi özel tasarım sisteminizi oluşturuyorsanız, yalnızca Foundation katman bileşenlerini kullanmaya geçebilirsiniz: . @Composable fun BespokeButton( // … backgroundColor: Color, modifier: Modifier = Modifier, content: @Composable RowScope.() -&gt; Unit ) { Row( // … modifier = modifier .clickable(onClick = {}) .background(backgroundColor) ) { // No Material components used content() } } . Jetpack Compose, en üst düzey komponentler için en basit isimleri ayırır. Örneğin, androidx.compose.material.Text, androidx.compose.foundation.text.BasicText üzerine inşa edilmiştir. Bu, daha yüksek seviyeleri değiştirmek isterseniz kendi implementasyonunuzu en keşfedilebilir isimle sağlamanızı mümkün kılar. Dikkat: Bir komponenti forklamak, upstream komponentin gelecekteki eklemelerinden veya hata düzeltmelerinden yararlanamayacağınız anlamına gelir. Picking the right abstraction . Compose’un katmanlı, yeniden kullanılabilir komponentler oluşturma felsefesi, her zaman alt seviye yapı taşlarına ulaşmamanız gerektiği anlamına gelir. Birçok üst düzey bileşen yalnızca daha fazla işlevsellik sunmakla kalmaz, aynı zamanda erişilebilirliği desteklemek gibi en iyi pratikleri de uygular. Örneğin, özel komponentinize gesture desteği eklemek istiyorsanız, bunu Modifier.pointerInput kullanarak sıfırdan oluşturabilirsiniz, ancak bunun üzerine inşa edilmiş ve daha iyi bir başlangıç noktası sunabilecek Modifier.draggable, Modifier.scrollable veya Modifier.swipeable gibi daha yüksek seviyeli başka komponentler de vardır. Kural olarak, içerdikleri en iyi pratiklerden faydalanmak için ihtiyacınız olan işlevselliği sunan en üst düzey komponent üzerine inşa etmeyi tercih edin. Learn More . Özel bir tasarım sistemi oluşturma örneği için Jetsnack örneğine bakın. ",
    "url": "/docs/jetpack-compose/ui-architecture/architectural-layering/#design-principles",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/architectural-layering/#design-principles"
  },"66": {
    "doc": "Architectural Layering",
    "title": "Architectural Layering",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/architectural-layering/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/architectural-layering/"
  },"67": {
    "doc": "Architecture components",
    "title": "Architecture components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/architecture-components/",
    
    "relUrl": "/docs/app-architecture/architecture-components/architecture-components/"
  },"68": {
    "doc": "Architecture recommendations",
    "title": "Architecture recommendations",
    "content": "Recommendations for Android Architecture . Bu sayfada çeşitli Architecture best practiceleri ve önerileri sunulmaktadır. Uygulamanızın kalitesini, sağlamlığını ve ölçeklenebilirliğini artırmak için bunları benimseyin. Ayrıca uygulamanızın bakımını ve test edilmesini de kolaylaştırırlar. Not: Bu belgedeki önerileri katı gereklilikler olarak değil tavsiyeler olarak ele almalısınız. Gerektiğinde bunları uygulamanıza uyarlayın. Aşağıdaki best practiceler konuya göre gruplandırılmıştır. Her birinin, ekibin ne kadar güçlü bir şekilde önerdiğini yansıtan bir önceliği vardır. Öncelikler listesi aşağıdaki gibidir: . | Strongly recommended: Yaklaşımınızla temelden çelişmediği sürece bu pratiği uygulamalısınız. | Recommended: Bu pratiğin uygulamanızı geliştirmesi muhtemeldir. | Optional: Bu pratik, belirli durumlarda uygulamanızı geliştirebilir. | . Not: Bu önerileri anlamak için [Architecture kılavuzu](guide-to-app-architecture)na aşina olmanız gerekir. Layer Architecture . Önerdiğimiz katmanlı mimari, seperation of concern’i destekler. UI’yi veri modellerinden yönlendirir, single source of truth ilkesine uyar ve undirectional data flow ilkelerini takip eder. İşte katmanlı mimari için bazı best practiceler: . | Recommendation | Description | . | Açıkça tanımlanmış bir data katmanı kullanın. Strongly recommended: | Data katmanı, uygulama verilerini uygulamanın geri kalanına sunar ve uygulamanızın business logic’inin büyük çoğunluğunu içerir.&lt;/br&gt; * Sadece tek bir veri kaynağı içerse bile veri repositorylerini oluşturmalısınız. &lt;/br&gt;* Küçük uygulamalarda, data katmanı türlerini bir data paketine veya modülüne yerleştirmeyi seçebilirsiniz | . | Açıkça tanımlanmış bir UI katmanı kullanın. Strongly recommended: | UI katmanı, uygulama verilerini ekranda görüntüler ve kullanıcı etkileşiminin birincil noktası olarak hizmet eder.&lt;/br&gt;* Küçük uygulamalarda, data katmanı tiplerini bir UI paketine veya modülüne yerleştirmeyi seçebilirsiniz.Daha fazla UI katmanı best practiceleri burada. | . | Data katmanı, bir repository kullanarak uygulama verilerini açığa çıkarmalıdır. Strongly recommended: | UI katmanındaki componentler, activity’ler veya ViewModel’lar gibi componentler doğrudan bir veri kaynağı ile etkileşime girmemelidir. Veri kaynaklarına örnekler şunlardır: &lt;/br&gt;* Databases, DataStore, SharedPreferences, Firebase APIs.&lt;/br&gt; * GPS location providers. &lt;/br&gt; * Bluetooth data providers.&lt;/br&gt; * Network connectivity status provider. | . | Coroutines ve flowlari kullanin. Strongly recommended: | Katmanlar arasında iletişim kurmak için coroutine’leri ve flow’ları kullanın. More coroutines best practices here. | . | Domain layer kullanin. Recommended in big apps | Birden fazla ViewModel’de data katmanıyla etkileşime giren business logic’i yeniden kullanmanız gerekiyorsa veya belirli bir ViewModel’in business logic karmaşıklığını basitleştirmek istiyorsanız bir domain katmanı, use caseleri kullanın. | . UI Layer . UI katmanının rolü, uygulama verilerini ekranda görüntülemek ve kullanıcı etkileşiminin birincil noktası olarak hizmet etmektir. İşte UI katmanı için bazı best practiceler: . | Recommendation | Description | . | Unidirectional Data Flow (UDF’i takip edin.. Strongly recommended: | ViewModel’lerin observer pattern kullanarak UI state’ini gösterdiği ve metot çağrıları yoluyla UI’dan action’lar aldığı Unidirectional Data Flow (UDF) prensiplerini takip edin. | . | Faydaları uygulamanız için uygunsa AAC ViewModellerini kullanın. Strongly recommended: | Business logic’i handle etmek için AAC ViewModels’i kullanın ve UI state’ini UI’ye göstermek için uygulama verilerini getirin (Compose veya Android Views).&lt;/br&gt; See more ViewModel best practices here.&lt;/br&gt;See the benefits of ViewModels here. | . | Yaşam döngüsüne duyarlı UI state collection kullanın. Strongly recommended: | Uygun yaşam döngüsüne duyarlı coroutine builder kullanarak UI state’ini UI’dan collect edin: View sisteminde repeatOnLifecycle ve Jetpack Compose’da collectAsStateWithLifecycle.&lt;/br&gt;Read more about repeatOnLifecycle.&lt;/br&gt; Read more about about collectAsStateWithLifecycle. | . | ViewModel’den UI’ye event göndermeyin. Strongly recommended: | Event’i ViewModel’de doğrudan işleyin ve event’in işlenmesinin sonucuyla bir state güncellemesine neden olun. UI event’leri hakkında daha fazla bilgiyi burada bulabilirsiniz. | . | Single-activity application kullanin. Recommended | Uygulamanızın birden fazla ekranı varsa ekranlar arasında gezinmek ve uygulamanıza deep link vermek için Navigation Fragments veya Navigation Compose kullanın. | . | Jetpack Compose kullanin. Recommended | Telefonlar, tabletler, katlanabilir cihazlar ve Wear OS için yeni uygulamalar oluşturmak üzere Jetpack Compose’u kullanın. | . Aşağıdaki kod parçacığı, UI state’inin yaşam döngüsüne duyarlı bir şekilde nasıl collect edileceğini özetlemektedir: . //Views class MyFragment : Fragment() { private val viewModel: MyViewModel by viewModel() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launch { viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { // Process item } } } } } //Compose @Composable fun MyScreen( viewModel: MyViewModel = viewModel() ) { val uiState by viewModel.uiState.collectAsStateWithLifecycle() } . ViewModel . ViewModeller, UI state’ini sağlamaktan ve data katmanına erişimden sorumludur. ViewModel’ler için bazı best practiceler aşağıda verilmiştir: . | Recommendation | Description | . | ViewModeller Android yaşam döngüsünden bağımsız olmalıdır. Strongly recommended: | ViewModel’ler Yaşam Döngüsü ile ilgili herhangi bir tipe referans tutmamalıdır. Activity, Fragment, Context veya Resources’ı bağımlılık olarak geçirmeyin. Bir şeyin ViewModel’de bir Context’e ihtiyacı varsa, bunun doğru katmanda olup olmadığını mutlaka değerlendirmelisiniz. | . | Coroutine’leri ve flow’ları kullanın. Strongly recommended: | ViewModel, data veya domain katmanları ile etkileşime girer:&lt;/br&gt;Uygulama verilerini almak için Kotlin flow’ları,&lt;/br&gt; viewModelScope kullanarak actionlari gerçekleştirmek için suspend fonksiyonlari kullanin. | . | Ekran seviyesinde ViewModelleri kullanın.&lt;/br&gt; Strongly recommended: | ViewModel’ları yeniden kullanılabilir UI parçalarında kullanmayın. ViewModel’leri şuralarda kullanmalısınız;&lt;/br&gt;Screen-level composables,&lt;/br&gt;Activities/Fragments in Views,&lt;/br&gt;Destinations or graphs when using Jetpack Navigation. | . | Use plain state holder classes in reusable UI components.&lt;/br&gt; Strongly recommended: | Yeniden kullanılabilir UI component’lerinde karmaşıklığı ele almak için düz state holder sınıflarını kullanın. Bunu yaparak, state harici olarak çağrılabilir ve kontrol edilebilir. | . | AndroidViewModel kullanma. Recommended | ViewModel class kullanin, AndroidViewModel kullanmayin. ViewModelde Application class kullanmamalisiniz. Bunun yerine, bağımlılığı UI veya data katmanına taşıyın. | . | Bir UI state açığa çıkarın. Recommended | ViewModeller, uiState adlı single property aracılığıyla UI’ye veri göstermelidir. UI birden fazla, ilgisiz veri parçası gösteriyorsa, VM multiple UI state property gösterebilir.&lt;/br&gt;uiState’i bir StateFlow yapmalısınız.&lt;/br&gt;Veriler hiyerarşinin diğer katmanlarından bir veri akışı olarak geliyorsa, WhileSubscribed(5000) ilkesiyle (örnek) stateIn operatörünü kullanarak uiState oluşturmalısınız.&lt;/br&gt;Data katmanından gelen veri akışlarının olmadığı daha basit durumlar için, immutable bir StateFlow olarak açığa çıkan bir MutableStateFlow kullanmak kabul edilebilir (örnek).&lt;/br&gt;Data, error ve loading sinyalleri içerebilen bir data class olarak ${Screen}UiState’e sahip olmayı seçebilirsiniz. Bu sınıf, farklı statelerin özel olması halinde sealed class da olabilir.Application sınıfı ViewModel’de kullanılmamalıdır. Application sınıfı ViewModel’de kullanılmamalıdır. Bunun yerine, bağımlılığı kullanıcı arayüzüne veya veri katmanına taşıyın. | . Aşağıdaki kod parçacığı, UI state’inin bir ViewModel’den nasıl açığa çıkarılacağını özetlemektedir: . @HiltViewModel class BookmarksViewModel @Inject constructor( newsRepository: NewsRepository ) : ViewModel() { val feedState: StateFlow&lt;NewsFeedUiState&gt; = newsRepository .getNewsResourcesStream() .mapToFeedState(savedNewsResourcesState) .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = NewsFeedUiState.Loading ) // ... } . Lifecycle . Aşağıda Android yaşam döngüsü ile çalışmaya yönelik best practiceler yer almaktadır: . | Recommendation | Description | . | Activity’lerde veya Fragment’larda yaşam döngüsü metotlarını override etmeyin.&lt;/br&gt; Strongly recommended: | Activity’lerde veya Fragment’larda onResume gibi yaşam döngüsü metodlarını override etmeyin. Bunun yerine LifecycleObserver kullanın. Uygulamanın, yaşam döngüsü belirli bir Lifecycle.State değerine ulaştığında iş yapması gerekiyorsa repeatOnLifecycle API’sini kullanın. | . Aşağıdaki kod parçacığı, belirli bir Yaşam Döngüsü state’i verildiğinde işlemlerin nasıl gerçekleştirileceğini özetlemektedir: . //Views class MyFragment: Fragment() { override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycle.addObserver(object : DefaultLifecycleObserver { override fun onResume(owner: LifecycleOwner) { // ... } override fun onPause(owner: LifecycleOwner) { // ... } } } } //Compose @Composable fun MyApp() { val lifecycleOwner = LocalLifecycleOwner.current DisposableEffect(lifecycleOwner, ...) { val lifecycleObserver = object : DefaultLifecycleObserver { override fun onStop(owner: LifecycleOwner) { // ... } } lifecycleOwner.lifecycle.addObserver(lifecycleObserver) onDispose { lifecycleOwner.lifecycle.removeObserver(lifecycleObserver) } } } . Handle dependencies . Componentler arasındaki bağımlılıkları yönetirken gözlemlemeniz gereken birkaç best practice vardir: . | Recommendation | Description | . | Dependency injection kullanin.&lt;/br&gt; Strongly recommended: | Dependency injection best practiceleri kullanin, ozellikle mumkun oldugunca constructor injection kullanin. | . | Gerektiginde bir componentin scope’nu belirleyin.&lt;/br&gt; Strongly recommended: | Scope to a dependency container; tip paylaşılması gereken mutable veriler içerdiğinde veya tipin init edilmesi pahalı olduğunda ve uygulamada yaygın olarak kullanıldığında. | . | Hilt kullanin. Recommended | Basit uygulamalarda Hilt veya manual dependency injection kullanin. Uygulamaniz karmasiklastiginda Hilt kullanin. Ornegin asagidakilere sahipseniz: &lt;/br&gt;Multiple screens with ViewModels—integration&lt;/br&gt;WorkManager usage—integration&lt;/br&gt;Advance usage of Navigation, such as ViewModels scoped to the nav graph—integration. | . Testing . Aşağıda test için bazı best practiceler verilmiştir: . | Recommendation | Description | . | Neyi test edeceginizi bilin. Strongly recommended: | Unless the project is roughly as simple as a hello world app, you should test it, at minimum with:&lt;/br&gt;Unit test ViewModels, including Flows.&lt;/br&gt;Unit test data layer entities. That is, repositories and data sources.&lt;/br&gt;UI navigation tests that are useful as regression tests in CI. | . | Prefer fakes to mocks. Strongly recommended: | Read more in the Use test doubles in Android documentation. | . | Test StateFlows. Strongly recommended: | When testing StateFlow:&lt;/br&gt;Assert on the value property whenever possible&lt;/br&gt;You should create a collectJob if using WhileSubscribed | . Daha fazla bilgi için Android DAC’da neleri test etmeli kılavuzuna bakın. Models . Uygulamalarınızda model geliştirirken bu best practiceleri uymalısınız: . | Recommendation | Description | . | Karmaşık uygulamalarda her katman için bir model oluşturun. Recommended | Karmaşık uygulamalarda, mantıklı olduğunda farklı katmanlarda veya componentlerde yeni modeller oluşturun. Aşağıdaki örnekleri göz önünde bulundurun:&lt;/br&gt;Uzak bir veri kaynağı, ağ üzerinden aldığı modeli, yalnızca uygulamanın ihtiyaç duyduğu verileri içeren daha basit bir sınıfla eşleyebilir&lt;/br&gt;Repository’ler DAO modellerini sadece UI katmanının ihtiyaç duyduğu bilgilerle daha basit data classlara eşleyebilir.&lt;/br&gt;ViewModel, UiState sınıflarındaki data katmanı modellerini içerebilir. | . Naming Conventions . Kod tabanınızı adlandırırken, aşağıdaki best practice’lerden haberdar olmalısınız: . | Recommendation | Description | . | Methodlari isimlendirmek.&lt;/br&gt; Optional: | Metodlar bir fiil cümlesi olmalıdır. Örneğin, makePayment(). | . | Propertyleri isimlendirmek.&lt;/br&gt; Optional: | Propertyler bir isim cümlesi olmalıdır. Örneğin, inProgressTopicSelection. | . | Data akislarini isimlendirmek&lt;/br&gt; Optional: | Bir sınıf bir Flow stream, LiveData veya başka bir stream sunduğunda, adlandırma kuralı get{model}Stream() şeklindedir. Örneğin, getAuthorStream(): Flow. Fonksiyon bir model listesi döndürüyorsa, model adı çoğul olmalıdır:getAuthorsStream(): Flow&lt;List&gt; | . | Interface implementasyonlarini isimlendirmek.&lt;/br&gt; Optional: | Interfacelerin implementasyonları için isimler anlamlı olmalıdır. Daha iyi bir isim bulunamazsa önek olarak Default kullanın. Örneğin, bir NewsRepository interface’i için OfflineFirstNewsRepository veya InMemoryNewsRepository kullanabilirsiniz. Eğer iyi bir isim bulamazsanız, DefaultNewsRepository kullanın. Sahte implementasyonların önüne FakeAuthorsRepository’de olduğu gibi Fake eklenmelidir. | . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/architecture-recommendatios/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/architecture-recommendatios/"
  },"69": {
    "doc": "Architecture",
    "title": "Architecting your Compose UI",
    "content": "Compose’da UI immutable’dır - çizildikten sonra onu güncellemenin bir yolu yoktur. Kontrol edebileceğiniz şey UI’nizin state’idir. UI’nin state’i her değiştiğinde, Compose UI ağacının değişen kısımlarını yeniden oluşturur. Composable’lar state kabul edebilir ve event’leri açığa çıkarabilir; örneğin bir TextField bir değer kabul eder ve callback handler’dan değeri değiştirmesini isteyen bir callback onValueChange sunar. var name by remember { mutableStateOf(\"\") } OutlinedTextField( value = name, onValueChange = { name = it }, label = { Text(\"Name\") } ) . Composable’lar state kabul ettiğinden ve event’leri açığa çıkardığından, tek yönlü veri akış modeli(unidirectional data flow pattern) Jetpack Compose ile iyi uyum sağlar. Bu kılavuz, Compose’da tek yönlü veri akışı modelinin nasıl uygulanacağına, event’lerin ve state holder’ların nasıl uygulanacağına ve Compose’da ViewModel’lerle nasıl çalışılacağına odaklanmaktadır. Not: Uygulamanızın diğer katmanları (data katmanı ve business katmanı) Jetpack Compose’un benimsenmesinden etkilenmez. Uygulamanızın tüm katmanlarını tasarlama hakkında daha fazla bilgi edinmek için uygulama mimarisi kılavuzuna göz atın. ",
    "url": "/docs/jetpack-compose/ui-architecture/architecture/#architecting-your-compose-ui",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/architecture/#architecting-your-compose-ui"
  },"70": {
    "doc": "Architecture",
    "title": "Unidirectional data flow",
    "content": "Tek yönlü veri akışı (UDF), state’in aşağı ve event’lerin yukarı aktığı bir tasarım modelidir. Tek yönlü veri akışını izleyerek, UI’da state’i görüntüleyen composable’ları uygulamanızın state’i depolayan ve değiştiren kısımlarından ayırabilirsiniz. Tek yönlü veri akışını kullanan bir uygulamanın UI güncelleme döngüsü şu şekildedir: . | Event: UI’nin bir kısmı bir event üretir ve bunu yukarı doğru iletir, mesela ViewModel’e ele alması için iletilen bir buton tıklaması gibi; veya uygulamanızın diğer katmanlarından bir event iletilir, mesela kullanıcı oturumunun süresinin dolduğunu belirtmek gibi. | Update state: Bir event handler state’i değiştirebilir. | Display state: State holder state’i aşağı aktarır ve UI bunu görüntüler. | . Sekil 1.Unidirectional data flow (tek yönlü veri akışı) modeli . Jetpack Compose kullanırken bu modeli takip etmek çeşitli avantajlar sağlar: . | Test edilebilirlik: State’i, onu görüntüleyen UI’dan ayırmak, her ikisini de izole olarak test etmeyi kolaylaştırır. | State encapsulation: State yalnızca tek bir yerde güncellenebildiğinden ve bir composable’ın state’i için yalnızca tek bir doğruluk kaynağı olduğundan, tutarsız state’ler nedeniyle hata oluşturma olasılığınız daha düşüktür. | UI tutarlılığı: Tüm state güncellemeleri, StateFlow veya LiveData gibi gözlemlenebilir state holder’lar kullanılarak anında UI’ye yansıtılır. | . Unidirectional data flow in Jetpack Compose . Composables state ve event’lere dayalı olarak çalışır. Örneğin, bir TextField yalnızca değer parametresi güncellendiğinde güncellenir ve bir onValueChange callback (değerin yenisiyle değiştirilmesini isteyen bir event) sunar. Compose, State nesnesini bir value tutucu olarak tanımlar ve state değerindeki değişiklikler bir recomposition’ı tetikler. Değeri ne kadar süreyle hatırlamanız gerektiğine bağlı olarak state’i bir remember { mutableStateOf(value) } veya bir rememberSaveable { mutableStateOf(value) içinde tutabilirsiniz. TextField composable’ın değerinin türü String’dir, dolayısıyla bu değer herhangi bir yerden gelebilir; sabit kodlanmış bir değerden, bir ViewModel’den veya üst composable’dan aktarılabilir. Bunu bir State nesnesinde tutmanız gerekmez, ancak onValueChange çağrıldığında değeri güncellemeniz gerekir. Önemli Noktalar . | mutableStateOf(value), Compose’da gözlemlenebilir bir tür olan bir MutableState oluşturur. Değerindeki herhangi bir değişiklik, bu değeri okuyan herhangi bir composable fonksiyonunun yeniden oluşturulmasını(recomposition) programlayacaktır. | remember nesneleri composition’da saklar ve remember’ı çağıran composable composition’dan kaldırıldığında nesneyi unutur. | rememberSaveable, bir Bundle’a kaydederek konfigürasyon değişiklikleri boyunca durumu korur. | . Not: Compose’da state ve state hoisting hakkında daha fazla bilgi edinmek için State ve Jetpack Compose bölümüne bakın. Define composable parameters . Bir composable’ın state parametrelerini tanımlarken aşağıdaki soruları aklınızda tutmalısınız: . | Composable ne kadar yeniden kullanılabilir veya esnektir? . | State parametreleri bu composable’ın performansını nasıl etkiler? . | . Decoupling’i ve yeniden kullanımı teşvik etmek için, her bir composable mümkün olan en az miktarda bilgiyi tutmalıdır. Örneğin, bir haber makalesinin başlığını tutmak için bir composable oluştururken, tüm haber makalesi yerine yalnızca görüntülenmesi gereken bilgileri aktarmayı tercih edin: . @Composable fun Header(title: String, subtitle: String) { // Başlık veya altyazı değiştiğinde yeniden oluşturur. } @Composable fun Header(news: News) { // Yeni bir News instance'ı gecildiginde yeniden oluşturur. } . Bazen tek tek parametreler kullanmak da performansı artırır - örneğin, News yalnızca başlık ve altyazıdan daha fazla bilgi içeriyorsa, Header(news) öğesine yeni bir News instance’ı geçildiğinde, başlık ve altyazı değişmemiş olsa bile composable yeniden oluşturulur. Geçtiğiniz parametre sayısını dikkatlice düşünün. Çok fazla parametresi olan bir fonksiyona sahip olmak fonksiyonun ergonomisini azaltır, bu nedenle bu durumda bunları bir sınıfta gruplamak tercih edilir. ",
    "url": "/docs/jetpack-compose/ui-architecture/architecture/#unidirectional-data-flow",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/architecture/#unidirectional-data-flow"
  },"71": {
    "doc": "Architecture",
    "title": "Events in Compose",
    "content": "Uygulamanıza yapılan her girdi bir event olarak temsil edilmelidir: dokunmalar, metin değişiklikleri ve hatta zamanlayıcılar veya diğer güncellemeler. Bu event’ler UI’nızın state’ini değiştirdiğinden, bunları ele alacak ve UI state’ini güncelleyecek olan ViewModel olmalıdır. UI katmanı asla bir event handler dışında state değiştirmemelidir çünkü bu uygulamanızda tutarsızlıklara ve hatalara yol açabilir. State ve event handler lambdaları için immutable değerler geçirmeyi tercih edin. Bu yaklaşımın aşağıdaki faydaları vardır: . | Yeniden kullanılabilirliği artırırsınız. | UI’nizin state değerini doğrudan değiştirmemesini sağlarsınız. | State’in başka bir thread tarafından değiştirilmediğinden emin olduğunuz için eş zamanlılık(concurrency) sorunlarından kaçınırsınız. | Genellikle kod karmaşıklığını azaltırsınız. | . Örneğin, parametre olarak bir String ve bir lambda kabul eden bir composable birçok bağlamdan(context) çağrılabilir ve yüksek oranda yeniden kullanılabilir. Uygulamanızdaki app bar’ın her zaman metin gösterdiğini ve bir geri butonu olduğunu varsayalım. Metni ve geri butonu handle’ını parametre olarak alan daha genel bir MyAppTopAppBar composable’ı tanımlayabilirsiniz: . @Composable fun MyAppTopAppBar(topAppBarText: String, onBackPressed: () -&gt; Unit) { TopAppBar( title = { Text( text = topAppBarText, textAlign = TextAlign.Center, modifier = Modifier .fillMaxSize() .wrapContentSize(Alignment.Center) ) }, navigationIcon = { IconButton(onClick = onBackPressed) { Icon( Icons.Filled.ArrowBack, contentDescription = localizedString ) } }, // ... ) } . ViewModels, states, and events: an example . ViewModel ve mutableStateOf kullanarak, aşağıdakilerden biri doğruysa uygulamanızda tek yönlü veri akışı(unidirectional data flow) da sağlayabilirsiniz: . | UI’nizin state’i, StateFlow veya LiveData gibi gözlemlenebilir state holder’lar aracılığıyla açığa çıkar. | ViewModel, UI’dan veya uygulamanızın diğer katmanlarından gelen eventleri ele alır ve state holder’ı eventlere göre günceller. | . Örneğin, bir oturum açma ekranı uygularken, Oturum Aç butonuna dokunmak uygulamanızın bir progress spinner ve bir ağ çağrısı görüntülemesine neden olmalıdır. Oturum açma işlemi başarılı olduysa uygulamanız farklı bir ekrana gider; hata durumunda ise uygulama bir Snackbar gösterir. Ekran state’ini ve event’i şu şekilde modelleyebilirsiniz: . Ekranın dört state’i vardır: . | Oturum kapatıldı: kullanıcı henüz oturum açmadığında. | Devam ediyor: uygulamanız şu anda bir ağ çağrısı gerçekleştirerek kullanıcıyla oturum açmaya çalışıyorsa. | Hata: oturum açma sırasında bir hata oluştuğunda. | Oturum açıldı: kullanıcı oturum açtığında. | . Bu state’leri sealed bir sınıf olarak modelleyebilirsiniz. ViewModel state’i bir State olarak gösterir, ilk state’i ayarlar ve gerektiğinde state’i günceller. ViewModel ayrıca bir onSignIn() metodu göstererek oturum açma olayını yönetir. class MyViewModel : ViewModel() { private val _uiState = mutableStateOf&lt;UiState&gt;(UiState.SignedOut) val uiState: State&lt;UiState&gt; get() = _uiState // ... } . MutableStateOf API’sine ek olarak Compose, LiveData, Flow ve Observable için bir dinleyici olarak kaydolmak ve değeri bir state olarak temsil etmek için extension fonksiyonlar sağlar. class MyViewModel : ViewModel() { private val _uiState = MutableLiveData&lt;UiState&gt;(UiState.SignedOut) val uiState: LiveData&lt;UiState&gt; get() = _uiState // ... } @Composable fun MyComposable(viewModel: MyViewModel) { val uiState = viewModel.uiState.observeAsState() // ... } . ",
    "url": "/docs/jetpack-compose/ui-architecture/architecture/#events-in-compose",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/architecture/#events-in-compose"
  },"72": {
    "doc": "Architecture",
    "title": "Learn More",
    "content": "Jetpack Compose’da mimari hakkında daha fazla bilgi edinmek için aşağıdaki kaynaklara başvurun: . Samples . | Jetnews sample | Jetchat sample | Now in Android App | Sunflower with Compose | Crane sample | Architecture | . ",
    "url": "/docs/jetpack-compose/ui-architecture/architecture/#learn-more",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/architecture/#learn-more"
  },"73": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/architecture/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/architecture/"
  },"74": {
    "doc": "Best practices for multi-module projects",
    "title": "Best practices for multi-module projects",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/best-practices-for-multi-module-projects/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/best-practices-for-multi-module-projects/"
  },"75": {
    "doc": "Best practices for shortcuts",
    "title": "Best practices for shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/best-practices-for-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/best-practices-for-shortcuts/"
  },"76": {
    "doc": "Best practices",
    "title": "Best practices",
    "content": " ",
    "url": "/docs/best-practices",
    
    "relUrl": "/docs/best-practices"
  },"77": {
    "doc": "Bind layout views to architecture components",
    "title": "Bind layout views to architecture components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/bind-layout-views-to-archtecture-components/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/bind-layout-views-to-archtecture-components/"
  },"78": {
    "doc": "Binding adapters",
    "title": "Binding adapters",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/binding-adapters/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/binding-adapters/"
  },"79": {
    "doc": "BOM to library version mapping",
    "title": "BOM to library version mapping",
    "content": "Bu sayfa surekli olarak guncellenmektedir. Orjinal sayfadan takip edebilirsiniz. ",
    "url": "/docs/jetpack-compose/introduction/bom-to-library-version-mapping/",
    
    "relUrl": "/docs/jetpack-compose/introduction/bom-to-library-version-mapping/"
  },"80": {
    "doc": "Build Your First App",
    "title": "Build Your First App",
    "content": "Bu sayfa interaktif olduğu için direkt link üzerinden inceleyebilirsiniz. ",
    "url": "/docs/app-basics/build-your-first-app/",
    
    "relUrl": "/docs/app-basics/build-your-first-app/"
  },"81": {
    "doc": "Color state list",
    "title": "Color state list",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/color-state-list/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/color-state-list/"
  },"82": {
    "doc": "Common patterns",
    "title": "Common patterns",
    "content": " ",
    "url": "/docs/app-architecture/modularization/common-patterns/",
    
    "relUrl": "/docs/app-architecture/modularization/common-patterns/"
  },"83": {
    "doc": "Communicate with fragments",
    "title": "Communicate with fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/communicate-with-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/communicate-with-fragments/"
  },"84": {
    "doc": "Complex XML resources",
    "title": "Complex XML resources",
    "content": " ",
    "url": "/docs/app-basics/app-resources/complex-xml-resources/",
    
    "relUrl": "/docs/app-basics/app-resources/complex-xml-resources/"
  },"85": {
    "doc": "CompositionLocal",
    "title": "Locally scoped data with CompositionLocal",
    "content": "CompositionLocal, Composition üzerinden örtük olarak veri aktarmaya yarayan bir araçtır. Bu sayfada, CompositionLocal’ın ne olduğunu daha ayrıntılı olarak öğrenecek, kendi CompositionLocal’ınızı nasıl oluşturacağınızı öğrenecek ve CompositionLocal’ın kullanım durumunuz için iyi bir çözüm olup olmadığını anlayacaksınız. ",
    "url": "/docs/jetpack-compose/ui-architecture/composition-local/#locally-scoped-data-with-compositionlocal",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/composition-local/#locally-scoped-data-with-compositionlocal"
  },"86": {
    "doc": "CompositionLocal",
    "title": "Introducing CompositionLocal",
    "content": "Genellikle Compose’da veri aşağı akar UI ağacı üzerinden her bir composable fonksiyona parametre olarak aktarılır. Bu, bir composable’ın bağımlılıklarını açık hale getirir. Ancak bu, renkler veya yazı stilleri gibi çok sık ve yaygın olarak kullanılan veriler için zahmetli olabilir. Aşağıdaki örneğe bakın: . @Composable fun MyApp() { // Tema bilgileri uygulamanın root'una yakın bir yerde tanımlanma eğilimindedir val colors = colors() } // Hiyerarşinin derinliklerinde bazı composablelar @Composable fun SomeTextLabel(labelText: String) { Text( text = labelText, color = colors.onPrimary // ← renklere buradan erişmeniz gerekiyor ) } . Renklerin çoğu composable’a açık bir parametre bağımlılığı olarak aktarılmasına gerek kalmamasını desteklemek için Compose, UI ağacından veri akışı sağlamak için örtük bir yol olarak kullanılabilecek ağaç kapsamına alınmış adlandırılmış nesneler oluşturmanıza olanak tanıyan CompositionLocal özelliğini sunar. CompositionLocal öğeleri genellikle UI ağacının belirli bir düğümünde bir değerle sağlanır. Bu değer, CompositionLocal öğesini composable fonksiyonda bir parametre olarak bildirmeden, composable torunları tarafından kullanılabilir. Anahtar terimler: Bu kılavuzda Composition, UI tree ve UI hierarchy terimlerini kullanıyoruz. Diğer kılavuzlarda birbirleriyle değiştirilebilir şekilde kullanılsalar da farklı anlamlara sahiptirler: Composition, composable fonksiyonların çağrı grafiğinin kaydıdır. UI ağacı veya UI hiyerarşisi, composition işlemi tarafından oluşturulan, güncellenen ve bakımı yapılan LayoutNode ağacıdır. CompositionLocal, Material temasının kaputun altında kullandığı şeydir. MaterialTheme üç CompositionLocal instance’ı (renkler, tipografi ve şekiller) sağlayan bir nesnedir ve bunları daha sonra Composition’ın herhangi bir alt kısmında almanıza olanak tanır. Bunlar özellikle MaterialTheme renkler, şekiller ve tipografi nitelikleri aracılığıyla erişebileceğiniz LocalColors, LocalShapes ve LocalTypography propertyleridir. @Composable fun MyApp() { // Provides a Theme whose values are propagated down its `content` MaterialTheme { // New values for colors, typography, and shapes are available // in MaterialTheme's content lambda. // ... content here ... } } // Some composable deep in the hierarchy of MaterialTheme @Composable fun SomeTextLabel(labelText: String) { Text( text = labelText, // `primary` is obtained from MaterialTheme's // LocalColors CompositionLocal color = MaterialTheme.colors.primary ) } . Bir CompositionLocal instance, Composition’ın bir bölümüne kapsamlandırılmıştır, böylece ağacın farklı seviyelerinde farklı değerler sağlayabilirsiniz. Bir CompositionLocalın [current][(https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal#current()) değeri, Composition’ın o bölümündeki bir ata tarafından sağlanan en yakın değere karşılık gelir. Bir CompositionLocal’a yeni bir değer sağlamak için CompositionLocalProvider‘ı ve CompositionLocal anahtarını bir değerle ilişkilendiren provides infix fonksiyonunu kullanın. CompositionLocalProvider’ın content lambda’sı, CompositionLocal’ın current property’sine erişirken sağlanan değeri alacaktır. Yeni bir değer sağlandığında, Compose CompositionLocal’ı okuyan Composition parçalarını yeniden oluşturur. Bunun bir örneği olarak, LocalContentAlpha CompositionLocal, UI’nin farklı bölümlerini belirginleştirmek veya belirginliğini azaltmak amacıyla metin ve ikonografi için kullanılan preferred content alpha değerini içerir. Aşağıdaki örnekte, CompositionLocalProvider Composition’ın farklı bölümleri için farklı değerler sağlamak üzere kullanılmaktadır. @Composable fun CompositionLocalExample() { MaterialTheme { // MaterialTheme ContentAlpha.high değerini varsayılan olarak ayarlar Column { Text(\"Uses MaterialTheme's provided alpha\") CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) { Text(\"Medium value provided for LocalContentAlpha\") Text(\"This Text also uses the medium value\") CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.disabled) { DescendantExample() } } } } } @Composable fun DescendantExample() { // CompositionLocalProviders ayrıca composable fonksiyonlar arasında da çalışır Text(\"This Text uses the disabled alpha now\") } . Şekil 1. CompositionLocalExample composable önizlemesi. Yukarıdaki tüm örneklerde, CompositionLocal instance’ları Material composable’ları tarafından dahili olarak kullanılmıştır. Bir CompositionLocal’ın geçerli değerine erişmek için current propertysini kullanın. Aşağıdaki örnekte, metni biçimlendirmek için Android uygulamalarında yaygın olarak kullanılan LocalContext CompositionLocal’ın geçerli Context değeri kullanılmıştır: . @Composable fun FruitText(fruitSize: Int) { // LocalContext'in current değerinden `resources` öğesini alır val resources = LocalContext.current.resources val fruitText = remember(resources, fruitSize) { resources.getQuantityString(R.plurals.fruit_title, fruitSize) } Text(text = fruitText) } . Not: CompositionLocal nesneleri veya sabitleri, IDE’de otomatik tamamlama ile daha iyi bulunabilirlik sağlamak için genellikle Local ile ön ek alır. ",
    "url": "/docs/jetpack-compose/ui-architecture/composition-local/#introducing-compositionlocal",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/composition-local/#introducing-compositionlocal"
  },"87": {
    "doc": "CompositionLocal",
    "title": "Creating your own CompositionLocal",
    "content": "CompositionLocal, verilerin Composition boyunca dolaylı olarak aktarılması için bir araçtır. CompositionLocal kullanımı için bir diğer önemli sinyal, parametrenin cross-cutting olduğu ve ara uygulama katmanlarının bunun varlığından haberdar olmaması gerektiğidir, çünkü bu ara katmanların haberdar olması composable’ın faydasını sınırlayacaktır. Örneğin, Android izinleri için sorgulama, kaputun altındaki bir CompositionLocal tarafından sağlanır. Composable bir medya seçici, API’sini değiştirmeden ve medya seçiciyi call edenlerin environment’dan kullanılan bu ek context’ten haberdar olmasını gerektirmeden cihazdaki izin korumalı içeriğe erişmek için yeni fonksiyonlar ekleyebilir. Ancak, CompositionLocal her zaman en iyi çözüm değildir. Bazı dezavantajları olduğu için CompositionLocal’ın aşırı kullanımını önermiyoruz: . CompositionLocal, bir composable’ın davranışı hakkında mantık yürütmeyi zorlaştırır. Örtük bağımlılıklar yarattıklarından, bunları kullanan composable’ları çağıranların her CompositionLocal için bir değerin karşılandığından emin olmaları gerekir. Ayrıca, Composition’ın herhangi bir bölümünde değişebileceğinden, bu bağımlılık için net bir doğruluk kaynağı olmayabilir. Bu nedenle, mevcut değerin nerede sağlandığını görmek için Composition’da gezinmeniz gerektiğinden, bir sorun oluştuğunda uygulamada hata ayıklama yapmak daha zor olabilir. IDE’deki Find usages veya Compose layout inspector gibi araçlar bu sorunu hafifletmek için yeterli bilgi sağlar. Not: CompositionLocal, temel mimari için iyi çalışır ve Jetpack Compose bunu yoğun bir şekilde kullanır. Deciding whether to use CompositionLocal . CompositionLocal’ı kullanım durumunuz için iyi bir çözüm haline getirebilecek belirli koşullar vardır: . Bir CompositionLocal iyi bir varsayılan değere sahip olmalıdır. Varsayılan bir değer yoksa, bir geliştiricinin CompositionLocal için bir değerin sağlanmadığı bir duruma girmesinin son derece zor olduğunu garanti etmelisiniz. Varsayılan bir değer sağlamamak, CompositionLocal’in her zaman açıkça sağlanmasını gerektiren bir composable’ı kullanan testler oluştururken veya önizleme yaparken sorunlara ve hayal kırıklığına neden olabilir. Ağaç kapsamı veya alt hiyerarşi kapsamı olarak düşünülmeyen kavramlar için CompositionLocal kullanmaktan kaçının. Bir CompositionLocal, birkaçı tarafından değil, herhangi bir torun tarafından potansiyel olarak kullanılabildiğinde anlamlıdır. Kullanım durumunuz bu gereksinimleri karşılamıyorsa, bir CompositionLocal oluşturmadan önce Dikkate Alınacak Alternatifler bölümüne göz atın. Belirli bir ekranın ViewModel’ini tutan bir CompositionLocal oluşturmak kötü bir pratiğe örnektir, böylece o ekrandaki tüm composable’lar bazı mantıkları gerçekleştirmek için ViewModel’e bir referans alabilir. Bu kötü bir pratiktir çünkü belirli bir UI ağacının altındaki tüm composable’ların bir ViewModel hakkında bilgi sahibi olması gerekmez. İyi pratik, state’in aşağı ve event’lerin yukarı akması modelini izleyerek composable’lara yalnızca ihtiyaç duydukları bilgileri aktarmaktır. Bu yaklaşım, composable’larınızı daha yeniden kullanılabilir ve daha kolay test edilebilir hale getirecektir. Creating a CompositionLocal . Bir CompositionLocal oluşturmak için iki API vardır: . | compositionLocalOf: Recomposition sırasında sağlanan değerin değiştirilmesi, yalnızca current değerini okuyan içeriği geçersiz kılar. | staticCompositionLocalOf: compositionLocalOf’un aksine, bir staticCompositionLocalOf’un okumaları Compose tarafından izlenmez. Değerin değiştirilmesi, CompositionLocal’ın sağlandığı content lambda’nın tamamının, sadece geçerli değerin Composition’da okunduğu yerler yerine yeniden oluşturulmasına neden olur. | . CompositionLocal’a sağlanan değerin değişme olasılığı çok düşükse veya hiç değişmeyecekse, performans avantajları elde etmek için staticCompositionLocalOf kullanın. Örneğin, bir uygulamanın tasarım sistemi, composable’ların UI komponenti için bir gölge kullanılarak elevate edilmesi konusunda fikir sahibi olabilir. Uygulama için farklı elevate etmelerin UI ağacı boyunca yayılması gerektiğinden, bir CompositionLocal kullanırız. CompositionLocal değeri sistem temasına göre koşullu olarak türetildiğinden, compositionLocalOf API’sini kullanırız: . // LocalElevations.kt dosyasi data class Elevations(val card: Dp = 0.dp, val default: Dp = 0.dp) // Varsayılan bir CompositionLocal global nesnesi tanımlayın // Bu instance'a uygulamadaki tüm composable'lar tarafından erişilebilir val LocalElevations = compositionLocalOf { Elevations() } . Providing values to a CompositionLocal . CompositionLocalProvider composable, değerleri verilen hiyerarşi için CompositionLocal instance’larına bağlar. Bir CompositionLocal’a yeni bir değer sağlamak için, bir CompositionLocal key’ini bir değerle ilişkilendiren provides infix fonksiyonunu aşağıdaki gibi kullanın: . // MyActivity.kt file class MyActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { // Sistem temasına göre yükseklikleri hesaplayın val elevations = if (isSystemInDarkTheme()) { Elevations(card = 1.dp, default = 1.dp) } else { Elevations(card = 0.dp, default = 0.dp) } // Yüksekliği LocalElevations için değer olarak bağlayın CompositionLocalProvider(LocalElevations provides elevations) { // ... Content buraya gidecek ... // Composition'ın bu bölümü LocalElevations.current dosyasına erişirken // `elevations` instance'ını görecektir } } } } . Consuming the CompositionLocal . CompositionLocal.current, o CompositionLocal için bir değer sağlayan en yakın CompositionLocalProvider tarafından sağlanan değeri döndürür: . @Composable fun SomeComposable() { // Composition'ın bu bölümündeki mevcut Elevations değerini almak için // global olarak tanımlanmış LocalElevations değişkenine erişin Card(elevation = LocalElevations.current.card) { // Content } } . ",
    "url": "/docs/jetpack-compose/ui-architecture/composition-local/#creating-your-own-compositionlocal",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/composition-local/#creating-your-own-compositionlocal"
  },"88": {
    "doc": "CompositionLocal",
    "title": "Alternatives to consider",
    "content": "CompositionLocal bazı kullanım durumları için aşırı bir çözüm olabilir. Kullanım durumunuz CompositionLocal kullanıp kullanmamaya karar verme bölümünde belirtilen ölçütleri karşılamıyorsa, kullanım durumunuz için başka bir çözüm daha uygun olabilir. Pass explicit parameters . Composable’ın bağımlılıkları hakkında açık olmak iyi bir alışkanlıktır. Composable’lara yalnızca ihtiyaç duydukları bilgileri aktarmanızı öneririz. Composable’ların decoupling ve yeniden kullanımını teşvik etmek için, her composable mümkün olan en az miktarda bilgiyi tutmalıdır. @Composable fun MyComposable(myViewModel: MyViewModel = viewModel()) { // ... MyDescendant(myViewModel.data) } // Tüm nesneyi geçirmeyin! Sadece torunun ihtiyacı olanı. // Ayrıca, bir CompositionLocal kullanarak ViewModel'i örtük bir bağımlılık olarak geçirmeyin. @Composable fun MyDescendant(myViewModel: MyViewModel) { /* ... */ } // Sadece torunun ihtiyacı olanı gecirin @Composable fun MyDescendant(data: DataToDisplay) { // Verileri görüntüle } . Inversion of control . Gereksiz bağımlılıkları bir composable’a geçirmekten kaçınmanın bir başka yolu da inversion of control’dür. Alt öğenin bazı logicleri yürütmek için bir bağımlılık alması yerine, üst öğe bunu yapar. Bir alt öğenin bazı verileri yüklemek için isteği tetiklemesi gereken aşağıdaki örneğe bakın: . @Composable fun MyComposable(myViewModel: MyViewModel = viewModel()) { // ... MyDescendant(myViewModel) } @Composable fun MyDescendant(myViewModel: MyViewModel) { Button(onClick = { myViewModel.loadData() }) { Text(\"Load data\") } } . Duruma bağlı olarak, MyDescendant çok fazla sorumluluğa sahip olabilir. Ayrıca, MyViewModel’i bir bağımlılık olarak geçirmek, MyDescendant’ı artık birbirine bağlı oldukları için daha az yeniden kullanılabilir hale getirir. Bağımlılığı toruna geçirmeyen ve logic’in yürütülmesinden atayı sorumlu kılan inversion of control ilkelerini kullanan alternatifi düşünün: . @Composable fun MyComposable(myViewModel: MyViewModel = viewModel()) { // ... ReusableLoadDataButton( onLoadClick = { myViewModel.loadData() } ) } @Composable fun ReusableLoadDataButton(onLoadClick: () -&gt; Unit) { Button(onClick = onLoadClick) { Text(\"Load data\") } } . Bu yaklaşım, çocuğu yakın atalarından decouple ettigi için bazı kullanım durumları için daha uygun olabilir. Ata composablelar, daha esnek alt seviye composablelara sahip olmak için daha karmaşık hale gelme eğilimindedir. Benzer şekilde, @Composable content lambda’lar da aynı faydaları elde etmek için aynı şekilde kullanılabilir: . @Composable fun MyComposable(myViewModel: MyViewModel = viewModel()) { // ... ReusablePartOfTheScreen( content = { Button( onClick = { myViewModel.loadData() } ) { Text(\"Confirm\") } } ) } @Composable fun ReusablePartOfTheScreen(content: @Composable () -&gt; Unit) { Column { // ... content() } } . ",
    "url": "/docs/jetpack-compose/ui-architecture/composition-local/#alternatives-to-consider",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/composition-local/#alternatives-to-consider"
  },"89": {
    "doc": "CompositionLocal",
    "title": "CompositionLocal",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/composition-local/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/composition-local/"
  },"90": {
    "doc": "Conditional navigation",
    "title": "Conditional navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/conditional-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/conditional-navigation/"
  },"91": {
    "doc": "Core topics",
    "title": "Core topics",
    "content": " ",
    "url": "/docs/core-topics",
    
    "relUrl": "/docs/core-topics"
  },"92": {
    "doc": "Create a deep link for a destination",
    "title": "Create a deep link for a destination",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/create-a-deep-link-for-a-destination/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/create-a-deep-link-for-a-destination/"
  },"93": {
    "doc": "Create a fragment",
    "title": "Create a fragment",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/create-a-fragment/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/create-a-fragment/"
  },"94": {
    "doc": "Create app links for instant apps",
    "title": "Create app links for instant apps",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/create-app-links-for-instant-apps/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/create-app-links-for-instant-apps/"
  },"95": {
    "doc": "Create a destination",
    "title": "Create a destination",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/create-destination/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/create-destination/"
  },"96": {
    "doc": "Create shortcuts",
    "title": "Create shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/create-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/create-shortcuts/"
  },"97": {
    "doc": "Create swipe views with tabs using ViewPager",
    "title": "Create swipe views with tabs using ViewPager",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager/",
    
    "relUrl": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager/"
  },"98": {
    "doc": "Create swipe views with tabs using ViewPager2",
    "title": "Create swipe views with tabs using ViewPager2",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager2/",
    
    "relUrl": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager2/"
  },"99": {
    "doc": "Create ViewModels with dependencies",
    "title": "Create ViewModels with dependencies",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/create-viewmodels-with-dependencies/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/create-viewmodels-with-dependencies/"
  },"100": {
    "doc": "Custom back navigation",
    "title": "Custom back navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/custom-back-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/custom-back-navigation/"
  },"101": {
    "doc": "Custom layouts",
    "title": "Custom layouts",
    "content": "Custom layouts and graphics in Compose . Compose’da UI öğeleri, çağrıldıklarında bir UI parçası yayan(emit) ve daha sonra ekranda işlenen bir UI ağacına eklenen composable fonksiyonlarla temsil edilir. Her UI öğesinin bir ebeveyni ve potansiyel olarak birçok çocuğu vardır. Her öğe aynı zamanda (x, y) konumu ve genişlik ve yükseklik olarak belirtilen bir boyut olarak ebeveyninin içinde yer alır. Ebeveynler, çocuk elemanları için kısıtlamaları tanımlar. Bir elemandan bu kısıtlamalar dahilinde boyutunu tanımlaması istenir. Kısıtlamalar bir elemanın minimum ve maksimum genişlik ve yüksekliğini sınırlar. Bir öğenin alt öğeleri varsa, boyutunu belirlemeye yardımcı olması için her bir alt öğeyi ölçebilir. Bir öğe kendi boyutunu belirleyip bildirdikten sonra, Custom layout olusturma bölümünde ayrıntılı olarak açıklandığı gibi, alt öğelerinin kendisine göre nasıl yerleştirileceğini tanımlama fırsatına sahip olur. UI ağacındaki her bir node’un yerleştirilmesi üç adımlı bir süreçtir. Her node şunları yapmalıdır: . | 1- Tüm çocukları ölçün | 2- Kendi boyutuna karar ver | 3- Çocuklarını yerleştir | . Not: Compose UI, çoklu geçiş ölçümüne izin vermez. Bu, bir layout öğesinin farklı ölçüm konfigürasyonlarını denemek için alt öğelerinden herhangi birini birden fazla kez ölçemeyeceği anlamına gelir. Scope kullanımı, alt öğelerinizi ne zaman ölçebileceğinizi ve yerleştirebileceğinizi tanımlar. Bir layout’un ölçümü yalnızca ölçüm ve layout geçişleri sırasında yapılabilir ve bir alt öğe yalnızca layout geçişleri sırasında (ve yalnızca ölçüldükten sonra) yerleştirilebilir. MeasureScope ve PlacementScope gibi Compose scope’ları nedeniyle, bu derleme zamanında zorunlu kılınır. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/"
  },"102": {
    "doc": "Custom layouts",
    "title": "Use the layout modifier",
    "content": "Advanced layout concepts - MAD Skills . Bir öğenin nasıl ölçüldüğünü ve düzenlendiğini değiştirmek için layout modifier’ı kullanabilirsiniz. Layout bir lambda’dır; parametreleri, measurable olarak geçirilen ölçebileceğiniz öğeyi ve constraints olarak geçirilen composable’ın mevcut kısıtlamalarını içerir. Custom bir layout modifier aşağıdaki gibi görünebilir: . fun Modifier.customLayoutModifier() = layout { measurable, constraints -&gt; // ... } . Ekranda bir Metin görüntüleyelim ve metnin ilk satırının üstten taban çizgisine olan mesafesini kontrol edelim. Bu tam olarak paddingFromBaseline modifier’ının yaptığı şeydir, onu burada örnek olarak uyguluyoruz. Bunu yapmak için, composable’ı ekrana manuel olarak yerleştirmek üzere layout modifier’ı kullanın. İşte Metin top padding’inin 24.dp olarak ayarlandığı istenen davranış: . İşte bu mesafeyi oluşturmak için gereken kod: . fun Modifier.firstBaselineToTop( firstBaselineToTop: Dp ) = layout { measurable, constraints -&gt; // Measure the composable val placeable = measurable.measure(constraints) // Check the composable has a first baseline check(placeable[FirstBaseline] != AlignmentLine.Unspecified) val firstBaseline = placeable[FirstBaseline] // Height of the composable with padding - first baseline val placeableY = firstBaselineToTop.roundToPx() - firstBaseline val height = placeable.height + placeableY layout(placeable.width, height) { // Where the composable gets placed placeable.placeRelative(0, placeableY) } } . İşte bu kodda neler olup bittiği: . | 1- Measurable lambda parametresinde, measurable.measure(constraints) öğesini çağırarak measurable parametresinin temsil ettiği Metni ölçersiniz. | 2- Sarılmış öğeleri yerleştirmek için kullanılan bir lambda da veren layout(width, height) metodunu çağırarak composable’ın boyutunu belirtirsiniz. Bu durumda, son taban çizgisi ile eklenen top padding arasındaki yüksekliktir. | 3- Placeable.place(x, y) metodunu çağırarak sarılmış elemanları ekranda konumlandırırsınız. Sarılı öğeler yerleştirilmezse görünür olmazlar. Y konumu, metnin ilk taban çizgisinin konumu olan top padding’e karşılık gelir. | . Bunun beklendiği gibi çalıştığını doğrulamak için, bu modifieri bir Text üzerinde kullanın: . @Preview @Composable fun TextWithPaddingToBaselinePreview() { MyApplicationTheme { Text(\"Hi there!\", Modifier.firstBaselineToTop(32.dp)) } } @Preview @Composable fun TextWithNormalPaddingPreview() { MyApplicationTheme { Text(\"Hi there!\", Modifier.padding(top = 32.dp)) } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#use-the-layout-modifier",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#use-the-layout-modifier"
  },"103": {
    "doc": "Custom layouts",
    "title": "Create custom layouts",
    "content": "@Composable fun MyBasicColumn( modifier: Modifier = Modifier, content: @Composable () -&gt; Unit ) { Layout( modifier = modifier, content = content ) { measurables, constraints -&gt; // measure and position children given constraints logic here // ... } } . @Composable fun MyBasicColumn( modifier: Modifier = Modifier, content: @Composable () -&gt; Unit ) { Layout( modifier = modifier, content = content ) { measurables, constraints -&gt; // Don't constrain child views further, measure them with given constraints // List of measured children val placeables = measurables.map { measurable -&gt; // Measure each children measurable.measure(constraints) } // Set the size of the layout as big as it can layout(constraints.maxWidth, constraints.maxHeight) { // Track the y co-ord we have placed children up to var yPosition = 0 // Place children in the parent layout placeables.forEach { placeable -&gt; // Position item on the screen placeable.placeRelative(x = 0, y = yPosition) // Record the y co-ord placed up to yPosition += placeable.height } } } } . @Composable fun CallingComposable(modifier: Modifier = Modifier) { MyBasicColumn(modifier.padding(8.dp)) { Text(\"MyBasicColumn\") Text(\"places items\") Text(\"vertically.\") Text(\"We've done it by hand!\") } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#create-custom-layouts",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#create-custom-layouts"
  },"104": {
    "doc": "Custom layouts",
    "title": "Layout direction",
    "content": "LocalLayoutDirection composition local’i değiştirerek bir composable’ın yerleşim yönünü değiştirin. Composable’ları ekrana manuel olarak yerleştiriyorsanız LayoutDirection, layout modifier’ın veya Layout composable’ın LayoutScope’unun bir parçasıdır. LayoutDirection kullanırken, composablelari place kullanarak yerleştirin. placeRelative metodunun aksine, place yerleşim yönüne göre değişmez (soldan sağa veya sağdan sola). ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#layout-direction",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#layout-direction"
  },"105": {
    "doc": "Custom layouts",
    "title": "Custom layouts in action",
    "content": "Compose’daki temel layoutlar bölümünde layoutlar ve modifier’lar hakkında daha fazla bilgi edinin ve Custom Layouts oluşturan Compose örneklerinde custom layoutları uygulamalı olarak görün. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#custom-layouts-in-action",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#custom-layouts-in-action"
  },"106": {
    "doc": "Custom layouts",
    "title": "Learn more",
    "content": "Compose’daki custom layout’lar hakkında daha fazla bilgi edinmek için aşağıdaki ek kaynaklara başvurun. Videos . | A deep dive into Jetpack Compose Layouts | . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#learn-more",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/custom-layouts/#learn-more"
  },"107": {
    "doc": "Dagger basics",
    "title": "Dagger basics",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/dagger-basics/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/dagger-basics/"
  },"108": {
    "doc": "Dagger",
    "title": "Dagger",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/dagger/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/dagger/"
  },"109": {
    "doc": "Data binding library",
    "title": "Data binding library",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/data-binding-library/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/data-binding-library/"
  },"110": {
    "doc": "Data layer libraries",
    "title": "Data layer libraries",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/data-layer-libraries/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/data-layer-libraries/"
  },"111": {
    "doc": "Data layer",
    "title": "Data layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/data-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/data-layer/"
  },"112": {
    "doc": "Datastore",
    "title": "Datastore",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/datastore/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/datastore/"
  },"113": {
    "doc": "Debug your fragments",
    "title": "Debug your fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/debug-your-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/debug-your-fragments/"
  },"114": {
    "doc": "Dependency Injection",
    "title": "Dependency Injection",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dependency-injection/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dependency-injection/"
  },"115": {
    "doc": "Dependency injection with Hilt",
    "title": "Dependency injection with Hilt",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dependency-injetion-with-hilt/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dependency-injetion-with-hilt/"
  },"116": {
    "doc": "Design for different form factors",
    "title": "Design for different form factors",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/design-for-different-form-factors/",
    
    "relUrl": "/docs/app-architecture/app-navigation/design-for-different-form-factors/"
  },"117": {
    "doc": "Design navigation graphs",
    "title": "Design navigation graphs",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/design-navigation-graphs/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/design-navigation-graphs/"
  },"118": {
    "doc": "Develop your app's layout",
    "title": "Develop your app's layout",
    "content": " ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/develop-your-apps-layout/",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/develop-your-apps-layout/"
  },"119": {
    "doc": "Display paged lists",
    "title": "Display paged lists",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/display-paged-lists/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/display-paged-lists/"
  },"120": {
    "doc": "Displaying dialogs with DialogFragment",
    "title": "Displaying dialogs with DialogFragment",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/displaying-dialogs-with-dialogfragment/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/displaying-dialogs-with-dialogfragment/"
  },"121": {
    "doc": "Documentation",
    "title": "Get started with Jetpack Compose",
    "content": "Jetpack Compose, native Android kullanıcı arayüzü oluşturmak için modern bir araç setidir. Compose kullanımı hakkında en güncel bilgileri burada bulabilirsiniz. Overview (Genel Bakış): Compose geliştiricileri için mevcut tüm kaynakları görün. Tutorial: Basit bir kullanıcı arayüzü oluşturmak için Compose’u kullanmaya başlayın. ",
    "url": "/docs/jetpack-compose/introduction/documentation/#get-started-with-jetpack-compose",
    
    "relUrl": "/docs/jetpack-compose/introduction/documentation/#get-started-with-jetpack-compose"
  },"122": {
    "doc": "Documentation",
    "title": "Foundation",
    "content": "Thinking in Compose: Compose’un deklaratif yaklaşımının geçmişte kullanmış olabileceğiniz view tabanlı yaklaşımdan nasıl farklı olduğunu ve Compose ile çalışmak için nasıl bir zihinsel model oluşturacağınızı öğrenin. Managing state: Compose uygulamanızda state ayarlama ve kullanma hakkında bilgi edinin. Lifecycle of composables: Bir composable’ın yaşam döngüsü ve Compose’un yeniden çizilmesi gerekip gerekmediğine nasıl karar verdiği hakkında bilgi edinin. Modifiers: Composable’larınızı güçlendirmek veya süslemek için modifier’ları nasıl kullanacağınızı öğrenin. Side-effects in Compose: Side-effectleri yönetmenin en iyi yollarını öğrenin. Jetpack Compose Phases: Compose’un kullanıcı arayüzünüzü oluşturmak için geçtiği adımları ve bu bilgileri verimli kod yazmak için nasıl kullanacağınızı öğrenin Architectural layering: Jetpack Compose’u oluşturan mimari katmanlar ve tasarımına yön veren temel ilkeler hakkında bilgi edinin. Performance: Uygulamanızın performansına zarar verebilecek yaygın programlama tuzaklarından nasıl kaçınacağınızı öğrenin. Semantics in Compose: Kullanıcı arayüzünüzü erişilebilirlik hizmetleri ve test framework’ü tarafından kullanılabilecek şekilde düzenleyen Semantics ağacı hakkında bilgi edinin. Locally scoped data with CompositionLocal: Composition üzerinden veri aktarmak için CompositionLocal’ı nasıl kullanacağınızı öğrenin. ",
    "url": "/docs/jetpack-compose/introduction/documentation/#foundation",
    
    "relUrl": "/docs/jetpack-compose/introduction/documentation/#foundation"
  },"123": {
    "doc": "Documentation",
    "title": "Development environment",
    "content": "Android Studio with Compose: Compose’u kullanmak için geliştirme ortamınızı ayarlayın. Tooling for Compose: Android Studio’nun Compose’u destekleyen yeni özellikleri hakkında bilgi edinin. Kotlin for Compose: Kotlin’e özgü bazı deyimlerin Compose ile nasıl çalıştığını öğrenin. Developer ergonomics: Compose’a geçişin uygulamanızın APK boyutunu ve çalışma zamanı performansını nasıl etkileyebileceğini öğrenin. Bill of Materials: Yalnızca BOM sürümünü belirterek tüm Compose bağımlılıklarınızı yönetin. ",
    "url": "/docs/jetpack-compose/introduction/documentation/#development-environment",
    
    "relUrl": "/docs/jetpack-compose/introduction/documentation/#development-environment"
  },"124": {
    "doc": "Documentation",
    "title": "Design",
    "content": ". | Layouts: Compose’un native layout component’leri hakkında bilgi edinin ve kendi layout’unuzu nasıl tasarlayacağınızı öğrenin. | Layout basics: Basit bir uygulama kullanıcı arayüzü için yapı taşları hakkında bilgi edinin. | Material Components and layouts: Compose’daki Materyal komponentleri ve layoutları hakkında bilgi edinin. | Custom layouts: Uygulamanızın layout’unun kontrolünü nasıl ele alacağınızı ve kendinize özel bir layout’u nasıl tasarlayacağınızı öğrenin. | Build adaptive layouts: Farklı ekran boyutlarına, yönlere ve form faktörlerine uyum sağlayan layoutlar oluşturmak için Compose’u nasıl kullanacağınızı öğrenin. | Alignment lines: UI öğelerinizi hassas bir şekilde hizalamak ve konumlandırmak için özel hizalama çizgilerinin nasıl oluşturulacağını öğrenin. | Intrinsic measurements: Compose, UI öğelerini her geçişte yalnızca bir kez ölçmenize izin verdiğinden, bu sayfada alt öğeler hakkında ölçüm yapmadan önce nasıl bilgi sorgulanacağı açıklanmaktadır. | ConstraintLayout: Compose UI’nizde ConstraintLayout’u nasıl kullanacağınızı öğrenin. | . | Design Systems: Bir tasarım sistemini nasıl uygulayacağınızı ve uygulamanıza nasıl tutarlı bir görünüm ve his kazandıracağınızı öğrenin. | Material Design 3: Compose’un Material Design 3 uygulaması ile Material You’yu nasıl uygulayacağınızı öğrenin. | Migrating from Material 2 to Material 3: Compose’da uygulamanızı Material Design 2’den Material Design 3’e nasıl geçireceğinizi öğrenin. | Material Design 2: Compose’un Material Design 2 uygulamasını ürününüzün markasına uyacak şekilde nasıl özelleştireceğinizi öğrenin. | Custom design systems: Compose’da özel bir tasarım sistemini nasıl uygulayacağınızı ve mevcut Material Design composable’larını buna nasıl uyarlayacağınızı öğrenin. | Anatomy of a theme: MaterialTheme ve özel tasarım sistemleri tarafından kullanılan alt düzey yapılar ve API’ler hakkında bilgi edinin. | . | Lists and grids: Veri listelerini ve gridlerini yönetmek ve görüntülemek için Compose’un bazı seçenekleri hakkında bilgi edinin. | Text: Metni görüntülemek ve düzenlemek için Compose’un ana seçenekleri hakkında bilgi edinin. | Graphics: Compose’un özel grafikler oluşturma ve bunlarla çalışma özellikleri hakkında bilgi edinin. | Animation: UI öğelerinizi canlandırmak için Compose’un farklı seçenekleri hakkında bilgi edinin. | Gestures: Kullanıcı hareketlerini algılayan ve bunlarla etkileşime giren bir Compose kullanıcı arayüzünün nasıl oluşturulacağını öğrenin. | Handling user interactions: Bileşenlerinizin kullanıcı eylemlerine nasıl yanıt vereceğini özelleştirebilmeniz için Compose’un düşük seviyeli girdileri daha yüksek seviyeli etkileşimlere nasıl dönüştürdüğünü öğrenin. | . ",
    "url": "/docs/jetpack-compose/introduction/documentation/#design",
    
    "relUrl": "/docs/jetpack-compose/introduction/documentation/#design"
  },"125": {
    "doc": "Documentation",
    "title": "Adopting Compose",
    "content": ". | Migrate existing View-based apps: Mevcut View tabanlı uygulamanızı Compose’a nasıl geçireceğinizi öğrenin. | Migration strategy: Compose’u kod tabanınıza güvenli ve aşamalı bir şekilde ekleme stratejisini öğrenin. | Interoperability APIs: Compose’u View tabanlı kullanıcı arayüzü ile birleştirmenize yardımcı olacak Compose API’leri hakkında bilgi edinin. | Other considerations: View tabanlı uygulamanızı Compose’a geçirirken tema oluşturma, mimari ve test gibi diğer hususlar hakkında bilgi edinin. | . | Compose and other libraries: Compose içeriğinizde view tabanlı kütüphaneleri nasıl kullanacağınızı öğrenin. | Compose architecture: Compose’da tek yönlü akış modelinin nasıl uygulanacağını, event’lerin ve state holder’ların nasıl uygulanacağını ve Compose’da ViewModel ile nasıl çalışılacağını öğrenin. | Navigation: Navigation component’i Compose UI’niz ile entegre etmek için NavController’ı nasıl kullanacağınızı öğrenin. | Navigation for responsive UIs: Uygulamanızın navigasyonunu farklı ekran boyutlarına, yönlere ve form faktörlerine uyum sağlayacak şekilde nasıl tasarlayacağınızı öğrenin. | . | Resources: Compose kodunuzda uygulamanızın kaynaklarıyla nasıl çalışacağınızı öğrenin. | Accessibility: Compose kullanıcı arayüzünüzü farklı erişilebilirlik gereksinimleri olan kullanıcılar için nasıl uygun hale getireceğinizi öğrenin. | Testing: Compose kodunuzu test etme hakkında bilgi edinin. | Testing cheat sheet: Yararlı Compose test API’lerinin hızlı bir referansı. | . | . ",
    "url": "/docs/jetpack-compose/introduction/documentation/#adopting-compose",
    
    "relUrl": "/docs/jetpack-compose/introduction/documentation/#adopting-compose"
  },"126": {
    "doc": "Documentation",
    "title": "Additional resources",
    "content": ". | Get setup | Curated learning pathway | Compose API guidelines | API reference | Codelabs | Sample apps | Videos | . ",
    "url": "/docs/jetpack-compose/introduction/documentation/#additional-resources",
    
    "relUrl": "/docs/jetpack-compose/introduction/documentation/#additional-resources"
  },"127": {
    "doc": "Documentation",
    "title": "Documentation",
    "content": " ",
    "url": "/docs/jetpack-compose/introduction/documentation/",
    
    "relUrl": "/docs/jetpack-compose/introduction/documentation/"
  },"128": {
    "doc": "Domain layer",
    "title": "Domain layer",
    "content": "Domain katmanı, UI katmanı ile data katmanı arasında yer alan isteğe bağlı bir katmandır. Domain katmanı, karmaşık business logic’in veya birden fazla ViewModel tarafından yeniden kullanılan basit business logic’in enkapsüle edilmesinden sorumludur. Bu katman isteğe bağlıdır çünkü tüm uygulamalar bu gereksinimlere sahip olmayacaktır. Yalnızca gerektiğinde kullanmalısınız - örneğin, karmaşıklığı handle etmek veya yeniden kullanılabilirliği kolaylaştırmak için. Domain katmanı aşağıdaki faydaları sağlar: . | Kod tekrarını önler. | Domain katmanı sınıflarını kullanan sınıflarda okunabilirliği artırır. | Uygulamanın test edilebilirliğini artırır. | Sorumlulukları bölmenize izin vererek büyük sınıfları önler. | . Bu sınıfları basit ve hafif tutmak için, her kullanım senaryosu yalnızca tek bir fonksiyonellik üzerinde sorumluluk sahibi olmalı ve mutable veri içermemelidir. Bunun yerine mutable verileri UI veya data katmanlarınızda ele almalısınız. Not: Bu sayfadaki öneriler ve best practiceler, ölçeklenmelerini sağlamak, kaliteyi ve sağlamlığı artırmak ve test edilmelerini kolaylaştırmak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Architecture: The Domain Layer - MAD Skills . Naming conventions in this guide . Bu kılavuzda, use case’ler sorumlu oldukları tek bir eylemden sonra adlandırılır. Kurallar aşağıdaki gibidir: . şimdiki zamanda fiil + isim/ne (isteğe bağlı) + UseCase. Örneğin: FormatDateUseCase, LogOutUserUseCase, GetLatestNewsWithAuthorsUseCase veya MakeLoginRequestUseCase. Dependencies . Tipik bir uygulama mimarisinde, use case sınıfları UI katmanındaki ViewModel’ler ile data katmanındaki repository’ler arasında yer alır. Bu, use case sınıflarının genellikle repository sınıflarına bağlı olduğu ve UI katmanı ile repository’lerin yaptığı gibi iletişim kurduğu anlamına gelir - ya callback’ler (Java için) ya da coroutine’ler (Kotlin için) kullanarak. Bu konuda daha fazla bilgi edinmek için data layer sayfasına bakın. Örneğin, uygulamanızda bir haber repository’sinden ve bir yazar repository’sinden veri alan ve bunları birleştiren bir use case sınıfınız olabilir: . class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository ) { /* ... */ } . Use case’ler yeniden kullanılabilir lojik içerdiğinden, diğer use case’ler tarafından da kullanılabilirler. Domain katmanında birden fazla use case seviyesi olması normaldir. Örneğin, aşağıdaki örnekte tanımlanan use case, UI katmanındaki birden fazla sınıfın ekranda uygun mesajı görüntülemek için saat dilimlerine güvenmesi durumunda FormatDateUseCase use case’ini kullanabilir: . class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository, private val formatDateUseCase: FormatDateUseCase ) { /* ... */ } . Example dependency graph for a use case that depends on other use cases . Call use cases in Kotlin . Kotlin’de, invoke() fonksiyonunu operatör modifier ile tanımlayarak use case sınıf instance’larını fonksiyon olarak çağrılabilir hale getirebilirsiniz. Aşağıdaki örneğe bakın: . class FormatDateUseCase(userRepository: UserRepository) { private val formatter = SimpleDateFormat( userRepository.getPreferredDateFormat(), userRepository.getPreferredLocale() ) operator fun invoke(date: Date): String { return formatter.format(date) } } . Bu örnekte, FormatDateUseCase’deki invoke() metodu, sınıfın instance’larını fonksiyonlarmış gibi çağırmanıza olanak tanır. invoke() metodu belirli bir imza ile sınırlandırılmamıştır; herhangi bir sayıda parametre alabilir ve herhangi bir tip döndürebilir. Ayrıca invoke() metodunu sınıfınızda farklı imzalarla overload edebilirsiniz. Yukarıdaki örnekteki use case’i aşağıdaki gibi çağırırsınız: . class MyViewModel(formatDateUseCase: FormatDateUseCase) : ViewModel() { init { val today = Calendar.getInstance() val todaysDate = formatDateUseCase(today) /* ... */ } } . invoke() operatörü hakkında daha fazla bilgi edinmek için Kotlin dokümanlarına bakın. Lifecycle . Use Case’lerin kendi yaşam döngüleri yoktur. Bunun yerine, onları kullanan sınıfa göre scopelandırılırlar. Bu, use case’leri UI katmanındaki sınıflardan, hizmetlerden veya Application sınıfının kendisinden çağırabileceğiniz anlamına gelir. Use case’ler mutable veriler içermemesi gerektiğinden, bir use case sınıfını bağımlılık olarak her ilettiğinizde bu sınıfın yeni bir instance’ını oluşturmanız gerekir. Threading . Domain katmanındaki Use Case’ler main-safe olmalıdır; başka bir deyişle, main thread’den çağrılmaları güvenli olmalıdır. Use case sınıfları uzun süren bloklama işlemleri gerçekleştiriyorsa, bu lojiği uygun iş parçacığına taşımaktan sorumludurlar. Ancak bunu yapmadan önce, bu engelleme işlemlerinin hiyerarşinin diğer katmanlarına yerleştirilmesinin daha iyi olup olmayacağını kontrol edin. Tipik olarak, karmaşık hesaplamalar yeniden kullanılabilirliği veya önbelleğe almayı teşvik etmek için data katmanında gerçekleşir. Örneğin, büyük bir liste üzerindeki yoğun kaynak gerektiren bir işlem, sonucun uygulamanın birden fazla ekranında yeniden kullanılabilmesi için önbelleğe alınması gerekiyorsa, domain katmanından ziyade data katmanına daha iyi yerleştirilir. Aşağıdaki örnekte, çalışmasını bir background thread üzerinde gerçekleştiren bir use case gösterilmektedir: . class MyUseCase( private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default ) { suspend operator fun invoke(...) = withContext(defaultDispatcher) { // Long-running blocking operations happen on a background thread. } } . Common Tasks . Bu bölümde, yaygın domain katmanı görevlerinin nasıl gerçekleştirileceği açıklanmaktadır. Reusable simple business logic UI katmanında bulunan tekrarlanabilir business logic’i bir use case sınıfında encapsulate etmelisiniz. Bu, logic’in kullanıldığı her yerde herhangi bir değişikliği gerçekleştirmeyi kolaylaştırır. Ayrıca lojiği izole bir şekilde test etmenize de olanak tanır. Daha önce açıklanan FormatDateUseCase örneğini düşünün. Tarih biçimlendirmeyle ilgili iş gereksinimleriniz gelecekte değişirse, kodu yalnızca tek bir merkezi yerde değiştirmeniz gerekir. Not: Bazı durumlarda, use case'lerde bulunabilecek lojik, bunun yerine Util sınıflarındaki statik metotların bir parçası olabilir. Ancak, Util sınıflarını bulmak genellikle zor olduğundan ve işlevlerini keşfetmek zor olduğundan, ikincisi önerilmez. Ayrıca, use case'ler temel sınıflarda thread ve error handling gibi ortak işlevleri paylaşabilir ve bu da ölçek olarak daha büyük ekiplere fayda sağlayabilir. Combine repositories . Bir haber uygulamasında, sırasıyla haber ve yazar veri işlemlerini gerçekleştiren NewsRepository ve AuthorsRepository sınıflarına sahip olabilirsiniz. NewsRepository’nin sunduğu Article sınıfı yalnızca yazarın adını içerir, ancak ekranda yazar hakkında daha fazla bilgi görüntülemek istersiniz. Yazar bilgileri AuthorsRepository’den elde edilebilir. Logic birden fazla repository içerdiğinden ve karmaşık hale gelebileceğinden, logic’i ViewModel’den soyutlamak ve daha okunabilir hale getirmek için bir GetLatestNewsWithAuthorsUseCase sınıfı oluşturursunuz. Bu aynı zamanda logic’in tek başına test edilmesini ve uygulamanın farklı bölümlerinde yeniden kullanılabilir olmasını kolaylaştırır. /** * This use case fetches the latest news and the associated author. */ class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository, private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default ) { suspend operator fun invoke(): List&lt;ArticleWithAuthor&gt; = withContext(defaultDispatcher) { val news = newsRepository.fetchLatestNews() val result: MutableList&lt;ArticleWithAuthor&gt; = mutableListOf() // This is not parallelized, the use case is linearly slow. for (article in news) { // The repository exposes suspend functions val author = authorsRepository.getAuthor(article.authorId) result.add(ArticleWithAuthor(article, author)) } result } } . Logic, haber listesindeki tüm öğeleri mapler; bu nedenle data katmanı main-safe olsa da, bu iş main thread’i bloke etmemelidir çünkü kaç öğeyi process edeceğini bilemezsiniz. Bu nedenle use case, varsayılan dispatcher’ı kullanarak işi bir background thread’e taşır. Not: Room kütüphanesi, bir veritabanındaki farklı entityler arasındaki ilişkileri sorgulamanızı sağlar. Veritabanı source of truth ise, tüm bu işi sizin için yapan bir query oluşturabilirsiniz. Bu durumda, bir use case yerine NewsWithAuthorsRepository gibi bir repository sınıfı oluşturmak daha iyidir. Other consumers . UI katmanının yanı sıra, domain katmanı servisler ve Application sınıfı gibi diğer sınıflar tarafından da yeniden kullanılabilir. Ayrıca, TV veya Wear gibi diğer platformlar mobil uygulama ile kod tabanını paylaşıyorsa, UI katmanları da domain katmanının yukarıda bahsedilen tüm avantajlarını elde etmek için use case’leri yeniden kullanabilir. Data layer access restriction . Domain katmanını implemente ederken göz önünde bulundurmanız gereken bir diğer husus da UI katmanından data katmanına doğrudan erişime izin vermeniz ya da her şeyi domain katmanı üzerinden yapmaya zorlamanız gerekip gerekmediğidir. Bu kısıtlamayı yapmanın bir avantajı, örneğin data katmanına her erişim isteğinde analitik loglama yapıyorsanız, UI’nizin domain katmanı logic’ini bypass etmesini engellemesidir. Bununla birlikte, potansiyel olarak önemli dezavantajı, sizi data katmanına basit fonksiyon çağrıları olsa bile use case’ler eklemeye zorlamasıdır, bu da çok az fayda için karmaşıklık yaratabilir. İyi bir yaklaşım, use case’leri yalnızca gerektiğinde eklemektir. UI katmanınızın verilere neredeyse yalnızca use case’ler aracılığıyla eriştiğini fark ederseniz, verilere yalnızca bu şekilde erişmek mantıklı olabilir. Nihayetinde data katmanına erişimi kısıtlama kararı, kod tabanınıza ve katı kuralları mı yoksa daha esnek bir yaklaşımı mı tercih ettiğinize bağlıdır. Testing Domain katmanını test ederken genel test kılavuzu geçerlidir. Diğer UI testleri için geliştiriciler genellikle sahte repository’ler kullanır ve domain katmanını test ederken de sahte repository’ler kullanmak iyi bir yöntemdir. Sample . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/domain-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/domain-layer/"
  },"129": {
    "doc": "Drawable",
    "title": "Drawable",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/drawable/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/drawable/"
  },"130": {
    "doc": "Enabling links to app content",
    "title": "Enabling links to app content",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/enabling-links-to-app-content/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/enabling-links-to-app-content/"
  },"131": {
    "doc": "Flow layouts",
    "title": "Flow layouts in Compose",
    "content": "Beta: FlowRow ve FlowColumn test aşamasındadır. Bu doküman API’nin beta sürümü içindir. Herhangi bir geri bildirimi issue tracker‘a gönderin. FlowRow ve FlowColumn, Row ve Column’a benzeyen ancak container’da yer kalmadığında öğelerin bir sonraki satıra geçmesi bakımından farklılık gösteren composable’lardır. Bu, birden fazla satır veya sütun oluşturur. Bir satırdaki öğe sayısı, maxItemsInEachRow veya maxItemsInEachColumn ayarlanarak da kontrol edilebilir. FlowRow ve FlowColumn’u genellikle responsive layout’lar oluşturmak için kullanabilirsiniz; öğeler bir boyut için çok büyükse içerik bölünmez ve maxItemsInEach* ile Modifier.weight(weight) kombinasyonunu kullanmak, gerektiğinde bir satırın veya sütunun genişliğini dolduran / genişleten (fill/expand) layout’lar oluşturmaya yardımcı olabilir. Tipik örnek, bir chip veya filtreleme kullanıcı arayüzü içindir: . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/flow-layouts/#flow-layouts-in-compose",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/flow-layouts/#flow-layouts-in-compose"
  },"132": {
    "doc": "Flow layouts",
    "title": "Basic usage",
    "content": "FlowRow veya FlowColumn kullanmak için bu composable’ları oluşturun ve standart akışı takip etmesi gereken öğeleri içine yerleştirin: . @Composable private fun FlowRowSimpleUsageExample() { FlowRow(modifier = Modifier.padding(8.dp)) { ChipItem(\"Price: High to Low\") ChipItem(\"Avg rating: 4+\") ChipItem(\"Free breakfast\") ChipItem(\"Free cancellation\") ChipItem(\"£50 pn\") } } . Bu kod parçacığı, ilk satırda yer kalmadığında öğelerin otomatik olarak bir sonraki satıra geçtiği yukarıda gösterilen kullanıcı arayüzüyle sonuçlanır. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/flow-layouts/#basic-usage",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/flow-layouts/#basic-usage"
  },"133": {
    "doc": "Flow layouts",
    "title": "Features of flow layout",
    "content": "Flow layout’ları, uygulamanızda farklı layout’lar oluşturmak için kullanabileceğiniz aşağıdaki özelliklere ve niteliklere sahiptir. Main axis arrangement: horizontal or vertical arrangement . Main axis, öğelerin yerleştirildiği eksendir (örneğin, FlowRow’da öğeler yatay olarak yerleştirilir). FlowRow’daki horizontalArrangement parametresi, boş alanın öğeler arasında nasıl dağıtılacağını kontrol eder. Aşağıdaki tabloda FlowRow için öğeler üzerinde horizontalArrangement ayarlama örnekleri gösterilmektedir: . | FlowRow üzerinde yatay düzenleme(arrangement) ayarı | Sonuc | . | Arrangement.Start(Default) | | . | Arrangement.SpaceBetween | | . | Arrangement.Center | | . | Arrangement.End | | . | Arrangement.SpaceAround | | . | Arrangement.spacedBy(8.dp) | | . FlowColumn için ise, default Arrangement.Top secenegidir. verticalArrangement icin benzer seçenekler mevcuttur. Cross axis arrangement . Cross axis (çapraz eksen), main axis’in (ana eksen) ters yönündeki eksendir. Örneğin, FlowRow’da bu dikey eksendir. Konteyner içindeki genel içeriğin çapraz eksende nasıl düzenlendiğini değiştirmek için FlowRow için verticalArrangement ve FlowColumn için horizontalArrangement kullanın. FlowRow için, aşağıdaki tabloda öğeler üzerinde farklı verticalArrangement ayarlama örnekleri gösterilmektedir: . | FlowRow üzerinde dikey düzenleme(arrangment) ayarı | Sonuc | . | Arrangement.Top(Default) | | . | Arrangement.Bottom | | . | Arrangement.Center | | . FlowColumn için horizontalArrangement için benzer seçenekler mevcuttur. Varsayılan çapraz eksen düzenlemesi Arrangement.Start’tır. Individual item alignment . Row içindeki öğeleri farklı hizalamalarla tek tek konumlandırmak isteyebilirsiniz. Bu, öğeleri geçerli satır içinde hizaladığı için verticalArrangement ve horizontalArrangement öğelerinden farklıdır. Bunu Modifier.align() ile uygulayabilirsiniz. Örneğin, bir FlowRow içindeki öğeler farklı yüksekliklerde olduğunda, satır en büyük öğenin yüksekliğini alır ve öğelere Modifier.align(alignmentOption) uygular: . | FlowRow üzerinde dikey hizalama(alignment) ayarı | Sonuc | . | Alignment.Top(Default) | | . | Alignment.Bottom | | . | Alignment.CenterVertically | | . FlowColumn için benzer seçenekler mevcuttur. Default hizalama Alignment.Start’tır. Max items in row or column . maxItemsInEachRow veya maxItemsInEachColumn parametreleri, bir sonraki satıra geçmeden önce bir satırda izin verilecek ana eksendeki maksimum öğeleri tanımlar. Varsayılan değer Int.MAX_INT olup, boyutları satıra sığmalarına izin verdiği sürece mümkün olduğunca çok öğeye izin verir. Örneğin, maxItemsInEachRow ayarı ilk layout’u yalnızca 3 öğeye sahip olacak şekilde zorlar: . | No max set | maxItemsInEachRow = 3 | . | | | . Item weights . Weight, bir öğeyi faktörüne ve yerleştirildiği satırdaki kullanılabilir alana göre büyütür. Önemli olarak, FlowRow ve Row arasında bir öğenin genişliğini hesaplamak için weight’in nasıl kullanıldığı ile ilgili bir fark vardır. Row için weight, Row’daki tüm öğeleri temel alır. FlowRow ile weight, FlowRow konteynerindeki tüm öğelere değil, öğenin yerleştirildiği satırdaki öğeleri temel alır. Örneğin, her biri 1f, 2f, 1f ve 3f farklı weight’e sahip, hepsi bir satıra düşen 4 öğeniz varsa, toplam ağırlık 7f olur. Bir row veya column’da kalan alan 7f’ye bölünecektir. Ardından, her bir öğe genişliği şu şekilde hesaplanacaktır: weight * (remainingSpace / totalWeight). Grid benzeri bir layout oluşturmak için FlowRow veya FlowColumn ile Modifier.weight ve max items kombinasyonunu kullanabilirsiniz. Bu yaklaşım, cihazınızın boyutuna göre ayarlanan responsive layout’lar oluşturmak için kullanışlıdır. Weight kullanarak elde edebileceğiniz birkaç farklı örnek vardır. Örneklerden biri, aşağıda gösterildiği gibi öğelerin eşit boyutta olduğu bir griddir: . Eşit öğe boyutlarında bir grid oluşturmak için aşağıdakileri yapabilirsiniz: . val rows = 3 val columns = 3 FlowRow( modifier = Modifier.padding(4.dp), horizontalArrangement = Arrangement.spacedBy(4.dp), maxItemsInEachRow = rows ) { val itemModifier = Modifier .padding(4.dp) .height(80.dp) .weight(1f) .clip(RoundedCornerShape(8.dp)) .background(MaterialColors.Blue200) repeat(rows * columns) { Spacer(modifier = itemModifier) } } . Daha da önemlisi, başka bir öğe ekler ve bunu 9 yerine 10 kez tekrarlarsanız, tüm satırın toplam weight’i 1f olduğundan, son öğe son sütunun tamamını kaplar: . Weight’leri Modifier.width(exactDpAmount), Modifier.aspectRatio(aspectRatio) veya Modifier.fillMaxWidth(fraction) gibi diğer Modifier’larla birleştirebilirsiniz. Bu modifier’ların hepsi birlikte çalışarak bir FlowRow (veya FlowColumn) içindeki öğelerin responsive boyutlandırılmasına olanak sağlar. Ayrıca, iki öğenin her birinin genişliğin yarısını kapladığı ve bir öğenin bir sonraki sütunun tam genişliğini kapladığı farklı öğe boyutlarından oluşan alternatif bir grid de oluşturabilirsiniz: . Bunu aşağıdaki kod ile gerçekleştirebilirsiniz: . FlowRow( modifier = Modifier.padding(4.dp), horizontalArrangement = Arrangement.spacedBy(4.dp), maxItemsInEachRow = 2 ) { val itemModifier = Modifier .padding(4.dp) .height(80.dp) .clip(RoundedCornerShape(8.dp)) .background(Color.Blue) repeat(6) { item -&gt; // if the item is the third item, don't use weight modifier, but rather fillMaxWidth if ((item + 1) % 3 == 0) { Spacer(modifier = itemModifier.fillMaxWidth()) } else { Spacer(modifier = itemModifier.weight(0.5f)) } } } . Fractional sizing . Modifier.fillMaxWidth(fraction) kullanarak, bir öğenin kaplaması gereken konteyner boyutunu belirtebilirsiniz. Bu, Modifier.fillMaxWidth(fraction) öğesinin Row veya Column öğesine uygulandığında çalışmasından farklıdır, çünkü Row/Column öğeleri tüm konteyner genişliği yerine kalan genişliğin bir yüzdesini alır. Örneğin, aşağıdaki kod FlowRow ile Row kullanıldığında farklı sonuçlar üretir: . FlowRow( modifier = Modifier.padding(4.dp), horizontalArrangement = Arrangement.spacedBy(4.dp), maxItemsInEachRow = 3 ) { val itemModifier = Modifier .clip(RoundedCornerShape(8.dp)) Box(modifier = itemModifier.height(200.dp).width(60.dp).background(Color.Red)) Box(modifier = itemModifier.height(200.dp).fillMaxWidth(0.7f).background(Color.Blue)) Box(modifier = itemModifier.height(200.dp).weight(1f).background(Color.Magenta)) } . | FlowRow:Tüm konteyner genişliğinin 0,7 fraksiyonuna sahip ortanca öğe. | | . | Row: Kalan Satır genişliğinin yüzde 0,7’sini kaplayan ortanca öğe. | | . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/flow-layouts/#features-of-flow-layout",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/flow-layouts/#features-of-flow-layout"
  },"134": {
    "doc": "Flow layouts",
    "title": "Flow layouts",
    "content": " ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/flow-layouts/",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/flow-layouts/"
  },"135": {
    "doc": "Font",
    "title": "Font",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/font/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/font/"
  },"136": {
    "doc": "Fragment lifecycle",
    "title": "Fragment lifecycle",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragment-lifecycle/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragment-lifecycle/"
  },"137": {
    "doc": "Fragment manager",
    "title": "Fragment manager",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragment-manager/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragment-manager/"
  },"138": {
    "doc": "Fragment transactions",
    "title": "Fragment transactions",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragment-transactions/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragment-transactions/"
  },"139": {
    "doc": "Fragments",
    "title": "Fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragments/"
  },"140": {
    "doc": "Generated binding classes",
    "title": "Generated binding classes",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/generated-binding-classes/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/generated-binding-classes/"
  },"141": {
    "doc": "Get started",
    "title": "Get started",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/get-started/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/get-started/"
  },"142": {
    "doc": "Getting started",
    "title": "Getting started",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/getting-started/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/getting-started/"
  },"143": {
    "doc": "Getting started",
    "title": "Getting started",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/getting-started/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/getting-started/"
  },"144": {
    "doc": "Global actions",
    "title": "Global actions",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/global-actions/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/global-actions/"
  },"145": {
    "doc": "Google Play",
    "title": "Google Play",
    "content": " ",
    "url": "/docs/core-topics/google-play/google-play/",
    
    "relUrl": "/docs/core-topics/google-play/google-play/"
  },"146": {
    "doc": "Guide to app architecture",
    "title": "Guide to app architecture",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/guide-to-app-architecture/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/guide-to-app-architecture/"
  },"147": {
    "doc": "Handle configuration changes",
    "title": "Handle configuration changes",
    "content": " ",
    "url": "/docs/app-basics/app-resources/handle-configuration-changes/",
    
    "relUrl": "/docs/app-basics/app-resources/handle-configuration-changes/"
  },"148": {
    "doc": "Handle configuration changes",
    "title": "Handle configuration changes",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/handle-configuration-changes/",
    
    "relUrl": "/docs/app-architecture/app-navigation/handle-configuration-changes/"
  },"149": {
    "doc": "Lifecycle-aware components",
    "title": "Lifecycle-aware components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/handle-lifecycles/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/handle-lifecycles/"
  },"150": {
    "doc": "Hilt and Dagger annotations cheat sheet",
    "title": "Hilt and Dagger annotations cheat sheet",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/hilt-and-dagger-annotations-cheat-sheet/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/hilt-and-dagger-annotations-cheat-sheet/"
  },"151": {
    "doc": "Hilt in multi-module apps",
    "title": "Hilt in multi-module apps",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/hilt-in-multi-module-apps/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/hilt-in-multi-module-apps/"
  },"152": {
    "doc": "Hilt testing guide",
    "title": "Hilt testing guide",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/hilt-testing-guide/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/hilt-testing-guide/"
  },"153": {
    "doc": "How to guides",
    "title": "How to guides",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/how-to-guides/how-to-guides/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/how-to-guides/how-to-guides/"
  },"154": {
    "doc": "Ana Sayfa",
    "title": "Android Dokümantasyonu Türkçe Çeviri Projesi",
    "content": "Bu proje, Android dokümantasyonunun Türkçe çevirisini oluşturmak amacıyla başlatılmıştır. Android platformunun genişleyen ve gelişen yapısı nedeniyle, geliştiricilerin öğrenmek ve anlamak istedikleri konuları daha rahat anlayabilecekleri bir dilde sunmak amacıyla böyle bir proje hayata geçirilmiştir. Bu GitHub sayfası, proje ekibi tarafından çevirisi yapılmış olan Android dokümantasyonunun Türkçe sürümüne erişmenizi sağlamak için oluşturulmuştur. Ayrıca projeye katılmak ve çeviri sürecine katkıda bulunmak isteyen geliştiricilerin de buradan projeye dahil olabileceği bir ortam sunulmaktadır. Projenin ilerleyişi ve son durumu hakkında güncel bilgilere bu sayfa üzerinden erişebilirsiniz. Ayrıca projenin GitHub deposuna da erişim sağlayarak, kodlar üzerinde değişiklik yapabilir ve pull requestler ile projeye katkıda bulunabilirsiniz. Bu projede yer alarak, Android geliştirme topluluğuna katkıda bulunmuş olacak ve Türkçe dilinde daha geniş bir Android dokümantasyonu kütüphanesi oluşmasına destek vermiş olacaksınız. ",
    "url": "/#android-dok%C3%BCmantasyonu-t%C3%BCrk%C3%A7e-%C3%A7eviri-projesi",
    
    "relUrl": "/#android-dokümantasyonu-türkçe-çeviri-projesi"
  },"155": {
    "doc": "Ana Sayfa",
    "title": "Proje Ekibi",
    "content": "Mustafa UNLU . ",
    "url": "/#proje-ekibi",
    
    "relUrl": "/#proje-ekibi"
  },"156": {
    "doc": "Ana Sayfa",
    "title": "Ana Sayfa",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"157": {
    "doc": "Interact programmatically",
    "title": "Interact programmatically",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/interact-programmatically/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/interact-programmatically/"
  },"158": {
    "doc": "Introduction to activities",
    "title": "Introduction to activities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/introcution-to-activities/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/introcution-to-activities/"
  },"159": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "Uygulama mimarisi tasarımı(app architecture design), uygulamalarınızın sağlam, test edilebilir ve sürdürülebilir olmasını sağlamak için önemli bir husustur. Android, uygulamanızı best practicelere göre oluşturmanıza yardımcı olacak bir dizi library ve component sağlar. Building a scalable, modularized, testable app from scratch . | Guide to app architecture ile sağlam bir uygulamayı bir araya getirmenin temellerini öğrenin. | Uygulama navigasyonunda ince ayar yaparak kullanıcı deneyimini iyileştirin. | Dependency injection kılavuzlarıyla boilerplate kodlari azaltın ve kodunuzun bakımını kolaylaştırın. | . ",
    "url": "/docs/app-architecture/introduction/",
    
    "relUrl": "/docs/app-architecture/introduction/"
  },"160": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": " ",
    "url": "/docs/jetpack-compose/introduction/introduction/",
    
    "relUrl": "/docs/jetpack-compose/introduction/introduction/"
  },"161": {
    "doc": "Jetpack Compose",
    "title": "Jetpack Compose",
    "content": " ",
    "url": "/docs/jetpack-compose",
    
    "relUrl": "/docs/jetpack-compose"
  },"162": {
    "doc": "Kotlin DSL",
    "title": "Kotlin DSL",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/kotlin-dsl/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/kotlin-dsl/"
  },"163": {
    "doc": "Language and locale resolution",
    "title": "Language and locale resolution",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/language-and-locale-resolution/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/language-and-locale-resolution/"
  },"164": {
    "doc": "Layout basics",
    "title": "Compose layout basics",
    "content": "Jetpack Compose, uygulamanızın kullanıcı arayüzünü tasarlamayı ve oluşturmayı çok daha kolay hale getirir. Compose, state’i UI öğelerine dönüştürür: . | Composition(Öğelerin bileşimi) | Layout of element(Elemanların yerleşimi) | Drawing of elements(Elemanların çizimi) | . Fundamentals of Compose Layouts and Modifiers - MAD Skills . Bu belge, Compose’un UI öğelerinizi düzenlemenize yardımcı olmak için sağladığı bazı yapı taşlarını açıklayarak öğelerin düzenine odaklanmaktadır. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#compose-layout-basics",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#compose-layout-basics"
  },"165": {
    "doc": "Layout basics",
    "title": "Goals of layouts in Compose",
    "content": "Layout sisteminin Jetpack Compose uygulamasının iki ana hedefi vardır: . | Yüksek performans | Kolayca custom layout yazabilme | . Not: Android View sistemi ile RelativeLayout gibi belirli View’leri iç içe yerleştirirken bazı performans sorunlarıyla karşılaşabilirsiniz. Compose çoklu ölçümleri önlediğinden, performansı etkilemeden istediğiniz kadar derine yerleştirebilirsiniz. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#goals-of-layouts-in-compose",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#goals-of-layouts-in-compose"
  },"166": {
    "doc": "Layout basics",
    "title": "Basicss of Composable functions",
    "content": "Composable fonksiyonlar Compose’un temel yapı taşıdır. Composable fonksiyon, UI’nizin bir kısmını tanımlayan Unit yayan bir fonksiyondur. Fonksiyon bazı girdileri alır ve ekranda gösterilenleri oluşturur. Composable’lar hakkında daha fazla bilgi için Compose mental model belgelerine göz atın. Bir Composable fonksiyonu birkaç UI öğesi yayabilir. Ancak, nasıl düzenlenmeleri gerektiği konusunda rehberlik sağlamazsanız, Compose öğeleri beğenmediğiniz bir şekilde düzenleyebilir. Örneğin, bu kod iki metin öğesi üretir: . @Composable fun ArtistCard() { Text(\"Alfred Sisley\") Text(\"3 minutes ago\") } . Nasıl düzenlenmelerini istediğinize dair bir yönlendirme olmadan, Compose metin öğelerini üst üste yığarak okunamaz hale getirir: . Compose, UI öğelerinizi düzenlemenize yardımcı olmak için kullanıma hazır layout’lardan oluşan bir koleksiyon sunar ve kendi daha özel layout’larınızı tanımlamanızı kolaylaştırır. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#basicss-of-composable-functions",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#basicss-of-composable-functions"
  },"167": {
    "doc": "Layout basics",
    "title": "Standard layout components",
    "content": "Çoğu durumda, Compose’un standart layout öğelerini kullanabilirsiniz. Öğeleri ekrana dikey olarak yerleştirmek için Column‘u kullanın. @Composable fun ArtistCardColumn() { Column { Text(\"Alfred Sisley\") Text(\"3 minutes ago\") } } . Benzer şekilde, öğeleri ekrana yatay olarak yerleştirmek için Row kullanın. Hem Column hem de Row, içerdikleri öğelerin hizalamasını yapılandırmayı destekler. @Composable fun ArtistCardRow(artist: Artist) { Row(verticalAlignment = Alignment.CenterVertically) { Image(bitmap = artist.image, contentDescription = \"Artist image\") Column { Text(artist.name) Text(artist.lastSeenOnline) } } } . Öğeleri üst üste koymak için Box‘ı kullanın. Box, içerdiği öğelerin belirli hizalamasını yapılandırmayı da destekler. @Composable fun ArtistAvatar(artist: Artist) { Box { Image(bitmap = artist.image, contentDescription = \"Artist image\") Icon(Icons.Filled.Check, contentDescription = \"Check mark\") } } . Genellikle ihtiyacınız olan tek şey bu yapı taşlarıdır. Bu layoutları uygulamanıza uygun daha ayrıntılı bir layoutta birleştirmek için kendi composable fonksiyonunuzu yazabilirsiniz. Not: Compose, iç içe layoutlari verimli bir şekilde işleyerek karmaşık bir UI tasarlamak için harika bir yol haline getirir. Bu, performans nedenleriyle iç içe layoutlarda kaçınmanız gereken Android Views’e göre bir gelişmedir. Child componentlerin Row içindeki konumunu ayarlamak için horizontalArrangement ve verticalAlignment argümanlarını kullanın. Column için, verticalArrangement ve horizontalAlignment argümanlarını kullanın: . @Composable fun ArtistCardArrangement(artist: Artist) { Row( verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.End ) { Image(bitmap = artist.image, contentDescription = \"Artist image\") Column { /*...*/ } } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#standard-layout-components",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#standard-layout-components"
  },"168": {
    "doc": "Layout basics",
    "title": "The layout model",
    "content": "Layout modelinde, UI ağacı tek bir seferde düzenlenir. Her node’dan önce kendisini boyutlandırması istenir, ardından tüm child’ları özyinelemeli olarak boyutlandırır ve boyut kısıtlamalarını ağaçtan aşağıya child’lara aktarır. Ardından, leaf nodelar boyutlandırılır ve yerleştirilir, çözülen boyutlar ve yerleştirme talimatları ağaca geri aktarılır. Kısaca, ebeveynler çocuklarından önce ölçülür, ancak çocuklarından sonra boyutlandırılır ve yerleştirilir. Aşağıdaki SearchResult fonksiyonunu düşünün. @Composable fun SearchResult() { Row { Image( // ... ) Column { Text( // ... ) Text( // ... ) } } } . Bu fonksiyon aşağıdaki UI ağacını verir. SearchResult Row Image Column Text Text . SearchResult örneğinde, UI ağaç layout’u şu sırayı takip eder: . | Root node olan Row’dan ölçüm yapması istenir. | Root node Row, ilk çocuğu olan Image’dan ölçüm yapmasını ister. | Image bir leaf node’dur (yani çocuğu yoktur), bu nedenle bir boyut bildirir ve yerleştirme talimatlarını döndürür. | Row, ikinci çocuğu olan Column’dan ölçüm yapmasını ister. | Column node’u ilk Text çocuğunun ölçülmesini ister. | İlk Text node’u bir leaf node’dur, bu nedenle bir boyut bildirir ve yerleştirme talimatlarını döndürür. | Column ikinci Text çocuğunun ölçülmesini ister. | İkinci Text node’u bir leaf node’dur, bu nedenle bir boyut bildirir ve yerleştirme talimatlarını döndürür. | Artık Column node’u çocuklarını ölçtüğüne, boyutlandırdığına ve yerleştirdiğine göre, kendi boyutunu ve yerleşimini belirleyebilir. | Root node olan Row ölçüldüğüne, boyutlandırıldığına ve çocukları yerleştirildiğine göre, kendi boyutunu ve yerleşimini belirleyebilir. | . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#the-layout-model",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#the-layout-model"
  },"169": {
    "doc": "Layout basics",
    "title": "Performance",
    "content": "Compose, child’ları yalnızca bir kez boyutlandırarak yüksek performans elde eder. Tek seferlik ölçüm performans açısından iyidir ve Compose’un derin UI ağaçlarını verimli bir şekilde işlemesine olanak tanır. Bir öğe child’ını iki kez ölçseydi ve bu child da her bir child’ını iki kez ölçseydi ve bu böyle devam etseydi, tüm bir UI’yi düzenlemek için tek bir girişimde çok fazla iş yapmak zorunda kalacak ve uygulamanızı performanslı tutmayı zorlaştıracaktı. Layout’unuz herhangi bir nedenle birden fazla ölçüm gerektiriyorsa, Compose özel bir sistem olan intrinsic ölçümler sunar. Bu özellik hakkında daha fazla bilgiyi Compose layout’larında intrinsic ölçümler bölümünde okuyabilirsiniz. Ölçüm ve yerleştirme, layout geçişinin farklı alt aşamaları olduğundan, ölçümü etkilemeyen yalnızca öğelerin yerleştirilmesini etkileyen herhangi bir değişiklik ayrı olarak yürütülebilir. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#performance",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#performance"
  },"170": {
    "doc": "Layout basics",
    "title": "Using modifiers in your layouts",
    "content": "Compose modifiers bölümünde tartışıldığı gibi, composablelar’ınızı zenginleştirmek veya dekore etmek için modifier’ları kullanabilirsiniz. Modifier’lar layout’unuzu özelleştirmek için çok önemlidir. Örneğin, burada ArtistCard’ı özelleştirmek için birkaç değiştirici zincirliyoruz: . @Composable fun ArtistCardModifiers( artist: Artist, onClick: () -&gt; Unit ) { val padding = 16.dp Column( Modifier .clickable(onClick = onClick) .padding(padding) .fillMaxWidth() ) { Row(verticalAlignment = Alignment.CenterVertically) { /*...*/ } Spacer(Modifier.size(padding)) Card( elevation = CardDefaults.cardElevation(defaultElevation = 4.dp), ) { /*...*/ } } } . Yukarıdaki kodda, birlikte kullanılan farklı modifier fonksiyonlarına dikkat edin. | clickable bir composable’ın kullanıcı girdisine tepki vermesini sağlar ve bir dalgalanma gösterir. | padding bir öğenin etrafına boşluk koyar. | fillMaxWidth, composable öğesinin ebeveyninden kendisine verilen maksimum genişliği doldurmasını sağlar. | size() bir öğenin tercih edilen genişlik ve yüksekliğini belirtir. | . Not: Diğer şeylerin yanı sıra, modifier’lar view tabanlı layout’lardaki layout parametrelerine benzer bir rol oynarlar. Bununla birlikte, modifier’lar bazen scope-specific olduklarından, tip güvenliği sunarlar ve ayrıca belirli bir layout için neyin mevcut ve uygulanabilir olduğunu keşfetmenize ve anlamanıza yardımcı olurlar. XML layout’larında, belirli bir layout attribute’ünün belirli bir view için geçerli olup olmadığını bulmak bazen zordur. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#using-modifiers-in-your-layouts",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#using-modifiers-in-your-layouts"
  },"171": {
    "doc": "Layout basics",
    "title": "Scrollable layouts",
    "content": "Compose gestures belgelerinde kaydırılabilir layoutlar hakkında daha fazla bilgi edinin. Listeler ve lazy listeler için Compose lists belgelerine göz atın. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#scrollable-layouts",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#scrollable-layouts"
  },"172": {
    "doc": "Layout basics",
    "title": "Responsive layouts",
    "content": "Bir layout, farklı ekran oryantasyonları ve form faktörü boyutları göz önünde bulundurularak tasarlanmalıdır. Compose, composable layout’larınızı çeşitli ekran konfigürasyonlarına uyarlamayı kolaylaştırmak için kutudan çıktığı gibi birkaç mekanizma sunar. Constraints . Parent’tan gelen kısıtlamaları bilmek ve layout’u buna göre tasarlamak için bir BoxWithConstraints kullanabilirsiniz. Ölçüm kısıtlamaları content lambda kapsamında bulunabilir. Bu ölçüm kısıtlamalarını, farklı ekran yapılandırmaları için farklı layoutlar oluşturmak için kullanabilirsiniz: . @Composable fun WithConstraintsComposable() { BoxWithConstraints { Text(\"My minHeight is $minHeight while my maxWidth is $maxWidth\") } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#responsive-layouts",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#responsive-layouts"
  },"173": {
    "doc": "Layout basics",
    "title": "Slot-based layouts",
    "content": "Compose, UI oluşturmayı kolaylaştırmak için androidx.compose.material:material bağımlılığı (Android Studio’da bir Compose projesi oluştururken dahil edilir) ile Materyal Tasarımına dayalı çok çeşitli bileşenler sağlar. Drawer, FloatingActionButton ve TopAppBar gibi öğelerin tümü sağlanmıştır. Material bileşenleri, Compose’un bileşenlerin üzerine bir özelleştirme katmanı getirmek için sunduğu bir model olan slot API’lerini yoğun bir şekilde kullanır. Bu yaklaşım, bileşenleri daha esnek hale getirir, çünkü child öğenin her yapılandırma parametresini ortaya çıkarmak zorunda kalmak yerine kendini yapılandırabilen bir child öğeyi kabul ederler. Slotlar, geliştiricinin istediği gibi doldurması için UI’da boş bir alan bırakır. Örneğin, bunlar bir TopAppBar‘da özelleştirebileceğiniz slotlardır: . Composable’lar genellikle bir content composable lambda alır ( content: @Composable () -&gt; Unit). Slot API’leri belirli kullanımlar için birden fazla content parametresi sunar. Örneğin, TopAppBar title, navigationIcon ve actions için içerik sağlamanıza olanak tanır. Örneğin, Scaffold temel Material Design layout yapısına sahip bir UI uygulamanıza olanak tanır. Scaffold, TopAppBar, BottomAppBar, FloatingActionButton ve Drawer gibi en yaygın üst düzey Material bileşenleri için slotlar sağlar. Scaffold‘u kullanarak bu komponentlerin doğru şekilde konumlandırıldığından ve birlikte doğru şekilde çalıştığından emin olmak kolaydır. @Composable fun HomeScreen(/*...*/) { ModalNavigationDrawer(drawerContent = { /* ... */ }) { Scaffold( topBar = { /*...*/ } ) { contentPadding -&gt; // ... } } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#slot-based-layouts",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/#slot-based-layouts"
  },"174": {
    "doc": "Layout basics",
    "title": "Layout basics",
    "content": " ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/layout-basics/"
  },"175": {
    "doc": "Layout",
    "title": "Layout",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/layout/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/layout/"
  },"176": {
    "doc": "Layouts and binding expressions",
    "title": "Layouts and binding expressions",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/layouts-and-binding-expressions/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/layouts-and-binding-expressions/"
  },"177": {
    "doc": "Learning pathway",
    "title": "Learning Pathway",
    "content": "Learning Pathway icin tiklayiniz. ",
    "url": "/docs/app-architecture/guide-to-app-architecture/learning-pathway/#learning-pathway",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/learning-pathway/#learning-pathway"
  },"178": {
    "doc": "Learning pathway",
    "title": "Learning pathway",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/learning-pathway/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/learning-pathway/"
  },"179": {
    "doc": "Lifecycle-aware components",
    "title": "Lifecycle-aware components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/lifecycle-aware-components/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/lifecycle-aware-components/"
  },"180": {
    "doc": "Lifecycle",
    "title": "Lifecycle of composables",
    "content": "Bu sayfada, bir composable’ın yaşam döngüsü ve Compose’un bir composable’ın recomposition’a ihtiyacı olup olmadığına nasıl karar verdiği hakkında bilgi edineceksiniz. ",
    "url": "/docs/jetpack-compose/ui-architecture/lifecycle/#lifecycle-of-composables",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/lifecycle/#lifecycle-of-composables"
  },"181": {
    "doc": "Lifecycle",
    "title": "Lifecycle overview",
    "content": "Managing state belgelerinde belirtildiği gibi, bir Composition uygulamanızın kullanıcı arayüzünü tanımlar ve composables çalıştırılarak üretilir. Bir Composition, kullanıcı arayüzünüzü tanımlayan composable’ların bir ağaç yapısıdır. Jetpack Compose, composable’larınızı ilk kez çalıştırdığında, ilk composition sırasında, UI’nizi bir Composition’da tanımlamak için çağırdığınız composable’ların takibini yapacaktır. Ardından, uygulamanızın state’i değiştiğinde, Jetpack Compose bir recomposition planlar. Recomposition, Jetpack Compose’un state değişikliklerine yanıt olarak değişmiş olabilecek composable’ları yeniden çalıştırması ve ardından Composition’ı değişiklikleri yansıtacak şekilde güncellemesidir. Bir Composition yalnızca bir initial composition tarafından üretilebilir ve recomposition tarafından güncellenebilir. Bir Composition’ı değiştirmenin tek yolu recomposition’dır. Bir composable’ın yaşam döngüsü şu olaylarla tanımlanır: Composition’a girme, 0 veya daha fazla kez yeniden composition’a girme ve Composition’dan çıkma. Şekil 1. Composition içindeki bir composable’ın yaşam döngüsü. Composition’a girer, 0 veya daha fazla kez yeniden oluşturulur ve Composition’dan ayrılır. Recomposition tipik olarak bir State nesnesindeki bir değişiklik tarafından tetiklenir. Compose bunları izler ve Composition'da söz konusu State nesnesini okuyan tüm composable'ları ve atlanamayacak şekilde çağırdıkları tüm composable'ları çalıştırır. Not: Bir Composable’ın yaşam döngüsü view, activity ve fragment’ların yaşam döngüsünden daha basittir. Bir composable’ın daha karmaşık bir yaşam döngüsüne sahip harici kaynakları yönetmesi veya bunlarla etkileşime girmesi gerektiğinde, efektleri kullanmalısınız. Bir composable birden çok kez çağrılırsa, Composition’a birden çok instance yerleştirilir. Her çağrının Composition içinde kendi yaşam döngüsü vardır. @Composable fun MyComposable() { Column { Text(\"Hello\") Text(\"World\") } } . Şekil 2. MyComposable’ın Composition’da gösterimi. Bir composable birden fazla kez çağrılırsa, Composition’a birden fazla instance yerleştirilir. Bir öğenin farklı bir renge sahip olması, onun ayrı bir instance olduğunun göstergesidir. ",
    "url": "/docs/jetpack-compose/ui-architecture/lifecycle/#lifecycle-overview",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/lifecycle/#lifecycle-overview"
  },"182": {
    "doc": "Lifecycle",
    "title": "Anatomy of a composable in Composition",
    "content": "Composition’da bir composable instance’ı call site ile tanımlanır. Compose derleyicisi her call site’i farklı olarak değerlendirir. Birden fazla call site’dan composable’ların çağrılması, Composition’da composable’ın birden fazla instance’ını oluşturacaktır. Anahtar Terim: Call site, bir composable’ın çağrıldığı kaynak kod konumudur. Bu, Composition’daki yerini ve dolayısıyla UI ağacını etkiler. Bir recomposition sırasında bir composable önceki composition sırasında çağırdığından farklı composable’lar çağırırsa, Compose hangi composable’ların çağrıldığını ya da çağrılmadığını belirleyecek ve her iki composition’da da çağrılan composable’lar için, girdileri değişmemişse onları recomposition etmekten kaçınacaktır.*** . Kimliğin korunması, side-effectleri composable’ları ile ilişkilendirmek için çok önemlidir, böylece her recomposition için yeniden başlatmak yerine başarıyla tamamlayabilirler. Aşağıdaki örneği ele alalım: . @Composable fun LoginScreen(showError: Boolean) { if (showError) { LoginError() } LoginInput() // Bu call site LoginInput'un Composition'da nereye yerleştirileceğini etkiler } @Composable fun LoginInput() { /* ... */ } @Composable fun LoginError() { /* ... */ } . Yukarıdaki kod parçasında, LoginScreen koşullu olarak LoginError composable’ını çağıracak ve her zaman LoginInput composable’ını çağıracaktır. Her çağrının, derleyicinin onu benzersiz bir şekilde tanımlamak için kullanacağı benzersiz bir call site ve kaynak konumu vardır. Şekil 3. State değiştiğinde ve recomposition gerçekleştiğinde LoginScreen’in Composition’daki gösterimi. Aynı renk, yeniden oluşturulmadığı anlamına gelir. LoginInput ilk çağrılmadan ikinci çağrılmaya geçse de, LoginInput instance’ı recompositionlar boyunca korunacaktır. Ayrıca, LoginInput’un recomposition boyunca değişen herhangi bir parametresi olmadığından, LoginInput’a yapılan çağrı Compose tarafından atlanacaktır. Add extra information to help smart recompositions . Bir composable’ın birden çok kez çağrılması, onu Composition’a da birden çok kez ekleyecektir. Aynı call site’dan bir composable birden çok kez çağrıldığında, Compose o composable’a yapılan her çağrıyı benzersiz bir şekilde tanımlayacak herhangi bir bilgiye sahip değildir, bu nedenle instance’ları farklı tutmak için call site’a ek olarak yürütme sırası kullanılır. Bu davranış bazen gerekli olan tek şeydir, ancak bazı durumlarda istenmeyen davranışlara neden olabilir. @Composable fun MoviesScreen(movies: List&lt;Movie&gt;) { Column { for (movie in movies) { //MovieOverview composablelari, for döngüsünde indeks konumu verilen Composition'a yerleştirilir MovieOverview(movie) } } } . Yukarıdaki örnekte Compose, instance’ları Composition’da farklı tutmak için call site’a ek olarak execution order’ı kullanır. Listenin en altına yeni bir film eklenirse, Compose, listedeki konumları değişmediğinden ve bu nedenle film girişi bu instancelar için aynı olduğundan, Composition’da zaten bulunan instance’ları yeniden kullanabilir. Şekil 4. Listenin altına yeni bir öğe eklendiğinde MoviesScreen’in Composition’daki gösterimi. Composition’daki MovieOverview composable’ları yeniden kullanılabilir. MovieOverview’daki aynı renk, composable’ın yeniden oluşturulmadığı anlamına gelir. Bununla birlikte, film listesi listenin üstüne veya ortasına ekleme, öğeleri kaldırma veya yeniden sıralama yoluyla değişirse, girdi parametresi listedeki konumu değişen tüm MovieOverview çağrılarında recomposition’a neden olur. Örneğin, MovieOverview bir side-effect kullanarak bir film görüntüsü getiriyorsa bu son derece önemlidir. Efekt devam ederken recomposition gerçekleşirse, iptal edilecek ve yeniden başlayacaktır. @Composable fun MovieOverview(movie: Movie) { Column { //Side-effect dokümanlarda daha sonra açıklanmıştır. // Resim getirme işlemi devam ederken MovieOverview recompose edilirse, // iptal edilir ve yeniden başlatılır. val image = loadNetworkImage(movie.url) MovieHeader(image) /* ... */ } } . Şekil 5. Listeye yeni bir eleman eklendiğinde MoviesScreen’in Composition’daki gösterimi. MovieOverview composable’ları yeniden kullanılamaz ve tüm side-effectler yeniden başlar. MovieOverview’da farklı bir renk, composable’ın yeniden oluşturulduğu anlamına gelir. İdeal olarak, MovieOverview instance’ının kimliğini kendisine aktarılan filmin kimliğine bağlı olarak düşünmek isteriz. Film listesini yeniden sıralarsak, ideal olarak her MovieOverview composable’ı farklı bir film instance’ı ile yeniden oluşturmak yerine Composition ağacındaki instance’ları da benzer şekilde yeniden sıralarız. Compose, çalışma zamanına ağacın belirli bir bölümünü tanımlamak için hangi değerleri kullanmak istediğinizi söylemeniz için bir yol sağlar: key composable. Bir kod bloğunu, bir veya daha fazla değerin aktarıldığı bir key composable çağrısı ile sardığınızda, bu değerler birleştirilerek compositiondaki o instance’ı tanımlamak için kullanılacaktır. Bir key için değerin global olarak benzersiz olması gerekmez, yalnızca call site’deki composable’ların invocation’ları arasında benzersiz olması gerekir. Yani bu örnekte, her filmin filmler arasında benzersiz olan bir key’e sahip olması gerekir; bu key’i uygulamanın başka bir yerindeki başka bir composable ile paylaşması sorun değildir. @Composable fun MoviesScreenWithKey(movies: List&lt;Movie&gt;) { Column { for (movie in movies) { key(movie.id) { // Bu film için benzersiz kimlik MovieOverview(movie) } } } } . Yukarıdakilerle, listedeki öğeler değişse bile, Compose, MovieOverview’a yapılan bireysel çağrıları tanır ve bunları yeniden kullanabilir. Şekil 6. Listeye yeni bir öğe eklendiğinde MoviesScreen’in Composition’daki gösterimi. MovieOverview composablelarinin benzersiz keyleri olduğundan, Compose hangi MovieOverview instance’larının değişmediğini tanır ve bunları yeniden kullanabilir; side-effectleri execute edilmeye devam edecektir. Anahtar Nokta: Compose’un Composition’daki composable instance’ları tanımlamasına yardımcı olmak için composable key’ini kullanın. Birden fazla composable aynı call site’dan çağrıldığında ve side-effectler veya dahili state içerdiğinde bu önemlidir. Bazı composable’lar key composable için yerleşik desteğe sahiptir. Örneğin, LazyColumn items DSL’sinde özel bir key belirtilmesini kabul eder. @Composable fun MoviesScreenLazy(movies: List&lt;Movie&gt;) { LazyColumn { items(movies, key = { movie -&gt; movie.id }) { movie -&gt; MovieOverview(movie) } } } . Skipping if the inputs haven’t changed . Bir composable zaten Composition içindeyse, tüm girdiler sabitse ve değişmemişse recomposition’ı atlayabilir. Bir stabil tip aşağıdaki sözleşmeye uygun olmalıdır: . | İki instance için equals sonucu, aynı iki instance için sonsuza kadar aynı olacaktır. | Türün bir public property’si değişirse, Composition bilgilendirilecektir. | Tüm public property türleri de stabildir. | . Bu sözleşmeye giren ve @Stable annotation’ı kullanılarak açıkça stable olarak işaretlenmemiş olsalar bile compose derleyicisinin stable olarak ele alacağı bazı önemli yaygın tipler vardır: . | Tüm primitif değer türleri: Boolean, Int, Long, Float, Char, etc. | Stringler | Tüm Fonksiyon türleri (lambdalar) | . Tüm bu tipler stable sözleşmesini takip edebilirler çünkü immutable’dırlar. Immutable tipler asla değişmediğinden, Composition’a değişikliği bildirmek zorunda kalmazlar, bu nedenle bu sözleşmeyi takip etmek çok daha kolaydır. Not: Tüm deeply immutable tipler güvenli bir şekilde stable tipler olarak kabul edilebilir. Stable ancak mutable olan dikkate değer bir tür Compose’un MutableState türüdür. Bir MutableState içinde bir değer tutulursa, Compose State’in .value property’sindeki herhangi bir değişiklikten haberdar edileceğinden, state nesnesinin genel olarak stable olduğu kabul edilir. Bir composable’a parametre olarak aktarılan tüm türler stable olduğunda, parametre değerleri UI ağacındaki composable konumuna göre eşitlik açısından karşılaştırılır. Önceki çağrıdan bu yana tüm değerler değişmemişse recomposition atlanır. Anahtar Nokta: Compose, tüm girdiler stable ise ve değişmemişse bir composable’ın recomposition’ını atlar. Karşılaştırma equals metodunu kullanır. Compose bir türü yalnızca bunu kanıtlayabiliyorsa stable olarak kabul eder. Örneğin, bir interface genellikle stable olarak değerlendirilmez ve implementasyonu immutable olabilen mutable public property’lere sahip tipler de stable değildir. Compose bir türün stable olduğu sonucunu çıkaramıyorsa, ancak Compose’u onu stable olarak ele almaya zorlamak istiyorsanız, @Stable annotation’ı ile işaretleyin. // Atlama ve akıllı recompositionları desteklemek için tipin stable olarak işaretlenmesi. @Stable interface UiState&lt;T : Result&lt;T&gt;&gt; { val value: T? val exception: Throwable? val hasError: Boolean get() = exception != null } . Yukarıdaki kod parçasında, UiState bir interface olduğundan, Compose normalde bu tipin stable olmadığını düşünebilir. Stable annotation’ını ekleyerek, Compose’a bu türün stable olduğunu söylersiniz ve Compose’un akıllı recomposition’ları tercih etmesini sağlarsınız. Bu aynı zamanda, interface’in parametre türü olarak kullanılması durumunda Compose’un tüm uygulamalarını stable olarak değerlendireceği anlamına gelir. Önemli Nokta: Compose bir türün stabilitesini çıkaramıyorsa, Compose’un akıllı rekompozisyonları tercih etmesine izin vermek için türe @Stable ile annotation ekleyin. ",
    "url": "/docs/jetpack-compose/ui-architecture/lifecycle/#anatomy-of-a-composable-in-composition",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/lifecycle/#anatomy-of-a-composable-in-composition"
  },"183": {
    "doc": "Lifecycle",
    "title": "Lifecycle",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/lifecycle/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/lifecycle/"
  },"184": {
    "doc": "List of modifiers",
    "title": "List of modifiers",
    "content": "Bu sayfa surekli guncellendigi icin bu link uzerinden takip edebilirsiniz: List of Compose modifieers . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/list-of-modifiers/",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/list-of-modifiers/"
  },"185": {
    "doc": "LiveData",
    "title": "LiveData",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/livedata/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/livedata/"
  },"186": {
    "doc": "About paging",
    "title": "About paging",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/load-and-display-paged-data/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/load-and-display-paged-data/"
  },"187": {
    "doc": "Load page data",
    "title": "Load page data",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/load-page-data/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/load-page-data/"
  },"188": {
    "doc": "Loaders",
    "title": "Loaders",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/loaders/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/loaders/"
  },"189": {
    "doc": "Localization",
    "title": "Localization",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/localization/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/localization/"
  },"190": {
    "doc": "Localize your app",
    "title": "Localize your app",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/localize-your-app/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/localize-your-app/"
  },"191": {
    "doc": "Manage and present loading states",
    "title": "Manage and present loading states",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/manage-and-present-loading-states/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/manage-and-present-loading-states/"
  },"192": {
    "doc": "Manage shortcuts",
    "title": "Manage shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/manage-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/manage-shortcuts/"
  },"193": {
    "doc": "Managing State",
    "title": "Managing State",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/managing-state/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/managing-state/"
  },"194": {
    "doc": "Manual dependency injection",
    "title": "Manual dependency injection",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/manual-dependency-injection/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/manual-dependency-injection/"
  },"195": {
    "doc": "Layout",
    "title": "Layout",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/menu/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/menu/"
  },"196": {
    "doc": "Migrate from Kotlin Synthetics to View Binding",
    "title": "Migrate from Kotlin Synthetics to View Binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/migrate-from-kotlin-synthetics-to-view-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/migrate-from-kotlin-synthetics-to-view-binding/"
  },"197": {
    "doc": "Migrate to Paging 3",
    "title": "Migrate to Paging 3",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/migrate-to-paging-3/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/migrate-to-paging-3/"
  },"198": {
    "doc": "Migrate to the Navigation component",
    "title": "Migrate to the Navigation component",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/migrate-to-the-nanvigation-component/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/migrate-to-the-nanvigation-component/"
  },"199": {
    "doc": "Migrating from Firebase JobDispatcher",
    "title": "Migrating from Firebase JobDispatcher",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-firebase-jobdispatcher/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-firebase-jobdispatcher/"
  },"200": {
    "doc": "Migrating from GCMNetworkManager",
    "title": "Migrating from GCMNetworkManager",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-gcmnetworkmanager/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-gcmnetworkmanager/"
  },"201": {
    "doc": "Modifiers",
    "title": "Compose modifiers",
    "content": "Modifier’lar bir composable’ı süslemenizi veya güçlendirmenizi sağlar. Modifier’lar şu tür şeyleri yapmanıza izin verir: . | Composable’ın boyutunu, layout’unu, davranışını ve görünümünü değiştirme | Erişilebilirlik etiketleri gibi bilgiler ekleyin | Kullanıcı girdisini işleme | Bir öğeyi tıklanabilir, kaydırılabilir, sürüklenebilir veya yakınlaştırılabilir yapmak gibi üst düzey etkileşimler ekleyin | . Modifier’lar standart Kotlin nesneleridir. Modifier sınıfı fonksiyonlarından birini çağırarak bir modifier oluşturun: . @Composable private fun Greeting(name: String) { Column(modifier = Modifier.padding(24.dp)) { Text(text = \"Hello,\") Text(text = name) } } . Bu fonksiyonları birleştirerek bir araya(compose) getirebilirsiniz: . @Composable private fun Greeting(name: String) { Column( modifier = Modifier .padding(24.dp) .fillMaxWidth() ) { Text(text = \"Hello,\") Text(text = name) } } . Yukarıdaki kodda, birlikte kullanılan farklı modifier fonksiyonlarına dikkat edin. | padding bir öğenin etrafına boşluk koyar. | fillMaxWidth, composable’ın parent’ından kendisine verilen maksimum genişliği doldurmasını sağlar. | . Tüm Composable’larınızın bir modifier parametresi kabul etmesi ve bu modifier’ı UI yayan ilk child’ına aktarması en iyi pratiktir. Bunu yapmak kodunuzu daha yeniden kullanılabilir hale getirir ve davranışını daha öngörülebilir ve sezgisel kılar. Daha fazla bilgi için Compose API yönergelerine, Elements accept and respect a Modifier parametresine bakın. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#compose-modifiers",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#compose-modifiers"
  },"202": {
    "doc": "Modifiers",
    "title": "Order of modifiers matters",
    "content": "Modifier fonksiyonlarının sırası önemlidir. Her fonksiyon bir önceki fonksiyon tarafından döndürülen Modifier üzerinde değişiklik yaptığından, sıra nihai sonucu etkiler. Bunun bir örneğini görelim: . @Composable fun ArtistCard(/*...*/) { val padding = 16.dp Column( Modifier .clickable(onClick = onClick) .padding(padding) .fillMaxWidth() ) { // rest of the implementation } } . Yukarıdaki kodda, padding modifieri clickable modifierinden sonra uygulandığından, çevreleyen dolgu dahil olmak üzere tüm alan tıklanabilirdir. Modifier’ların sırası tersine çevrilirse, padding tarafından eklenen boşluk kullanıcı girişine tepki vermez: . @Composable fun ArtistCard(/*...*/) { val padding = 16.dp Column( Modifier .padding(padding) .clickable(onClick = onClick) .fillMaxWidth() ) { // rest of the implementation } } . Not: Belirgin sıralama, farklı modifier’ların nasıl etkileşime gireceği konusunda mantık yürütmenize yardımcı olur. Bunu, kutu modelini öğrenmek zorunda kaldığınız, kenar boşluklarının öğenin “dışına” uygulandığı ancak “içine” dolgu uygulandığı ve bir arka plan öğesinin buna göre boyutlandırılacağı view tabanlı sistemle karşılaştırın. Modifier tasarımı bu tür davranışları açık ve öngörülebilir hale getirir ve tam olarak istediğiniz davranışı elde etmek için size daha fazla kontrol sağlar. Bu aynı zamanda neden bir margin modifier değil de sadece bir padding modifier olduğunu da açıklar. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#order-of-modifiers-matters",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#order-of-modifiers-matters"
  },"203": {
    "doc": "Modifiers",
    "title": "Built-in modifiers",
    "content": "Jetpack Compose, bir composable’ı dekore etmenize veya zenginleştirmenize yardımcı olmak için yerleşik modifierlarin bir listesini sunar. İşte layoutlarinizi ayarlamak için kullanacağınız bazı yaygın modifierlar. Not: Bu modifier’ların birçoğu, UI’nizin layout’unu ihtiyaç duyduğunuz şekilde düzenlemenize yardımcı olmak için tasarlanmıştır. Modifier’ların layout’unuzda nasıl çalıştığı hakkında daha fazla bilgi için Compose layout basics belgesine bakın. padding and size . Varsayılan olarak, Compose’da sağlanan layoutlar child’larını sarar. Ancak, size modifier’ını kullanarak bir boyut ayarlayabilirsiniz: . @Composable fun ArtistCard(/*...*/) { Row( modifier = Modifier.size(width = 400.dp, height = 100.dp) ) { Image(/*...*/) Column { /*...*/ } } } . Layout’un parent’ından gelen constraintleri karşılamıyorsa, belirttiğiniz boyuta itibar edilmeyebileceğini unutmayın. Gelen constraintlerden etkilenmeksizin composable boyutunun sabit olmasını istiyorsanız requiredSize modifier’ını kullanın: . @Composable fun ArtistCard(/*...*/) { Row( modifier = Modifier.size(width = 400.dp, height = 100.dp) ) { Image( /*...*/ modifier = Modifier.requiredSize(150.dp) ) Column { /*...*/ } } } . Bu örnekte, parent height 100.dp olarak ayarlanmış olsa bile, requiredSize modifier’ı öncelikli olduğu için Image’ın yüksekliği 150.dp olacaktır. Not: Layout’lar constraints’lere bağlıdır ve normalde parent bu constraints’leri child’lara aktarır. Child, constraintlere saygı göstermelidir. Ancak, kullanıcı arayüzünün gerektirdiği her zaman bu olmayabilir. Bu child davranışını atlamanın yolları vardır. Örneğin, requiredSize gibi modifier’ları doğrudan child’a geçirebilir, child’ın ebeveynden aldığı constrainte’ları override edebilir veya farklı davranışa sahip özel bir layout kullanabilirsiniz. Bir child kendi constraints’lerine uymadığında, layout sistemi bunu parent’tan gizleyecektir. Parent, child’ın genişlik ve yükseklik değerlerini parent tarafından sağlanan constraintlerde zorlanmış gibi görecektir. Layout sistemi daha sonra, child’ın kısıtlamalara uyduğu varsayımı altında, child’ı parent tarafından tahsis edilen alan içinde ortalayacaktır. Geliştiriciler, child’a wrapContentSize modifierları uygulayarak bu ortalama davranışını override edebilirler. Bir child layout’un parent tarafından izin verilen tüm yüksekliği doldurmasını istiyorsanız, fillMaxHeight modifier’ını ekleyin (Compose ayrıca fillMaxSize ve fillMaxWidth sağlar): . @Composable fun ArtistCard(/*...*/) { Row( modifier = Modifier.size(width = 400.dp, height = 100.dp) ) { Image( /*...*/ modifier = Modifier.fillMaxHeight() ) Column { /*...*/ } } } . Bir öğenin etrafına dolgu eklemek için bir padding modifier ayarlayın. Bir metin taban çizgisinin üzerine, layout’un üst kısmından taban çizgisine kadar belirli bir mesafe elde edecek şekilde dolgu eklemek istiyorsanız, paddingFromBaseline modifier’ını kullanın: . @Composable fun ArtistCard(artist: Artist) { Row(/*...*/) { Column { Text( text = artist.name, modifier = Modifier.paddingFromBaseline(top = 50.dp) ) Text(artist.lastSeenOnline) } } } . Offset . Bir layout’u orijinal konumuna göre konumlandırmak için ofset modifier’ını ekleyin ve ofseti x ve y ekseninde ayarlayın. Ofsetler pozitif olabileceği gibi pozitif olmayabilir de. Padding ve offset arasındaki fark, bir composable’a offset eklemenin onun ölçümlerini değiştirmemesidir: . @Composable fun ArtistCard(artist: Artist) { Row(/*...*/) { Column { Text(artist.name) Text( text = artist.lastSeenOnline, modifier = Modifier.offset(x = 4.dp) ) } } } . Ofset modifier’ı layout yönüne göre yatay olarak uygulanır. Soldan sağa bağlamında, pozitif bir ofset öğeyi sağa kaydırırken, sağdan sola bağlamında öğeyi sola kaydırır. Layout yönünü dikkate almadan bir ofset ayarlamanız gerekiyorsa, pozitif bir ofset değerinin öğeyi her zaman sağa kaydırdığı absoluteOffset modifier’ına bakın. offset modifier iki overload sağlar - ofsetleri parametre olarak alan offset ve bir lambda alan offset. Bunların her birinin ne zaman kullanılacağı ve performans için nasıl optimize edileceği hakkında daha ayrıntılı bilgi için Compose performance - Defer reads as long as possible bölümünü okuyun. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#built-in-modifiers",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#built-in-modifiers"
  },"204": {
    "doc": "Modifiers",
    "title": "Scope safety in Compose",
    "content": "Compose’da, yalnızca belirli composable’ların child’larına uygulandığında kullanılabilen modifier’lar vardır. Compose bunu custom scopelar aracılığıyla uygular. Örneğin, bir child öğeyi Box boyutunu etkilemeden üst Box öğesi kadar büyük yapmak istiyorsanız, matchParentSize modifier’ını kullanın. matchParentSize yalnızca BoxScope içinde kullanılabilir. Bu nedenle, yalnızca bir Box parent içindeki bir child üzerinde kullanılabilir. Scope güvenliği, diğer composable’larda ve scope’larda çalışmayacak modifier’lar eklemenizi engeller ve deneme yanılma yöntemiyle zaman kazanmanızı sağlar. Not: Android View sisteminde scope safety (kapsam güvenliği) yoktur. Geliştiriciler genellikle hangilerinin dikkate alındığını ve belirli bir parent bağlamında anlamlarını keşfetmek için kendilerini farklı layout parametreleri denerken bulurlar. Scoped modifier’lar, parent’ın child hakkında bilmesi gereken bazı bilgileri parent’a bildirir. Bunlar genellikle parent data modifier’ları olarak da adlandırılır. İç yapıları genel amaçlı modifier’lardan farklıdır, ancak kullanım açısından bu farklılıklar önemli değildir. matchParentSize in Box . Yukarıda belirtildiği gibi, bir child layout’un Box boyutunu etkilemeden bir parent Box ile aynı boyutta olmasını istiyorsanız, matchParentSize modifier’ını kullanın. matchParentSize’ın yalnızca bir Box scope içinde kullanılabildiğini, yani yalnızca Box composables’ın doğrudan child’ları için geçerli olduğunu unutmayın. Aşağıdaki örnekte, Spacer child öğesi boyutunu Parent Box öğesinden alır, o da boyutunu en büyük child öğesinden (bu durumda ArtistCard öğesinden) alır. @Composable fun MatchParentSizeComposable() { Box { Spacer( Modifier .matchParentSize() .background(Color.LightGray) ) ArtistCard() } } . matchParentSize yerine fillMaxSize kullanılsaydı, Spacer parent’a izin verilen tüm boş alanı alacak ve bu da parent’ın genişlemesine ve tüm boş alanı doldurmasına neden olacaktı. weight in Row and Column . Padding ve size ile ilgili önceki bölümde gördüğünüz gibi, varsayılan olarak, bir composable size sardığı içerik tarafından tanımlanır. Yalnızca RowScope ve ColumnScope’ta kullanılabilen ağırlık Modifier’ını kullanarak composable size’ı parent’ı içinde esnek olacak şekilde ayarlayabilirsiniz. İki Box composable içeren bir Row’u ele alalım. İlk Box’a ikincisinin iki katı weight verildiğinden genişliği de iki katına çıkar. Row 210.dp genişliğinde olduğundan, ilk Box 140.dp genişliğinde ve ikincisi 70.dp genişliğindedir: . @Composable fun ArtistCard(/*...*/) { Row( modifier = Modifier.fillMaxWidth() ) { Image( /*...*/ modifier = Modifier.weight(2f) ) Column( modifier = Modifier.weight(1f) ) { /*...*/ } } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#scope-safety-in-compose",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#scope-safety-in-compose"
  },"205": {
    "doc": "Modifiers",
    "title": "Extracting and reusing modifiers",
    "content": "Bir composable’ı dekore etmek veya zenginleştirmek için birden fazla modifier birbirine zincirlenebilir. Bu zincir, tek Modifier.Elements‘in sıralı, değişmez bir listesini temsil eden Modifier interface’i aracılığıyla oluşturulur. Her Modifier.Element, layout, çizim ve grafik davranışları, jestle ilgili tüm davranışlar, odak ve semantik davranışlarının yanı sıra cihaz giriş olayları gibi ayrı bir davranışı temsil eder. Bunların sıralaması önemlidir: ilk eklenen modifier öğeleri ilk olarak uygulanacaktır. Bazen aynı modifier zinciri örneklerini değişkenlere ayıklayarak ve daha yüksek kapsamlara taşıyarak birden fazla composable’da yeniden kullanmak faydalı olabilir. Bu, kodun okunabilirliğini artırabilir veya birkaç nedenden dolayı uygulamanızın performansını iyileştirmeye yardımcı olabilir: . | Modifier’ların yeniden tahsisi, bunları kullanan composable’lar için recomposition gerçekleştiğinde tekrarlanmayacaktır | Modifier zincirleri potansiyel olarak çok uzun ve karmaşık olabilir, bu nedenle bir zincirin aynı örneğini yeniden kullanmak Compose çalışma zamanının bunları karşılaştırırken yapması gereken iş yükünü hafifletebilir | Bu ayıklama kod tabanı genelinde kod temizliğini, tutarlılığı ve sürdürülebilirliği teşvik eder | . Best practices for reusing modifiers . Kendi Modifier zincirlerinizi oluşturun ve bunları birden fazla composable bileşen üzerinde yeniden kullanmak için ayıklayın. Veri benzeri nesneler oldukları için bir modifier’ı sadece kaydetmek tamamen iyidir: . val reusableModifier = Modifier .fillMaxWidth() .background(Color.Red) .padding(12.dp) . Extracting and reusing modifiers when observing frequently changing state . Animasyon state’leri veya scrollState gibi composable’lar içinde sık değişen state’leri gözlemlerken, önemli miktarda recomposition yapılabilir. Bu durumda, modifier’larınız her recomposition’da ve potansiyel olarak her frame için tahsis edilecektir: . @Composable fun LoadingWheelAnimation() { val animatedState = animateFloatAsState(/*...*/) LoadingWheel( // Bu modifier'ın oluşturulması ve tahsisi animasyonun her karesinde gerçekleşecektir! modifier = Modifier .padding(12.dp) .background(Color.Gray), animatedState = animatedState ) } . Bunun yerine, modifier’ın aynı instance’ını oluşturabilir, ayıklayabilir ve yeniden kullanabilir ve bu şekilde composable’a aktarabilirsiniz: . // Şimdi, modifier'ın tahsisi burada gerçekleşir: val reusableModifier = Modifier .padding(12.dp) .background(Color.Gray) @Composable fun LoadingWheelAnimation() { val animatedState = animateFloatAsState(/*...*/) LoadingWheel( // Aynı instance'ı tekrar kullandığımız için tahsis yok modifier = reusableModifier, animatedState = animatedState ) } . Extracting and reusing unscoped modifiers . Modifier’lar scope edilmemiş veya belirli bir composable’a scop edilmiş olabilir. Scope edilmemiş modifier’lar söz konusu olduğunda, bunları basit değişkenler olarak herhangi bir composable’ın dışına kolayca çıkarabilirsiniz: . val reusableModifier = Modifier .fillMaxWidth() .background(Color.Red) .padding(12.dp) @Composable fun AuthorField() { HeaderText( // ... modifier = reusableModifier ) SubtitleText( // ... modifier = reusableModifier ) } . Bu, özellikle Lazy layout’ları ile birlikte kullanıldığında faydalı olabilir. Çoğu durumda, potansiyel olarak önemli miktarda olan tüm öğelerinizin tam olarak aynı modifier’lara sahip olmasını istersiniz: . val reusableItemModifier = Modifier .padding(bottom = 12.dp) .size(216.dp) .clip(CircleShape) @Composable private fun AuthorList(authors: List&lt;Author&gt;) { LazyColumn { items(authors) { AsyncImage( // ... modifier = reusableItemModifier, ) } } } . Extracting and reusing scoped modifiers . Belirli composable’lara scope edilmiş değiştiricilerle uğraşırken, bunları mümkün olan en yüksek seviyeye taşıyabilir ve uygun olan yerlerde yeniden kullanabilirsiniz: . Column(/*...*/) { val reusableItemModifier = Modifier .padding(bottom = 12.dp) // Align Modifier.Element bir ColumnScope gerektirir .align(Alignment.CenterHorizontally) .weight(1f) Text1( modifier = reusableItemModifier, // ... ) Text2( modifier = reusableItemModifier // ... ) // ... } . Çıkarılan, scope edilmiş modifier’ları yalnızca aynı scope edilmiş, doğrudan child’lara aktarmalısınız. Bunun neden önemli olduğu hakkında daha fazla bilgi için Compose’da Scope safety bölümüne bakın: . Column(modifier = Modifier.fillMaxWidth()) { // Weight modifier is scoped to the Column composable val reusableItemModifier = Modifier.weight(1f) // Weight will be properly assigned here since this Text is a direct child of Column Text1( modifier = reusableItemModifier // ... ) Box { Text2( // Weight won't do anything here since the Text composable is not a direct child of Column modifier = reusableItemModifier // ... ) } } . Further chaining of extracted modifiers . Çıkarılan modifier zincirlerinizi .then() fonksiyonunu çağırarak daha fazla zincirleyebilir veya ekleyebilirsiniz: . val reusableModifier = Modifier .fillMaxWidth() .background(Color.Red) .padding(12.dp) // Append to your reusableModifier reusableModifier.clickable { /*...*/ } // Append your reusableModifier otherModifier.then(reusableModifier) . Sadece modifierlerin sırasının önemli olduğunu unutmayın! . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#extracting-and-reusing-modifiers",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#extracting-and-reusing-modifiers"
  },"206": {
    "doc": "Modifiers",
    "title": "Learn more",
    "content": "Parametreleri ve scopelari ile birlikte modifier’ların tam bir listesini sunuyoruz. Modifier’ların nasıl kullanılacağı hakkında daha fazla pratik yapmak için Compose codelab’deki Basic layouts‘u inceleyebilir veya Now in Android repository’ye başvurabilirsiniz. Custom modifier’lar ve bunların nasıl oluşturulacağı hakkında daha fazla bilgi için Custom layouts - Using the layout modifier belgesine göz atın. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#learn-more",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/#learn-more"
  },"207": {
    "doc": "Modifiers",
    "title": "Modifiers",
    "content": " ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/modifiers/"
  },"208": {
    "doc": "Modularization",
    "title": "Modularization",
    "content": " ",
    "url": "/docs/app-architecture/modularization/modularization/",
    
    "relUrl": "/docs/app-architecture/modularization/modularization/"
  },"209": {
    "doc": "More types",
    "title": "More types",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/more-types/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/more-types/"
  },"210": {
    "doc": "Navigate to a destination",
    "title": "Navigate to a destination",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/navigate-to-a-destination/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/navigate-to-a-destination/"
  },"211": {
    "doc": "Navigate with feature modules",
    "title": "Navigate with feature modules",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/navigate-with-feature-modules/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/navigate-with-feature-modules/"
  },"212": {
    "doc": "Navigation component",
    "title": "Navigation component",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/navigation-component/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/navigation-component/"
  },"213": {
    "doc": "Navigation",
    "title": "Navigation",
    "content": " ",
    "url": "/docs/app-architecture/modularization/navigation/",
    
    "relUrl": "/docs/app-architecture/modularization/navigation/"
  },"214": {
    "doc": "Navigation",
    "title": "Navigating with Compose",
    "content": "Navigation komponenti Jetpack Compose uygulamaları için destek sağlar. Navigation komponentinin altyapısından ve özelliklerinden yararlanırken composable’lar arasında gezinebilirsiniz. Not: Compose hakkında bilgi sahibi değilseniz, devam etmeden önce Jetpack Compose kaynaklarını inceleyin. ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#navigating-with-compose",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#navigating-with-compose"
  },"215": {
    "doc": "Navigation",
    "title": "Setup",
    "content": "Compose’u desteklemek için, uygulama modülünüzün `build.gradle’ dosyasında aşağıdaki bağımlılığı kullanın: . dependencies { def nav_version = \"2.5.3\" implementation \"androidx.navigation:navigation-compose:$nav_version\" } . ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#setup",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#setup"
  },"216": {
    "doc": "Navigation",
    "title": "Getting Started",
    "content": "NavController, Navigasyon komponenti için merkezi API’dir. Stateful’dur ve uygulamanızdaki ekranları oluşturan composable’ların back stack’ini ve her bir ekranın state’ini takip eder. composable’ınızda rememberNavController() metodunu kullanarak bir NavController oluşturabilirsiniz: . val navController = rememberNavController() . NavController‘ı, composable hiyerarşinizde ona referans vermesi gereken tüm composable’ların erişebileceği bir yerde oluşturmalısınız. Bu, state hoisting ilkelerini takip eder ve NavController’ı ve currentBackStackEntryAsState() aracılığıyla sağladığı state’i, ekranlarınızın dışındaki composable’ları güncellemek için doğruluk kaynağı olarak kullanmanıza olanak tanır. Bu işlevselliğin bir örneği için Bottom Navbar ile Entegrasyon bölümüne bakın. Not: Fragmentler için Navigation component kullanıyorsanız, Compose’da yeni navigasyon grafikleri tanımlamanız veya NavHost composables kullanmanız gerekmez. Daha fazla bilgi için Birlikte Çalışabilirlik bölümüne bakın. ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#getting-started",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#getting-started"
  },"217": {
    "doc": "Navigation",
    "title": "Creating a NavHost",
    "content": "Her NavController tek bir NavHost composable ile ilişkilendirilmelidir. NavHost, NavController’ı aralarında gezinebileceğiniz composable hedefleri belirten bir navigasyon grafiğine bağlar. Composable’lar arasında gezinirken, NavHost’un içeriği otomatik olarak yeniden oluşturulur. Navigasyon grafiğinizdeki her bir composable hedef bir route ile ilişkilendirilir. Anahtar Terim: Route, composable’ınıza giden yolu tanımlayan bir String’dir. Bunu, belirli bir hedefe götüren örtük bir deep link olarak düşünebilirsiniz. Her hedefin benzersiz bir route’u olmalıdır. NavHost’un oluşturulması için daha önce rememberNavController() aracılığıyla oluşturulan NavController ve grafiğinizin başlangıç hedefinin route’u gerekir. NavHost oluşturma, navigasyon grafiğinizi oluşturmak için Navigation Kotlin DSL‘deki lambda sentaksını kullanır. composable() metodunu kullanarak navigasyon yapınıza eklemeler yapabilirsiniz. Bu yöntem, bir route ve hedefe bağlanması gereken composable’ı sağlamanızı gerektirir: . NavHost(navController = navController, startDestination = \"profile\") { composable(\"profile\") { Profile(/*...*/) } composable(\"friendslist\") { FriendsList(/*...*/) } /*...*/ } . Not: Navigasyon Komponenti, Navigasyon İlkelerine uymanızı ve sabit bir başlangıç hedefi kullanmanızı gerektirir. startDestination route için composable bir değer kullanmamalısınız. ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#creating-a-navhost",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#creating-a-navhost"
  },"218": {
    "doc": "Navigation",
    "title": "Navigate to a composable",
    "content": "Navigasyon grafiğinde composable bir hedefe gitmek için navigate metodunu kullanmanız gerekir. navigate, hedefin route’unu temsil eden tek bir String parametresi alır. Navigasyon grafiği içindeki bir composable’dan navigasyon yapmak için navigate‘i çağırın: . navController.navigate(\"friendslist\") . Varsayılan olarak, navigate yeni hedefinizi back stack’e ekler. navigate() çağrımıza ek navigasyon seçenekleri ekleyerek navigate’in davranışını değiştirebilirsiniz: . // \"friendslist\" hedefine gitmeden önce her şeyi back stack'ten \"home\" // hedefine kadar cikarin(pop) navController.navigate(\"friendslist\") { popUpTo(\"home\") } // \"friendslist\" hedefine gitmeden önce \"home\" hedefine kadar ve \"home\" hedefi de dahil olmak üzere her şeyi back stack'ten çıkarın(pop edin) navController.navigate(\"friendslist\") { popUpTo(\"home\") { inclusive = true } } // \"search\" hedefine yalnızca zaten \"search\" hedefinde değilsek gidin, // böylece back stack'in tepesinde birden fazla kopyadan kaçınmış oluruz navController.navigate(\"search\") { launchSingleTop = true } . Daha fazla kullanım örneği için popUpTo kılavuzuna bakın. Not: Animasyon bloğu Navigation Compose ile kullanılamaz. Navigation Compose’daki Geçiş Animasyonları bu özellik talebinde takip edilmektedir. Navigate calls triggered by other composable functions . NavControllerın navigate fonksiyonu, NavControllerın dahili state’ini değiştirir. Tek doğruluk kaynağı ilkesine mümkün olduğunca uymak için, yalnızca NavController instance’ını hoist eden composable fonksiyon veya state holder ve NavController’ı parametre olarak alan composable fonksiyonlar navigasyon çağrıları yapmalıdır. UI hiyerarşisinde daha aşağıda yer alan diğer composable fonksiyonlardan tetiklenen navigasyon event’lerinin, fonksiyonları kullanarak bu event’leri arayan kişiye uygun şekilde göstermesi gerekir. Aşağıdaki örnekte, NavController instance’ı için tek doğruluk kaynağı olarak MyAppNavHost composable fonksiyonu gösterilmektedir. ProfileScreen bir event’i, kullanıcı bir button’a dokunduğunda çağrılan bir fonksiyon olarak sunar. Uygulamadaki farklı ekranlarda gezinmenin sorumlusu olan MyAppNavHost, ProfileScreen‘i çağırırken doğru hedefe navigasyon çağrısı yapar. @Composable fun MyAppNavHost( modifier: Modifier = Modifier, navController: NavHostController = rememberNavController(), startDestination: String = \"profile\" ) { NavHost( modifier = modifier, navController = navController, startDestination = startDestination ) { composable(\"profile\") { ProfileScreen( onNavigateToFriends = { navController.navigate(\"friendsList\") }, /*...*/ ) } composable(\"friendslist\") { FriendsListScreen(/*...*/) } } } @Composable fun ProfileScreen( onNavigateToFriends: () -&gt; Unit, /*...*/ ) { /*...*/ Button(onClick = onNavigateToFriends) { Text(text = \"See friends list\") } } . Her recomposition’da navigate() fonksiyonunu çağırmaktan kaçınmak için navigate() fonksiyonunu composable’ınızın bir parçası olarak değil, sadece bir callback’in parçası olarak çağırmalısınız. Best Practices . Uygulamadaki belirli bir mantığın nasıl işleneceğini bilen caller’lara composable fonksiyonlardan event’leri göstermek, Compose’da state’i hoist ederken iyi bir pratiktir. Eventleri ayrı lambda parametreleri olarak göstermek fonksiyon imzasını overload edebilecek olsa da, composable fonksiyon sorumluluklarının ne olduğunun görünürlüğünü maksimize eder. Bir bakışta ne yaptığını görebilirsiniz. Fonksiyon bildirimindeki parametre sayısını azaltabilecek diğer alternatifler başlangıçta daha rahat yazılabilir ancak uzun vadede bazı dezavantajları gizleyebilir. Örneğin, tüm eventleri tek bir yerde merkezileştiren ProfileScreenEvents gibi bir sarmalayıcı sınıf oluşturmak. Bunu yapmak, fonksiyon tanımından geçerken composable’ın ne yaptığının görünürlüğünü azaltır, proje sayınıza başka bir sınıf ve metot ekler ve zaten bu composable fonksiyonunu her çağırdığınızda bu sınıfın instance’larını oluşturmanız ve hatırlamanız gerekir. Ayrıca, bu sarmalayıcı sınıfı mümkün olduğunca yeniden kullanmak için, bu model, composable’lara sadece ihtiyaç duyduklarını iletmek gibi en iyi pratik yerine, bu sınıfın bir instance’ını UI hiyerarşisinde aşağıya doğru geçirmeyi teşvik eder. ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#navigate-to-a-composable",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#navigate-to-a-composable"
  },"219": {
    "doc": "Navigation",
    "title": "Navigate with arguments",
    "content": "Navigation Compose, composable hedefler arasında argüman aktarımını da destekler. Bunu yapmak için, temel navigasyon kütüphanesini kullanırken bir deep linke argüman eklediğinize benzer şekilde rotanıza argüman yer tutucuları eklemeniz gerekir: . NavHost(startDestination = \"profile/{userId}\") { ... composable(\"profile/{userId}\") {...} } . Varsayılan olarak, tüm argümanlar string olarak ayrıştırılır. composable() metodunun arguments parametresi bir NamedNavArguments listesi kabul eder. navArgument metodunu kullanarak hızlı bir şekilde bir NamedNavArgument oluşturabilir ve ardından tam tipini belirtebilirsiniz: . NavHost(startDestination = \"profile/{userId}\") { ... composable( \"profile/{userId}\", arguments = listOf(navArgument(\"userId\") { type = NavType.StringType }) ) {...} } . Argümanları composable() lambda’sında bulunan NavBackStackEntry‘den çıkarmalısınız. composable(\"profile/{userId}\") { backStackEntry -&gt; Profile(navController, backStackEntry.arguments?.getString(\"userId\")) } . Argümanı hedefe iletmek için, navigate çağrısını yaptığınızda rotaya eklemeniz gerekir: . navController.navigate(\"profile/user1234\") . Desteklenen türlerin listesi için Hedefler arasında veri aktarma bölümüne bakın. Retrieving complex data when navigating . Navigasyon sırasında kompleks veri nesnelerinin aktarılmaması, bunun yerine navigasyon eylemleri gerçekleştirilirken benzersiz bir tanımlayıcı veya başka bir ID biçimi gibi gerekli minimum bilgilerin argüman olarak aktarılması şiddetle tavsiye edilir: . // Yeni bir hedefe giderken argüman olarak yalnızca kullanıcı ID'sini geçirin navController.navigate(\"profile/user1234\") . Kompleks nesneler, data katmanı gibi tek bir doğruluk kaynağında veri olarak saklanmalıdır. Navigasyondan sonra hedefinize ulaştığınızda, aktarılan ID’yi kullanarak tek bir doğruluk kaynağından gerekli bilgileri yükleyebilirsiniz. Data katmanına erişmekten sorumlu olan ViewModel’inizdeki argümanları almak için ViewModel’in SavedStateHandle‘ını kullanabilirsiniz: . class UserViewModel( savedStateHandle: SavedStateHandle, private val userInfoRepository: UserInfoRepository ) : ViewModel() { private val userId: String = checkNotNull(savedStateHandle[\"userId\"]) // İletilen userId argümanına dayalı olarak data katmanından, // yani userInfoRepository'den ilgili kullanıcı bilgilerini getirin private val userInfo: Flow&lt;UserInfo&gt; = userInfoRepository.getUserInfo(userId) // … } . Bu yaklaşım, konfigürasyon değişiklikleri sırasında veri kaybını ve söz konusu nesne güncellenirken veya mutasyona uğrarken oluşabilecek tutarsızlıkları önlemeye yardımcı olur. Kompleks verileri argüman olarak geçirmekten neden kaçınmanız gerektiğine dair daha ayrıntılı bir açıklama ve desteklenen argüman türlerinin bir listesi için bkz. Hedefler arasında veri aktarma. Adding optional arguments . Navigation Compose isteğe bağlı navigasyon argümanlarını da destekler. İsteğe bağlı argümanlar, gerekli argümanlardan iki şekilde farklıdır: . | Sorgu parametresi sentaksı kullanılarak dahil edilmelidirler (\"?argName={argName}\") . | Bir defaultValue ayarına sahip olmalı veya nullable = true (varsayılan değeri dolaylı olarak null olarak ayarlar) olmalıdır . | . Bu, tüm isteğe bağlı argümanların composable() fonksiyonuna bir liste olarak açıkça eklenmesi gerektiği anlamına gelir: . composable( \"profile?userId={userId}\", arguments = listOf(navArgument(\"userId\") { defaultValue = \"user1234\" }) ) { backStackEntry -&gt; Profile(navController, backStackEntry.arguments?.getString(\"userId\")) } . Artık, hedefe herhangi bir argüman iletilmese bile, bunun yerine defaultValue, \"user1234\" kullanılır. Argümanları rotalar aracılığıyla ele alma yapısı, composable’larınızın Navigation’dan tamamen bağımsız kalması anlamına gelir ve onları çok daha test edilebilir hale getirir. ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#navigate-with-arguments",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#navigate-with-arguments"
  },"220": {
    "doc": "Navigation",
    "title": "Deep links",
    "content": "Navigation Compose, composable() fonksiyonunun bir parçası olarak tanımlanabilen örtük deeplink’leri de destekler. deepLinks parametresi, navDeepLink metodu kullanılarak hızlı bir şekilde oluşturulabilen NavDeepLinks listesini kabul eder: . val uri = \"https://www.example.com\" composable( \"profile?id={id}\", deepLinks = listOf(navDeepLink { uriPattern = \"$uri/{id}\" }) ) { backStackEntry -&gt; Profile(navController, backStackEntry.arguments?.getString(\"id\")) } . Bu deep linkler belirli bir URL’yi, action’ı veya mime tipini composable ile ilişkilendirmenizi sağlar. Varsayılan olarak, bu deep linkler harici uygulamalara açık değildir. Bu deep linkleri harici olarak kullanılabilir hale getirmek için uygulamanızın manifest.xml dosyasına uygun &lt;intent-filter&gt; öğelerini eklemeniz gerekir. Yukarıdaki deep link’i etkinleştirmek için manifest’in &lt;activity&gt; elementinin içine aşağıdakileri eklemelisiniz: . &lt;activity …&gt; &lt;intent-filter&gt; ... &lt;data android:scheme=\"https\" android:host=\"www.example.com\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; . Navigasyon, deep link başka bir uygulama tarafından tetiklendiğinde otomatik olarak o composable’a deep link verir. Aynı deep linkler, bir composable’dan uygun deep link ile bir PendingIntent oluşturmak için de kullanılabilir: . val id = \"exampleId\" val context = LocalContext.current val deepLinkIntent = Intent( Intent.ACTION_VIEW, \"https://www.example.com/$id\".toUri(), context, MyActivity::class.java ) val deepLinkPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run { addNextIntentWithParentStack(deepLinkIntent) getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT) } . Daha sonra uygulamanızı deeplink hedefinde açmak için bu deepLinkPendingIntent‘i diğer PendingIntent‘ler gibi kullanabilirsiniz. ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#deep-links",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#deep-links"
  },"221": {
    "doc": "Navigation",
    "title": "Nested Navigation",
    "content": "Hedefler, uygulamanızın UI’sindeki belirli bir akışı modülerleştirmek için iç içe geçmiş bir grafikte (nested graph) gruplandırılabilir. Bunun bir örneği, kendi kendine çalışan bir oturum açma akışı olabilir. İç içe grafik(nested graph), hedeflerini encapsulate eder. Root grafiğinde(root graph) olduğu gibi, iç içe geçmiş bir grafiğin de rotası tarafından başlangıç hedefi olarak tanımlanan bir hedefi olmalıdır. Bu, iç içe grafikle ilişkili rotaya gittiğinizde gidilen hedeftir. NavHost’unuza iç içe bir grafik eklemek için navigation extension fonksiyonunu kullanabilirsiniz: . NavHost(navController, startDestination = \"home\") { ... // Grafiğe otomatik olarak rotası ('login') üzerinden gitmek için // grafiğin başlangıç hedefine gider - 'username' // Bu nedenle grafiğin dahili rota belirleme mantığını enkapsüle eder navigation(startDestination = \"username\", route = \"login\") { composable(\"username\") { ... } composable(\"password\") { ... } composable(\"registration\") { ... } } ... } . Grafiğin boyutu büyüdükçe navigasyon grafiğinizi birden fazla metoda bölmeniz şiddetle tavsiye edilir. Bu aynı zamanda birden fazla modülün kendi navigasyon grafiklerine katkıda bulunmasına olanak tanır. fun NavGraphBuilder.loginGraph(navController: NavController) { navigation(startDestination = \"username\", route = \"login\") { composable(\"username\") { ... } composable(\"password\") { ... } composable(\"registration\") { ... } } } . Metodu NavGraphBuilder üzerinde bir extension metodu haline getirerek, önceden oluşturulmuş navigasyon, composable ve dialog extension metotlarının yanında kullanabilirsiniz: . NavHost(navController, startDestination = \"home\") { ... loginGraph(navController) ... } . ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#nested-navigation",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#nested-navigation"
  },"222": {
    "doc": "Navigation",
    "title": "Integration with the bottom nav bar",
    "content": "NavController‘ı composable hiyerarşinizde daha yüksek bir seviyede tanımlayarak Navigation’ı bottom navigation component gibi diğer componentlere bağlayabilirsiniz. Bunu yapmak, bottom bardaki ikonları seçerek navigasyon yapmanızı sağlar. BottomNavigation ve BottomNavigationItem komponentlerini kullanmak için Android uygulamanıza androidx.compose.material bağımlılığını ekleyin. dependencies { implementation \"androidx.compose.material:material:1.4.3\" } android { buildFeatures { compose true } composeOptions { kotlinCompilerExtensionVersion = \"1.4.7\" } kotlinOptions { jvmTarget = \"1.8\" } } . Bottom navigation bar’daki öğeleri navigasyon grafiğinizdeki rotalara bağlamak için, burada görülen Screen gibi, hedefler için rota ve String resource ID’sini içeren bir sealed sınıf tanımlamanız önerilir. sealed class Screen(val route: String, @StringRes val resourceId: Int) { object Profile : Screen(\"profile\", R.string.profile) object FriendsList : Screen(\"friendslist\", R.string.friends_list) } . Ardından bu öğeleri BottomNavigationItem tarafından kullanılabilecek bir listeye yerleştirin: . val items = listOf( Screen.Profile, Screen.FriendsList, ) . BottomNavigation composable’ınızda, currentBackStackEntryAsState() fonksiyonunu kullanarak şu anki NavBackStackEntry’yi alın. Bu girdi size geçerli NavDestination’a erişim sağlar. Her BottomNavigationItem öğesinin seçili state’i daha sonra NavDestination hiyerarşisi aracılığıyla öğenin rotası geçerli hedefin ve onun üst hedeflerinin (iç içe navigasyon kullandığınız durumları ele almak için) rotasıyla karşılaştırılarak belirlenebilir. Öğenin rotası aynı zamanda onClick lambda’sını navigasyon çağrısına bağlamak için de kullanılır, böylece öğeye dokunulduğunda o öğeye gidilir. saveState ve restoreState flag’lerini kullanarak, botttom navigation öğeleri arasında geçiş yaparken bu öğenin state’i ve back stack’i doğru şekilde kaydedilir ve geri yüklenir. val navController = rememberNavController() Scaffold( bottomBar = { BottomNavigation { val navBackStackEntry by navController.currentBackStackEntryAsState() val currentDestination = navBackStackEntry?.destination items.forEach { screen -&gt; BottomNavigationItem( icon = { Icon(Icons.Filled.Favorite, contentDescription = null) }, label = { Text(stringResource(screen.resourceId)) }, selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true, onClick = { navController.navigate(screen.route) { // Kullanıcılar öğeleri seçtikçe back stack üzerinde büyük bir // hedef stack'i oluşmasını önlemek için // grafiğin başlangıç hedefine pop edilir popUpTo(navController.graph.findStartDestination().id) { saveState = true } // Aynı öğeyi yeniden seçerken aynı hedefin birden fazla kopyasını önlemek launchSingleTop = true // Önceden seçilmiş bir öğe yeniden seçildiğinde state'i geri yüklemek restoreState = true } } ) } } } ) { innerPadding -&gt; NavHost(navController, startDestination = Screen.Profile.route, Modifier.padding(innerPadding)) { composable(Screen.Profile.route) { Profile(navController) } composable(Screen.FriendsList.route) { FriendsList(navController) } } } . Burada NavController.currentBackStackEntryAsState() metodundan yararlanarak navController state’ini NavHost fonksiyonundan çıkarır ve BottomNavigation komponentiyle paylaşırsınız. Bu, BottomNavigation‘un otomatik olarak en güncel state’e sahip olduğu anlamına gelir. ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#integration-with-the-bottom-nav-bar",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#integration-with-the-bottom-nav-bar"
  },"223": {
    "doc": "Navigation",
    "title": "Type safety in Navigation Compose",
    "content": "Type safe, multi-module best practices with Navigation Compose . Bu sayfadaki kod type-safe değildir. Navigate() fonksiyonunu mevcut olmayan rotalarla veya yanlış argümanlarla çağırabilirsiniz. Ancak, Navigasyon kodunuzu çalışma zamanında type-safe olacak şekilde yapılandırabilirsiniz. Bunu yaparak, çökmeleri önleyebilir ve şunlardan emin olabilirsiniz: . | Bir hedefe veya navigasyon grafiğine giderken sağladığınız argümanlar doğru türdedir ve gerekli tüm argümanlar mevcuttur. | SavedStateHandle’dan aldığınız argümanlar doğru türdedir. | . Bu konuda daha fazla bilgi için Navigasyon type safety belgelerine göz atın. ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#type-safety-in-navigation-compose",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#type-safety-in-navigation-compose"
  },"224": {
    "doc": "Navigation",
    "title": "Interoperability",
    "content": "Navigation component’i Compose ile kullanmak istiyorsanız iki seçeneğiniz vardır: . | Fragmentler için Navigation bileşeni ile bir navigasyon grafiği tanımlayın. | Compose hedeflerini kullanarak Compose’da bir NavHost ile bir navigasyon grafiği tanımlayın. Bu, yalnızca navigasyon grafiğindeki tüm ekranlar composable ise mümkündür. | . Bu nedenle, karma Compose ve Views uygulamaları için öneri Fragment tabanlı Navigasyon komponentini kullanmaktır. Fragmentler daha sonra View tabanlı ekranları, Compose ekranlarını ve hem Views hem de Compose kullanan ekranları tutacaktır. Her bir Fragment’ın içeriği Compose’da olduğunda, bir sonraki adım tüm bu ekranları Navigation Compose ile birbirine bağlamak ve tüm Fragment’ları kaldırmaktır. Navigate from Compose with Navigation for fragments . Compose kodu içindeki hedefleri değiştirmek için, hiyerarşideki herhangi bir composable’a aktarılabilen ve onlar tarafından tetiklenebilen event’leri açığa çıkarırsınız: . @Composable fun MyScreen(onNavigate: (Int) -&gt; ()) { Button(onClick = { onNavigate(R.id.nav_profile) } { /* ... */ } } . Fragmentinizde, NavController’ı bularak ve hedefe giderek Compose ile fragment tabanlı Navigation komponenti arasında köprü kurarsınız: . override fun onCreateView( /* ... */ ) { setContent { MyScreen(onNavigate = { dest -&gt; findNavController().navigate(dest) }) } } . Alternatif olarak, NavController’ı Compose hiyerarşinizden aşağı aktarabilirsiniz. Ancak, basit fonksiyonları açığa çıkarmak çok daha yeniden kullanılabilir ve test edilebilirdir. ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#interoperability",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#interoperability"
  },"225": {
    "doc": "Navigation",
    "title": "Testing",
    "content": "Testing the NavHost . Testing navigation actions . ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#testing",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#testing"
  },"226": {
    "doc": "Navigation",
    "title": "Learn more",
    "content": "Jetpack Navigasyon hakkında daha fazla bilgi edinmek için Navigasyon komponentini kullanmaya başlayın bölümüne bakın veya Jetpack Compose Navigation codelab‘ına katılın. Uygulamanızın navigasyonunu farklı ekran boyutlarına, yönlere ve form faktörlerine uyum sağlayacak şekilde nasıl tasarlayacağınızı öğrenmek için Responsive UI’lar için Navigasyon bölümüne bakın. İç içe grafikler ve bottom navigation bar entegrasyonu gibi kavramlar da dahil olmak üzere modülerleştirilmiş bir uygulamada daha gelişmiş Navigation Compose uygulaması hakkında bilgi edinmek için Now in Android repositorysine göz atın. Samples . | Jetnews sample | Sunflower with Compose | Now in Android App | . ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/#learn-more",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/#learn-more"
  },"227": {
    "doc": "Navigation",
    "title": "Navigation",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/navigation/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/navigation/"
  },"228": {
    "doc": "Nested graphs",
    "title": "Nested graphs",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/nested-graphs/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/nested-graphs/"
  },"229": {
    "doc": "Offline first",
    "title": "Offline first",
    "content": "Çevrimdışı öncelikli(offline-first) bir uygulama, temel işlevselliğinin tamamını veya kritik bir alt kümesini internet erişimi olmadan gerçekleştirebilen bir uygulamadır. Yani, iş mantığının bir kısmını veya tamamını çevrimdışı olarak gerçekleştirebilir. Çevrimdışı öncelikli bir uygulama oluşturmaya yönelik hususlar, uygulama verilerine ve business logic’e erişim sunan data katmanında başlar. Uygulamanın bu verileri zaman zaman cihaz dışındaki kaynaklardan yenilemesi gerekebilir. Bunu yaparken, güncel kalmak için ağ kaynaklarını kullanması gerekebilir. Ağ kullanılabilirliği her zaman garanti edilmez. Cihazlarda genellikle ağ bağlantısının zayıf veya yavaş olduğu dönemler olabilir. Kullanıcılar aşağıdakilerle karşılaşabilir: . | Sınırlı internet bant genişliği | Asansör veya tünelde olduğu gibi geçici bağlantı kesintileri. | Ara sıra veri erişimi. Örneğin, yalnızca WiFi kullanan tabletler. | . Nedeni ne olursa olsun, bir uygulamanın bu koşullarda yeterli şekilde çalışması genellikle mümkündür. Uygulamanızın çevrimdışı olarak doğru şekilde çalıştığından emin olmak için aşağıdakileri yapabilmelidir: . | Güvenilir bir ağ bağlantısı olmadan kullanılabilirliğini sürdürme. | İlk ağ çağrısının tamamlanmasını veya başarısız olmasını beklemek yerine kullanıcılara yerel verileri hemen sunun. | Pil ve veri durumunun bilincinde olacak şekilde veri alın. Örneğin, yalnızca şarj olurken veya WiFi’da olduğu gibi en uygun koşullarda veri getirme talebinde bulunarak. Yukarıdaki kriterleri karşılayabilen bir uygulama genellikle çevrimdışı öncelikli uygulama(offline-first app) olarak adlandırılır. | . Create offline-first apps . Design an offline-first app . Çevrimdışı öncelikli bir uygulama tasarlarken data katmanından ve uygulama verileri üzerinde gerçekleştirebileceğiniz iki ana işlemden başlamalısınız: . | Reads: Kullanıcıya bilgi göstermek gibi uygulamanın diğer bölümleri tarafından kullanılmak üzere veri çekme. | Writes: User input’u daha sonra kullanmak üzere kalıcı hale getirme. | . Veri katmanındaki repository‘ler, uygulama verilerini sağlamak için veri kaynaklarını birleştirmekten sorumludur. Çevrimdışı öncelikli bir uygulamada, en kritik görevlerini gerçekleştirmek için ağ erişimine ihtiyaç duymayan en az bir veri kaynağı olmalıdır. Bu kritik görevlerden biri de veri okumaktır. Not: En azından, çevrimdışı öncelikli bir uygulama ağ erişimi olmadan okuma yapabilmelidir. Model data in an offline-first app . Çevrimdışı öncelikli bir uygulama, ağ kaynaklarını kullanan her repository için en az 2 veri kaynağına sahiptir: . | Local veri kaynağı | Network veri kaynağı | . Not: Çevrimdışı öncelikli bir uygulamada ağ erişimi olan bir repository her zaman lokal bir veri kaynağına sahip olmalıdır. The local data source . Lokal veri kaynağı, uygulama için standart haline gelmiş source of truth‘tır. Uygulamanın daha yüksek katmanlarının okuduğu tüm verilerin özel kaynağı olmalıdır. Bu, bağlantı durumları arasında veri tutarlılığı sağlar. Lokal veri kaynağı genellikle diske kalıcı olarak aktarılan bir depolama alanı tarafından desteklenir. Verileri diske kalıcı hale getirmenin bazı yaygın yolları şunlardır: . | Room gibi ilişkisel veritabanları gibi yapılandırılmış veri kaynakları. | Yapılandırılmamış veri kaynakları. Örneğin, Datastore ile protocol buffers. | Basit dosyalar | . The network data source . Network veri kaynağı uygulamanın gerçek state’idir. Lokal veri kaynağı en iyi ihtimalle network veri kaynağı ile senkronize edilir. Bunun gerisinde de kalabilir, bu durumda uygulamanın tekrar çevrimiçi olduğunda güncellenmesi gerekir. Tersine, network veri kaynağı, bağlantı geri geldiğinde uygulama onu güncelleyene kadar lokal veri kaynağının gerisinde kalabilir. Uygulamanın domain ve UI katmanları asla network katmanı ile doğrudan bağlantı kurmamalıdır. Onunla iletişim kurmak ve lokal veri kaynağını güncellemek için onu kullanmak hosting repository’nin sorumluluğundadır. Exposing resources . Lokal ve network veri kaynakları, uygulamanızın bunları nasıl okuyabileceği ve yazabileceği konusunda temel farklılıklar gösterebilir. Lokal bir veri kaynağını sorgulamak, SQL sorguları kullanmak gibi hızlı ve esnek olabilir. Buna karşılık, network veri kaynakları yavaş ve kısıtlı olabilir, örneğin RESTful kaynaklarına id ile artımlı olarak erişirken olduğu gibi. Sonuç olarak, her veri kaynağı genellikle sağladığı verilerin kendi temsiline ihtiyaç duyar. Bu nedenle lokal veri kaynağı ve network veri kaynağı kendi modellerine sahip olabilir. Aşağıdaki dizin yapısı bu kavramı görselleştirmektedir. AuthorEntity, uygulamanın lokal veritabanından okunan bir yazarın temsilidir ve NetworkAuthor, network üzerinden serileştirilen bir yazarın temsilidir: . data/ ├─ local/ │ ├─ entities/ │ │ ├─ AuthorEntity │ ├─ dao/ │ ├─ NiADatabase ├─ network/ │ ├─ NiANetwork │ ├─ models/ │ │ ├─ NetworkAuthor ├─ model/ │ ├─ Author ├─ repository/ . AuthorEntity ve NetworkAuthor’un ayrıntıları aşağıdaki gibidir: . /** * Network representation of [Author] */ @Serializable data class NetworkAuthor( val id: String, val name: String, val imageUrl: String, val twitter: String, val mediumPage: String, val bio: String, ) /** * Defines an author for either an [EpisodeEntity] or [NewsResourceEntity]. * It has a many-to-many relationship with both entities */ @Entity(tableName = \"authors\") data class AuthorEntity( @PrimaryKey val id: String, val name: String, @ColumnInfo(name = \"image_url\") val imageUrl: String, @ColumnInfo(defaultValue = \"\") val twitter: String, @ColumnInfo(name = \"medium_page\", defaultValue = \"\") val mediumPage: String, @ColumnInfo(defaultValue = \"\") val bio: String, ) . Hem AuthorEntity hem de NetworkAuthor’u veri katmanının içinde tutmak ve harici katmanların kullanması için üçüncü bir türü ortaya çıkarmak iyi bir pratiktir. Bu, harici katmanları, uygulamanın davranışını temelden değiştirmeyen lokal ve network veri kaynaklarındaki küçük değişikliklerden korur. Bu, aşağıdaki snippet’te gösterilmiştir: . /** * External data layer representation of a \"Now in Android\" Author */ data class Author( val id: String, val name: String, val imageUrl: String, val twitter: String, val mediumPage: String, val bio: String, ) . Network modeli daha sonra bunu lokal modele dönüştürmek için bir extension metodu tanımlayabilir ve lokal model de benzer şekilde aşağıda gösterildiği gibi bunu harici temsile dönüştürmek için bir metoda sahiptir: . /** * Converts the network model to the local model for persisting * by the local data source */ fun NetworkAuthor.asEntity() = AuthorEntity( id = id, name = name, imageUrl = imageUrl, twitter = twitter, mediumPage = mediumPage, bio = bio, ) /** * Converts the local model to the external model for use * by layers external to the data layer */ fun AuthorEntity.asExternalModel() = Author( id = id, name = name, imageUrl = imageUrl, twitter = twitter, mediumPage = mediumPage, bio = bio, ) . Not: Yukarıdaki gibi mapper’lar genellikle farklı modüllerde tanımlanan modeller arasında eşleme yapar. Sonuç olarak, tightly coupled modüllerden kaçınmak için bu mapperlari kullanıldıkları modüllerde tanımlamak genellikle faydalıdır. Daha fazla ayrıntı için modularization kılavuzuna bakın. Reads . Okumalar, çevrimdışı öncelikli bir uygulamada uygulama verileri üzerindeki temel işlemdir. Bu nedenle, uygulamanızın verileri okuyabildiğinden ve yeni veriler mevcut olur olmaz uygulamanın bunları görüntüleyebildiğinden emin olmalısınız. Bunu yapabilen bir uygulama reaktif bir uygulamadır çünkü okuma API’lerini observable tiplerle sunarlar. Aşağıdaki kod parçasında, OfflineFirstTopicRepository tüm okuma API’leri için Flow döndürür. Bu, network veri kaynağından güncellemeler aldığında okuyucularını güncellemesini sağlar. Başka bir deyişle, OfflineFirstTopicRepository’nin lokal veri kaynağı invalid edildiğinde değişiklikleri iletmesine olanak tanır. Bu nedenle, OfflineFirstTopicRepository’nin her okuyucusu, uygulamaya network bağlantısı yeniden sağlandığında tetiklenebilecek veri değişikliklerini ele almaya hazır olmalıdır. Ayrıca, OfflineFirstTopicRepository verileri doğrudan lokal veri kaynağından okur. Veri değişikliklerini okuyucularına ancak önce lokal veri kaynağını güncelleyerek bildirebilir. class OfflineFirstTopicsRepository( private val topicDao: TopicDao, private val network: NiaNetworkDataSource, ) : TopicsRepository { override fun getTopicsStream(): Flow&lt;List&lt;Topic&gt;&gt; = topicDao.getTopicEntitiesStream() .map { it.map(TopicEntity::asExternalModel) } } . Not: Çevrimdışı öncelikli bir uygulamada repository’lerden okuma işlemleri doğrudan lokal veri kaynağından okunmalıdır. Herhangi bir güncelleme önce lokal veri kaynağına yazılmalıdır ve lokal veri kaynağı observable olduğu için tüketicilerini güncelleyecektir. Error handling strategies . Çevrimdışı öncelikli uygulamalarda hataları ele almanın, oluşabilecekleri veri kaynaklarına bağlı olarak benzersiz yolları vardır. Aşağıdaki alt bölümlerde bu stratejiler özetlenmektedir. | Local data source Lokal veri kaynağından okuma sırasında oluşan hatalar nadir olmalıdır. Okuyucuları hatalardan korumak için, okuyucunun veri topladığı Flow’larda catch operatörünü kullanın. | . Bir ViewModel’de catch operatörünün kullanımı aşağıdaki gibidir: . class AuthorViewModel( authorsRepository: AuthorsRepository, ... ) : ViewModel() { private val authorId: String = ... // Observe author information private val authorStream: Flow&lt;Author&gt; = authorsRepository.getAuthorStream( id = authorId ) .catch { emit(Author.empty()) } } . Not: catch operatörü yalnızca exception’ın uygulamayı çökertmesini engeller, backing Flow yine de sonlanır. Exception’dan sonra flow’tan collecting’e devam etmek için retry metodunu kullanın. | Network data source Bir network veri kaynağından veri okunurken hata oluşursa, uygulamanın veri getirmeyi yeniden denemek için bir heuristic yöntem kullanması gerekecektir. Yaygın heuristic yöntemler şunlardır: . | Exponential backoff . Exponential backoff‘ta uygulama, başarılı olana veya diğer koşullar durması gerektiğini belirleyene kadar artan zaman aralıklarıyla network veri kaynağından okumayı denemeye devam eder. Uygulamanın backing off yapmaya devam edip etmeyeceğini değerlendirmek için kriterler şunlardır: . | Network veri kaynağının belirttiği hata türü. Örneğin, bağlantı eksikliğini gösteren bir hata döndüren network çağrılarını yeniden denemelisiniz. Tersine, uygun kimlik bilgileri mevcut olana kadar yetkilendirilmemiş HTTP isteklerini yeniden denememelisiniz. | İzin verilen maksimum yeniden deneme sayısı. | . | Network connectivity monitoring Bu yaklaşımda, uygulama network veri kaynağına bağlanabileceğinden emin olana kadar okuma istekleri kuyruğa alınır. Bağlantı kurulduktan sonra okuma isteği kuyruktan çıkarılır, veri okunur ve lokal veri kaynağı güncellenir. Android’de bu kuyruk bir Room veritabanı ile tutulabilir ve WorkManager kullanılarak kalıcı iş olarak tüketilebilir. | . | . Writes . Çevrimdışı öncelikli bir uygulamada veri okumak için önerilen yol observable tipleri kullanmak olsa da, yazma API’leri için eşdeğer olan suspend fonksiyonları gibi asenkron API’lerdir. Bu, UI thread’inin engellenmesini önler ve çevrimdışı öncelikli uygulamalardaki yazma işlemleri bir network sınırını geçerken başarısız olabileceğinden hata ele almaya yardımcı olur. interface UserDataRepository { /** * Updates the bookmarked status for a news resource */ suspend fun updateNewsResourceBookmark(newsResourceId: String, bookmarked: Boolean) } . Yukarıdaki kod parçasında, yukarıdaki metot askıya aldığı için tercih edilen asenkron API Coroutines‘tir. Write strategies . Çevrimdışı öncelikli uygulamalarda veri yazarken göz önünde bulundurulması gereken üç strateji vardır. Hangisini seçeceğiniz, yazılmakta olan veri türüne ve uygulamanın gereksinimlerine bağlıdır: . | Online-only writes . Verileri network sınırı boyunca yazmayı deneyin. Başarılı olursa, lokal veri kaynağını günceller, aksi takdirde bir exception atar ve uygun şekilde yanıt vermeyi çağırana bırakır. Bu strateji genellikle neredeyse gerçek zamanlı olarak çevrimiçi gerçekleşmesi gereken yazma işlemleri için kullanılır. Örneğin, bir banka transferi. Yazma işlemleri başarısız olabileceğinden, genellikle kullanıcıya yazmanın başarısız olduğunu bildirmek veya kullanıcının ilk etapta veri yazmaya çalışmasını önlemek gerekir. Bu senaryolarda kullanabileceğiniz bazı stratejiler şunları içerebilir: . | Bir uygulama veri yazmak için internet erişimi gerektiriyorsa, kullanıcıya veri yazmasına izin veren bir UI sunmamayı veya en azından bunu devre dışı bırakmayı tercih edebilir. | Kullanıcının çevrimdışı olduğunu bildirmek için kullanıcının reddedemeyeceği bir açılır mesaj veya geçici bir mesaj kullanabilirsiniz. | . | Queued writes . Yazmak istediğiniz bir nesne olduğunda, bunu bir kuyruğa ekleyin. Uygulama tekrar çevrimiçi olduğunda exponential back off ile kuyruğu tüketmeye devam edin. Android’de çevrimdışı bir kuyruğu tüketmek, genellikle WorkManager’a devredilen kalıcı bir iştir. Bu yaklaşım aşağıdaki durumlarda iyi bir seçimdir: . | Verilerin ağa yazılması zorunlu değildir. | İşlem zamana duyarlı değildir. | İşlemin başarısız olması durumunda kullanıcının bilgilendirilmesi gerekli değildir. | . Bu yaklaşımın kullanım alanları arasında analytics eventlar ve loglama yer alır. | Lazy writes . Önce lokal veri kaynağına yazın, ardından en uygun zamanda network’e bildirmek için yazma işlemini kuyruğa alın. Uygulama tekrar çevrimiçi olduğunda network ve lokal veri kaynakları arasında çakışmalar olabileceğinden bu önemsiz bir işlem değildir. Çakışma çözümü ile ilgili bir sonraki bölümde daha fazla ayrıntı verilmektedir. Bu yaklaşım, veriler uygulama için kritik olduğunda doğru seçimdir. Örneğin, çevrimdışı öncelikli bir yapılacaklar listesi uygulamasında, veri kaybı riskini önlemek için kullanıcının çevrimdışı olarak eklediği tüm görevlerin lokal olarak saklanması çok önemlidir. Not: Çevrimdışı öncelikli uygulamalarda veri yazmak, olası çakışmalar nedeniyle genellikle veri okumaktan daha fazla dikkat gerektirir. Çevrimdışı öncelikli uygulamaların çevrimdışı öncelikli olarak kabul edilmesi için çevrimdışıyken veri yazabilmesi gerekmez. | . Synchronization and conflict resolution . Çevrimdışı öncelikli bir uygulama bağlantısını geri yüklediğinde, lokal veri kaynağındaki verileri network veri kaynağındaki verilerle bağdaştırması gerekir. Bu işleme senkronizasyon denir. Bir uygulamanın network veri kaynağıyla senkronize olmasının iki ana yolu vardır: 1-Pull-based synchronization, 2-Push-based synchronization . | Pull-based synchronization | . Pull-based senkronizasyonda uygulama, talep üzerine en son uygulama verilerini okumak için network’e ulaşır. Bu yaklaşım için yaygın bir heuristic yontem, uygulamanın verileri yalnızca kullanıcıya sunmadan hemen önce aldığı navigation-based’dir. Bu yaklaşım, uygulamanın network bağlantısının olmadığı kısa veya ara dönemler beklediği durumlarda en iyi sonucu verir. Bunun nedeni, veri yenilemenin fırsatçı olması ve uzun süreli bağlantısızlık durumlarında kullanıcının eskimiş ya da boş bir önbellekle uygulama hedeflerini ziyaret etmeye çalışması olasılığının artmasıdır. Belirli bir ekran için sonsuz kaydırma listesindeki öğeleri getirmek üzere sayfa token’larının kullanıldığı bir uygulama düşünün. Uygulama lazy bir şekilde networke ulaşabilir, verileri lokal veri kaynağında kalıcı hale getirebilir ve daha sonra bilgileri kullanıcıya geri sunmak için lokal veri kaynağından okuyabilir. Network bağlantısının olmadığı durumlarda, repository sadece lokal veri kaynağından veri talep edebilir. Bu, Jetpack Paging Library tarafından RemoteMediator API‘si ile kullanılan modeldir. class FeedRepository(...) { fun feedPagingSource(): PagingSource&lt;FeedItem&gt; { ... } } class FeedViewModel( private val repository: FeedRepository ) : ViewModel() { private val pager = Pager( config = PagingConfig( pageSize = NETWORK_PAGE_SIZE, enablePlaceholders = false ), remoteMediator = FeedRemoteMediator(...), pagingSourceFactory = feedRepository::feedPagingSource ) val feedPagingData = pager.flow } . Pull Based senkronizasyonun avantaj ve dezavantajları aşağıdaki tabloda özetlenmiştir: . | Avantaj | Dezavantaj | . | Uygulaması nispeten kolay. | Yoğun veri kullanımına yatkındır. Bunun nedeni, bir navigasyon hedefine tekrarlanan ziyaretlerin, değişmeyen bilgilerin gereksiz yere yeniden alınmasını tetiklemesidir. Bunu uygun önbellekleme ile azaltabilirsiniz. Bu, cachedIn operatörü ile UI katmanında veya bir HTTP önbelleği ile network katmanında yapılabilir. | . | İhtiyaç duyulmayan veriler asla getirilmeyecektir | Çekilen modelin kendi kendine yeterli olması gerektiğinden ilişkisel verilerle iyi ölçeklenmez. Senkronize edilen model, kendisini doldurmak için getirilecek diğer modellere bağlıysa, daha önce bahsedilen yoğun veri kullanımı sorunu daha da önemli hale gelecektir. Ayrıca, üst modelin repository’leri ile iç içe geçmiş modelin repository’leri arasında bağımlılıklara neden olabilir. | . | Push-based synchronization | . Push based senkronizasyonda, lokal veri kaynağı network veri kaynağının bir replika setini elinden geldiğince taklit etmeye çalışır. Bir baseline belirlemek için ilk başlangıçta proaktif olarak uygun miktarda veri çeker, daha sonra bu veriler eskidiğinde kendisini uyarması için sunucudan gelen bildirimlere güvenir. Eskimiş bildiriminin alınmasının ardından uygulama, yalnızca eskimiş olarak işaretlenen verileri güncellemek için network’e ulaşır. Bu iş, network veri kaynağına ulaşan ve lokal veri kaynağına getirilen verileri kalıcı hale getiren Repository’ye devredilir. Repository verilerini gözlemlenebilir tiplerle sunduğundan, okuyucular herhangi bir değişiklikten haberdar edilecektir. class UserDataRepository(...) { suspend fun synchronize() { val userData = networkDataSource.fetchUserData() localDataSource.saveUserData(userData) } } . Bu yaklaşımda, uygulama network veri kaynağına çok daha az bağımlıdır ve uzun süreler boyunca onsuz çalışabilir. Çevrimdışıyken hem okuma hem de yazma erişimi sunar çünkü lokal olarak network veri kaynağından en son bilgilere sahip olduğu varsayılır. Push based senkronizasyonun avantajları ve dezavantajları aşağıdaki tabloda özetlenmiştir: . | Avantaj | Dezavantaj | . | Uygulama süresiz olarak çevrimdışı kalabilir. | Çakışma çözümü için verilerin versiyonlanması önemsizdir. | . | Minimum veri kullanımı. Uygulama yalnızca değişen verileri alır. | Senkronizasyon sırasında yazma endişelerini dikkate almanız gerekir. | . | İlişkisel veriler için iyi çalışır. Her repository yalnızca desteklediği model için veri getirmekten sorumludur. | Network veri kaynağının senkronizasyonu desteklemesi gerekir. | . | Hybrid synchronization | . Bazı uygulamalar, verilere bağlı olarak pull veya push based olan hibrit bir yaklaşım kullanır. Örneğin, bir sosyal medya uygulaması, akış güncellemelerinin yüksek sıklığı nedeniyle kullanıcının takip akışını talep üzerine almak için pull based senkronizasyon kullanabilir. Aynı uygulama, kullanıcı adı, profil resmi vb. dahil olmak üzere oturum açan kullanıcı hakkındaki veriler için push based senkronizasyonu kullanmayı tercih edebilir. Sonuç olarak, çevrimdışı öncelikli senkronizasyon seçimi ürün gereksinimlerine ve mevcut teknik altyapıya bağlıdır. Not: Uygulamanızın senkronizasyon yöntemi, uygulamanızın ihtiyaçlarına ve lokal ve network veri kaynaklarını destekleyen altyapının kısıtlamalarına bağlıdır. Conflict resolution . Uygulama çevrimdışıyken lokal olarak network veri kaynağıyla uyumsuz veri yazıyorsa, senkronizasyon gerçekleşmeden önce çözmeniz gereken bir çakışma meydana gelmiştir. Çakışma çözümü genellikle versiyonlama gerektirir. Uygulamanın, değişikliklerin ne zaman gerçekleştiğini takip etmek için bazı kayıt tutma işlemleri yapması gerekecektir. Bu, meta verileri network veri kaynağına aktarmasını sağlar. Network veri kaynağı daha sonra source of truth sağlama sorumluluğuna sahiptir. Uygulamanın ihtiyaçlarına bağlı olarak çakışma çözümü için dikkate alınması gereken çok çeşitli stratejiler vardır. Mobil uygulamalar için yaygın bir yaklaşım “son yazan kazanır(last write wins) “dır. | Last write wins | . Bu yaklaşımda, cihazlar network’e yazdıkları verilere zaman damgası metadatası eklerler. Network veri kaynağı bunları aldığında, mevcut state’inden daha yeni olanları kabul ederken mevcut state’inden daha eski olan verileri reddeder. Yukarıdaki şekilde, her iki cihaz da çevrimdışıdır ve başlangıçta network veri kaynağı ile senkronizedir. Çevrimdışıyken, her ikisi de lokal olarak veri yazar ve verilerini yazdıkları zamanı takip ederler. Her ikisi de tekrar çevrimiçi olduğunda ve network veri kaynağı ile senkronize edildiğinde, network, B cihazının verilerini daha sonra yazdığı için bu cihazın verilerini kalıcı hale getirerek çakışmayı çözer. WorkManager in offline-first apps . Yukarıda ele alınan okuma ve yazma stratejilerinin her ikisinde de iki ortak araç vardı: . | Queues . | Reads: Network bağlantısı mevcut olana kadar okumaları ertelemek için kullanılır. | Writes: Network bağlantısı mevcut olana kadar yazmaları ertelemek ve yeniden denemeler için yazmaları yeniden istemek için kullanılır. | . | Network connectivity monitors . | Reads: Uygulama bağlandığında okuma kuyruğunu boşaltmak ve senkronizasyon için bir sinyal olarak kullanılır | Writes: Uygulama bağlandığında yazma kuyruğunu boşaltmak ve senkronizasyon için bir sinyal olarak kullanılır | . | . Her iki durum da WorkManager’ın üstün olduğu persistent work örnekleridir. Örneğin Now in Android örnek uygulamasında, WorkManager lokal veri kaynağını senkronize ederken hem okuma kuyruğu hem de ağ monitörü olarak kullanılır. Başlangıçta, uygulama aşağıdaki eylemleri gerçekleştirir: . | Lokal veri kaynağı ile network veri kaynağı arasında eşitlik olduğundan emin olmak için okuma senkronizasyon işini kuyruga alın. | Okuma senkronizasyon kuyruğunu boşaltın ve uygulama çevrimiçi olduğunda senkronize etmeye başlayın. | Network veri kaynağından exponential backoff kullanarak bir okuma gerçekleştirin. | Okuma sonuçlarını, oluşabilecek çakışmaları çözerek yerel veri kaynağına aktarın. | Lokal veri kaynağındaki verileri uygulamanın diğer katmanlarının kullanması için sunun. | Yukarıda anlatılanlar aşağıdaki şemada gösterilmiştir: | . WorkManager ile senkronizasyon işinin kuyruğa alınması, KEEP ExistingWorkPolicy ile benzersiz iş olarak belirtilerek takip edilir: . class SyncInitializer : Initializer&lt;Sync&gt; { override fun create(context: Context): Sync { WorkManager.getInstance(context).apply { // Queue sync on app startup and ensure only one // sync worker runs at any time enqueueUniqueWork( SyncWorkName, ExistingWorkPolicy.KEEP, SyncWorker.startUpSyncWork() ) } return Sync } } . Not: “Now in Android “deki okuma kuyruğu sadece enqueueUniqueWork API’si ile temsil edilebilecek kadar basittir. Kuyruğun boşaltılma sırası hakkında daha sıkı garantiler için, Room veya Datastore gibi bir veri kalıcılığı API’si ile daha sağlam bir kuyruk uygulamasının gerçekleştirilmesi gerekecektir. Daha sonra bu kuyruğu sırayla boşaltmak için bir Worker ayarlanabilir. Burada SyncWorker.startupSyncWork() aşağıdaki gibi tanımlanır: . /** Create a WorkRequest to call the SyncWorker using a DelegatingWorker. This allows for dependency injection into the SyncWorker in a different module than the app module without having to create a custom WorkManager configuration. */ fun startUpSyncWork() = OneTimeWorkRequestBuilder&lt;DelegatingWorker&gt;() // Run sync as expedited work if the app is able to. // If not, it runs as regular work.setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST) .setConstraints(SyncConstraints) // Delegate to the SyncWorker.setInputData(SyncWorker::class.delegatedData()) .build() val SyncConstraints get() = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() . Özellikle, SyncConstraints tarafından tanımlanan Kısıtlamalar(Constraints) NetworkType‘ın NetworkType.CONNECTED olmasını gerektirir. Yani, çalışmadan önce network kullanılabilir olana kadar bekler. Network kullanılabilir olduğunda, Worker uygun Repository instance’larına temsilci atayarak SyncWorkName tarafından belirtilen benzersiz iş kuyruğunu boşaltır. Senkronizasyon başarısız olursa doWork() metodu Result.retry() ile döner. WorkManager, exponential backoff ile senkronizasyonu otomatik olarak yeniden deneyecektir. Aksi takdirde, senkronizasyonu tamamlayarak Result.success() döndürür. class SyncWorker(...) : CoroutineWorker(appContext, workerParams), Synchronizer { override suspend fun doWork(): Result = withContext(ioDispatcher) { // First sync the repositories in parallel val syncedSuccessfully = awaitAll( async { topicRepository.sync() }, async { authorsRepository.sync() }, async { newsRepository.sync() }, ).all { it } if (syncedSuccessfully) Result.success() else Result.retry() } } . Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/offline-first/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/offline-first/"
  },"230": {
    "doc": "Overview",
    "title": "State and Jetpack Compose",
    "content": "Bir uygulamadaki state, zaman içinde değişebilen herhangi bir değerdir. Bu çok geniş bir tanımdır ve bir Room veritabanından bir sınıftaki değişkene kadar her şeyi kapsar. Tüm Android uygulamaları kullanıcıya state gösterir. Android uygulamalarında birkaç state örneği: . | Bir ağ bağlantısı kurulamadığında bunu gösteren bir Snackbar. | Bir blog yazısı ve ilgili yorumlar. | Kullanıcı tıkladığında oynatılan butonlar üzerindeki dalgalanma animasyonları. | Kullanıcının bir resmin üzerine çizebileceği çıkartmalar. | . Jetpack Compose, bir Android uygulamasında state’i nerede ve nasıl sakladığınız ve kullandığınız konusunda açık olmanıza yardımcı olur. Bu kılavuz, state ve composables arasındaki bağlantıya ve Jetpack Compose’un state ile daha kolay çalışmak için sunduğu API’lere odaklanmaktadır. Jetpack Compose: State . ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-and-jetpack-compose",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-and-jetpack-compose"
  },"231": {
    "doc": "Overview",
    "title": "State and composition",
    "content": "Compose deklaratiftir ve bu nedenle onu güncellemenin tek yolu aynı composable’ı yeni argümanlarla çağırmaktır. Bu argümanlar kullanıcı arayüzü state’inin temsilleridir. Bir state her güncellendiğinde recomposition gerçekleşir. Sonuç olarak, TextField gibi şeyler emperatif XML tabanlı view’larda olduğu gibi otomatik olarak güncellenmez. Bir composable’ın uygun şekilde güncellenebilmesi için yeni state’in açıkça söylenmesi gerekir. @Composable private fun HelloContent() { Column(modifier = Modifier.padding(16.dp)) { Text( text = \"Hello!\", modifier = Modifier.padding(bottom = 8.dp), style = MaterialTheme.typography.bodyMedium ) OutlinedTextField( value = \"\", onValueChange = { }, label = { Text(\"Name\") } ) } } . Bunu çalıştırırsanız, hiçbir şey olmadığını göreceksiniz. Bunun nedeni TextField’ın kendisini güncellememesi, value parametresi değiştiğinde güncellemesidir. Bu, Compose’da composition ve recomposition’ın nasıl çalıştığından kaynaklanmaktadır. Anahtar Terim: Composition: Jetpack Compose tarafından composables çalıştırıldığında oluşturulan kullanıcı arayüzünün bir açıklaması. Initial composition (İlk kompozisyon): composables’ı ilk kez çalıştırarak bir Composition oluşturulması. Recomposition: veri değiştiğinde Composition’ı güncellemek için composables’ın yeniden çalıştırılması. Initial composition ve recomposition hakkında daha fazla bilgi edinmek için Thinking in Compose bölümüne bakınız. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-and-composition",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-and-composition"
  },"232": {
    "doc": "Overview",
    "title": "State in composables",
    "content": "Composable fonksiyonlar bir nesneyi bellekte saklamak için remember API’sini kullanabilir. remember tarafından hesaplanan bir değer initial composition sırasında Composition’da saklanır ve saklanan değer recomposition sırasında döndürülür. remember hem mutable hem de immutable nesneleri saklamak için kullanılabilir. Not: remember nesneleri Composition’da saklar ve remember’ı çağıran composable Composition’dan kaldırıldığında nesneyi unutur. mutableStateOf, compose çalışma zamanıyla entegre edilmiş gözlemlenebilir bir tür olan gözlemlenebilir bir [MutableState](https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState) oluşturur. interface MutableState&lt;T&gt; : State&lt;T&gt; { override var value: T } . Value’da yapılan herhangi bir değişiklik, value’yu okuyan tüm composable fonksiyonların yeniden oluşturulmasını planlar. ExpandingCard durumunda, expanded her değiştiğinde, ExpandingCard’ın yeniden oluşturulmasına neden olur. Bir MutableState nesnesini bir composable içinde bildirmenin üç yolu vardır: . | val mutableState = remember { mutableStateOf(default) } | var value by remember { mutableStateOf(default) } | val (value, setValue) = remember { mutableStateOf(default) } | . Bu bildirimler eşdeğerdir ve farklı state kullanımları için syntax sugar olarak sağlanmıştır. Yazdığınız composable’da okunması en kolay kodu üreteni seçmelisiniz. By delegate syntax aşağıdaki import’ları gerektirir: . import androidx.compose.runtime.getValue import androidx.compose.runtime.setValue . Remembered değeri diğer composable’lar için bir parametre olarak veya hatta hangi composable’ların görüntüleneceğini değiştirmek için ifadelerde logic olarak kullanabilirsiniz. Örneğin, ad boşsa karşılama mesajını görüntülemek istemiyorsanız, state’i bir if ifadesinde kullanın: . @Composable fun HelloContent() { Column(modifier = Modifier.padding(16.dp)) { var name by remember { mutableStateOf(\"\") } if (name.isNotEmpty()) { Text( text = \"Hello, $name!\", modifier = Modifier.padding(bottom = 8.dp), style = MaterialTheme.typography.bodyMedium ) } OutlinedTextField( value = name, onValueChange = { name = it }, label = { Text(\"Name\") } ) } } . remember, recompositionlarda state’i korumanıza yardımcı olsa da, yapılandırma değişikliklerinde state korunmaz. Bunun için rememberSaveable kullanmanız gerekir. rememberSaveable, bir Bundle’a kaydedilebilen tüm değerleri otomatik olarak kaydeder. Diğer değerler için özel bir kaydedici nesnesi iletebilirsiniz. Dikkat: Compose’da state olarak ArrayList veya mutableListOf() gibi mutable nesnelerin kullanılması, kullanıcılarınızın uygulamanızda yanlış veya eski veriler görmesine neden olur. ArrayList veya mutable veri sınıfı gibi gözlemlenemeyen mutable nesneler Compose tarafından gözlemlenemez ve değiştiklerinde yeniden birleştirme tetiklemez. Gözlemlenebilir olmayan değişken nesneler kullanmak yerine, State&lt;List&gt; ve değişmez listOf() gibi gözlemlenebilir bir veri tutucu kullanmanız önerilir. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-in-composables",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-in-composables"
  },"233": {
    "doc": "Overview",
    "title": "Other supported types of state",
    "content": "Compose, state tutmak için MutableState kullanmanızı gerektirmez; diğer gözlemlenebilir türleri destekler. Compose'da başka bir gözlemlenebilir türü okumadan önce, onu bir State'ye dönüştürmelisiniz, böylece state değiştiğinde composablelar otomatik olarak yeniden oluşturabilir. Compose, Android uygulamalarında kullanılan yaygın gözlemlenebilir türlerden State oluşturmak için fonksiyonlarla birlikte gelir. Bu entegrasyonları kullanmadan önce, aşağıda belirtildiği gibi uygun artifact(lar)ı ekleyin: . | Flow: collectAsStateWithLifecycle(): collectAsStateWithLifecycle(), bir Flow’dan değerleri yaşam döngüsüne duyarlı bir şekilde toplayarak uygulamanızın gereksiz uygulama kaynaklarından tasarruf etmesini sağlar. Compose State aracılığıyla en son yayılan(emit edilen) değeri temsil eder. Android uygulamalarında Flow’ları collect etmek için önerilen yol olarak bu API’yi kullanın. Not: collectAsStateWithLifecycle() API’si ile Android’de flowlari güvenli bir şekilde collect etme hakkında daha fazla bilgi edinmek için bu blog yazısını okuyabilirsiniz. build.gradle dosyasında aşağıdaki bağımlılık gereklidir (2.6.0-beta01 veya daha yeni olmalıdır): . dependencies { ... implementation \"androidx.lifecycle:lifecycle-runtime-compose:2.6.0-beta01\" } . | Flow: collectAsState() collectAsState, collectAsStateWithLifecycle’a benzer, çünkü aynı zamanda bir Flow’dan değerleri collect eder ve bunları Compose State’e dönüştürür. Platformdan bağımsız kod için yalnızca Android’e özel olan collectAsStateWithLifecycle yerine collectAsState’i kullanın. collectAsState için ek bağımlılıklar gerekli değildir, çünkü compose-runtime’da mevcuttur. | LiveData: observeAsState() observeAsState() bu LiveData‘yı gözlemlemeye başlar ve değerlerini State aracılığıyla temsil eder. build.gradle dosyasında aşağıdaki bağımlılık gereklidir: . dependencies { ... implementation \"androidx.compose.runtime:runtime-livedata:1.4.2\" } . | RxJava2: subscribeAsState() subscribeAsState(), RxJava2’nin reaktif stream’lerini (örneğin Single, Observable, Completable) Compose State’e dönüştüren extension fonksiyonlarıdır. Build.gradle dosyasında aşağıdaki bağımlılık gereklidir: . dependencies { ... implementation \"androidx.compose.runtime:runtime-rxjava2:1.4.2\" } . | RxJava3: subscribeAsState() subscribeAsState(), RxJava3’ün reaktif stream’lerini (örneğin Single, Observable, Completable) Compose State’e dönüştüren extension fonksiyonlarıdır. build.gradle dosyasında aşağıdaki bağımlılık gereklidir: . dependencies { ... implementation \"androidx.compose.runtime:runtime-rxjava3:1.4.2\" } . | . Anahtar Nokta: Compose, State nesnelerini okurken otomatik olarak yeniden birleştirir. Compose’da LiveData gibi başka bir gözlemlenebilir tür kullanıyorsanız, okumadan önce bunu State’e dönüştürmelisiniz. Bu tür dönüştürme işleminin LiveData.observeAsState() gibi bir composable extension fonksiyonu kullanarak composable içinde gerçekleştiğinden emin olun. Not: Bu entegrasyonlarla sınırlı değilsiniz. Jetpack Compose için diğer gözlemlenebilir türleri okuyan bir extension fonksiyonu oluşturabilirsiniz. Uygulamanız özel bir gözlemlenebilir sınıf kullanıyorsa, produceState API’sini kullanarak bunu State üretecek şekilde dönüştürün. Bunun nasıl yapılacağına dair örnekler için yerleşiklerin uygulamasına bakın: collectAsStateWithLifecycle. Jetpack Compose’un her değişikliğe abone olmasını sağlayan herhangi bir nesne State'ye dönüştürülebilir ve bir Composable'da okunabilir. Stateful versus stateless . Bir nesneyi saklamak için remember kullanan bir composable, dahili state oluşturarak composable’ı stateful yapar. HelloContent, name state’ini dahili olarak tuttuğu ve değiştirdiği için stateful bir composable örneğidir. Bu, caller’ın state’i kontrol etmesine gerek olmadığı ve state’i kendisi yönetmek zorunda kalmadan kullanabileceği durumlarda faydalı olabilir. Bununla birlikte, dahili state’e sahip composable’lar daha az yeniden kullanılabilir ve test edilmesi daha zor olma eğilimindedir. Stateless composable, herhangi bir state tutmayan bir composable’dır. State tutmamayı başarmanın kolay bir yolu state hoisting kullanmaktır. Yeniden kullanılabilir composable’lar geliştirirken, genellikle aynı composable’ın hem stateful hem de stateeless versiyonunu ortaya çıkarmak istersiniz. Stateful sürüm, state’i önemsemeyen caller’lar için kullanışlıdır ve state’i kontrol etmesi veya kaldırması gereken caller’lar için stateless sürüm gereklidir. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#other-supported-types-of-state",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#other-supported-types-of-state"
  },"234": {
    "doc": "Overview",
    "title": "State hoisting",
    "content": "Compose’da state hoisting, bir composable’ı stateless yapmak için state’i composable’ın caller’ına taşıma yoludur. Jetpack Compose’da state hoisting için genel şablon, state değişkenini iki parametre ile değiştirmektir: . | value: T: görüntülenecek geçerli değer | onValueChange: (T) -&gt; Unit: değerin değişmesini isteyen bir olay, burada T önerilen yeni değerdir | . Ancak, onValueChange ile sınırlı değilsiniz. Composable için daha spesifik olaylar uygunsa, ExpandingCard’ın onExpand ve onCollapse ile yaptığı gibi bunları lambda kullanarak tanımlamalısınız. Bu şekilde kaldırılan state bazı önemli özelliklere sahiptir: . | Single source of truth (Tek doğruluk kaynağı): State’i çoğaltmak yerine taşıyarak yalnızca tek bir doğruluk kaynağı olmasını sağlıyoruz. Bu, hataları önlemeye yardımcı olur. | Encapsulated: Yalnızca stateful composable’lar state’lerini değiştirebilir. Tamamen içseldir. | Shareable: Kaldırılmış state birden fazla composable ile paylaşılabilir. Eğer farklı bir composable’daki ismi okumak isterseniz, hoisting bunu yapmanıza izin verir. | Interceptable: stateless composable’ları caller’lar state’i değiştirmeden önce event’leri görmezden gelmeye veya değiştirmeye karar verebilirler. | Decoupled: stateless ExpandingCard için state herhangi bir yerde saklanabilir. Örneğin, artık ismi bir ViewModel’e taşımak mümkündür. | . Örnek durumda, name ve onValueChange’i HelloContent’ten çıkarır ve bunları ağaçta HelloContent’i çağıran bir HelloScreen composable’ına taşırsınız. @Composable fun HelloScreen() { var name by rememberSaveable { mutableStateOf(\"\") } HelloContent(name = name, onNameChange = { name = it }) } @OptIn(ExperimentalMaterial3Api::class) @Composable fun HelloContent(name: String, onNameChange: (String) -&gt; Unit) { Column(modifier = Modifier.padding(16.dp)) { Text( text = \"Hello, $name\", modifier = Modifier.padding(bottom = 8.dp), style = MaterialTheme.typography.bodyMedium ) OutlinedTextField(value = name, onValueChange = onNameChange, label = { Text(\"Name\") }) } } . State’i HelloContent’ten kaldırarak, composable hakkında mantık yürütmek, farklı durumlarda yeniden kullanmak ve test etmek daha kolaydır. HelloContent, state’inin nasıl depolandığından ayrıştırılmıştır. Ayrıştırma(decoupled), HelloScreen’i değiştirdiğinizde ya da yerine başka bir şey koyduğunuzda HelloContent’in nasıl implemente edildiğini değiştirmek zorunda kalmayacağınız anlamına gelir. State’in aşağı indiği ve event’lerin yukarı çıktığı modele tek yönlü veri akışı denir. Bu durumda, state HelloScreen’den HelloContent’e iner ve event’ler HelloContent’ten HelloScreen’e çıkar. Tek yönlü veri akışını izleyerek, kullanıcı arayüzünde state’i görüntüleyen composable’ları uygulamanızın state’i depolayan ve değiştiren bölümlerinden ayırabilirsiniz. Anahtar Nokta: State’i kaldırırken(hoisting), state’in nereye gitmesi gerektiğini anlamanıza yardımcı olacak üç kural vardır: . | State, state’i kullanan tüm composable’ların en azından en düşük ortak parent’ına kaldırılmalıdır(hoist) (read). | State en azından değiştirilebileceği en yüksek seviyeye kaldırılmalıdır(hoist) (write). | Aynı eventlara yanıt olarak iki state değişirse bunlar birlikte kaldırılmalıdır(hoist). State’i bu kuralların gerektirdiğinden daha yükseğe kaldırabilirsiniz, ancak state’in daha az kaldırılması tek yönlü veri akışını takip etmeyi zorlaştırır veya imkansız hale getirir. | . Daha fazla bilgi edinmek için Where to hoist state sayfasına bakın. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-hoisting",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-hoisting"
  },"235": {
    "doc": "Overview",
    "title": "Restoring state in Compose",
    "content": "rememberSaveable API’si remember’a benzer şekilde davranır çünkü kaydedilen instance state mekanizmasını kullanarak recompositionlar boyunca ve ayrıca activity veya process recreation boyunca state’i korur. Örneğin, ekran döndürüldüğünde bu durum gerçekleşir. Ways to store state . Bundle’a eklenen tüm veri türleri otomatik olarak kaydedilir. Bundle’a eklenemeyen bir şeyi kaydetmek istiyorsanız, birkaç seçenek vardır. Parcelize . En basit çözüm, nesneye @Parcelize annotation’ını eklemektir. Nesne parsellenebilir hale gelir ve bundle edilebilir. Örneğin, bu kod City veri türünü parsellenebilir hale getirir ve state’e kaydeder. @Parcelize data class City(val name: String, val country: String) : Parcelable @Composable fun CityScreen() { var selectedCity = rememberSaveable { mutableStateOf(City(\"Madrid\", \"Spain\")) } } . MapSaver . Herhangi bir nedenle @Parcelize uygun değilse, bir nesneyi sistemin Bundle’a kaydedebileceği bir değerler kümesine dönüştürmek için kendi kuralınızı tanımlamak üzere mapSaver’ı kullanabilirsiniz. data class City(val name: String, val country: String) val CitySaver = run { val nameKey = \"Name\" val countryKey = \"Country\" mapSaver( save = { mapOf(nameKey to it.name, countryKey to it.country) }, restore = { City(it[nameKey] as String, it[countryKey] as String) } ) } @Composable fun CityScreen() { var selectedCity = rememberSaveable(stateSaver = CitySaver) { mutableStateOf(City(\"Madrid\", \"Spain\")) } } . ListSaver . Map’in key’lerini tanımlamak zorunda kalmamak için listSaver’ı kullanabilir ve index’lerini key olarak kullanabilirsiniz: . data class City(val name: String, val country: String) val CitySaver = listSaver&lt;City, Any&gt;( save = { listOf(it.name, it.country) }, restore = { City(it[0] as String, it[1] as String) } ) @Composable fun CityScreen() { var selectedCity = rememberSaveable(stateSaver = CitySaver) { mutableStateOf(City(\"Madrid\", \"Spain\")) } } . ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#restoring-state-in-compose",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#restoring-state-in-compose"
  },"236": {
    "doc": "Overview",
    "title": "State holders in Compose",
    "content": "Basit state hoisting işlemi, composable fonksiyonların kendi içinde yönetilebilir. Bununla birlikte, takip edilmesi gereken state miktarı artarsa veya composable fonksiyonlarda gerçekleştirilecek logic doğarsa, logic ve state sorumluluklarını diğer sınıflara devretmek iyi bir pratiktir: state holders. Anahtar Terim: State holder’lar composable’ların logic ve state’lerini yönetir. Diğer materyallerde state holder’ların hoisted state objects olarak da adlandırıldığını unutmayın. Daha fazla bilgi edinmek için Compose belgelerinde state hoisting‘e veya daha genel olarak mimari kılavuzundaki State holders ve UI State sayfasına bakın. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-holders-in-compose",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#state-holders-in-compose"
  },"237": {
    "doc": "Overview",
    "title": "Retrigger remember caculations when keys change",
    "content": "remember api’i sıklıkla MutableState ile birlikte kullanılır: . var name by remember { mutableStateOf(\"\") } . Burada, remember fonksiyonunun kullanılması MutableState değerinin recompositionlarda hayatta kalmasını sağlar. Genel olarak, remember bir hesaplama lambda parametresi alır. remember ilk çalıştırıldığında, hesaplama lambdasını çağırır ve sonucunu saklar. Recomposition sırasında, remember en son depolanan değeri döndürür. State’i önbelleğe almanın yanı sıra, başlatılması veya hesaplanması pahalı olan herhangi bir nesneyi veya bir işlemin sonucunu Composition’da saklamak için de remember’ı kullanabilirsiniz. Bu hesaplamayı her recompositionda tekrarlamak istemeyebilirsiniz. Pahalı bir işlem olan bu ShaderBrush nesnesini oluşturmak buna bir örnektir: . val brush = remember { ShaderBrush( BitmapShader( ImageBitmap.imageResource(res, avatarRes).asAndroidBitmap(), Shader.TileMode.REPEAT, Shader.TileMode.REPEAT ) ) } . remember değeri Composition’dan ayrılana kadar saklar. Ancak, önbelleğe alınan değeri geçersiz kılmanın bir yolu vardır. remember API’si ayrıca bir key veya keys parametresi alır. Bu key’lerden herhangi biri değişirse, fonksiyon bir sonraki yeniden oluşturma işleminde remember önbelleği geçersiz kılar ve hesaplama lambda bloğunu yeniden çalıştırır. Bu mekanizma, Composition’daki bir nesnenin yaşam süresi üzerinde kontrol sahibi olmanızı sağlar. Hesaplama, hatırlanan değer Composition’dan ayrılana kadar değil, girdiler değişene kadar geçerli kalır. Aşağıdaki örnekler bu mekanizmanın nasıl çalıştığını göstermektedir. Bu kod parçasında, bir ShaderBrush oluşturulur ve bir Box composable’ın arka plan boyası olarak kullanılır. remember, ShaderBrush instance’ını saklar çünkü daha önce açıklandığı gibi yeniden oluşturulması pahalıdır. remember, seçilen arka plan görüntüsü olan avatarRes’i key1 parametresi olarak alır. AvatarRes değişirse, fırça yeni görüntüyle yeniden oluşturulur ve Box’a yeniden uygulanır. Bu, kullanıcı bir seçiciden arka plan olarak başka bir görüntü seçtiğinde meydana gelebilir. @Composable private fun BackgroundBanner( @DrawableRes avatarRes: Int, modifier: Modifier = Modifier, res: Resources = LocalContext.current.resources ) { val brush = remember(key1 = avatarRes) { ShaderBrush( BitmapShader( ImageBitmap.imageResource(res, avatarRes).asAndroidBitmap(), Shader.TileMode.REPEAT, Shader.TileMode.REPEAT ) ) } Box( modifier = modifier.background(brush) ) { /* ... */ } } . Bir sonraki kod parçacığında state, MyAppState adlı düz bir state holder sınıfına hoist edilir. Sınıfın bir instance’ını remember kullanarak initialize etmek için bir rememberMyAppState fonksiyonu sunar. Bu tür fonksiyonları, recompositionlarda hayatta kalan bir instance oluşturmak için ortaya çıkarmak Compose’da yaygın bir modeldir. rememberMyAppState fonksiyonu, remember için anahtar parametre görevi gören windowSizeClass değerini alır. Bu parametre değişirse, uygulamanın düz state holder sınıfını en son değerle yeniden oluşturması gerekir. Bu, örneğin kullanıcı cihazı döndürdüğünde meydana gelebilir. @Composable private fun rememberMyAppState( windowSizeClass: WindowSizeClass ): MyAppState { return remember(windowSizeClass) { MyAppState(windowSizeClass) } } @Stable class MyAppState( private val windowSizeClass: WindowSizeClass ) { /* ... */ } . Not: Düz state holder sınıfları hakkında daha fazla bilgi için, State holder class as state owner belgesine veya Architecture kılavuzundaki State holders and UI State belgesine bakın. Compose, bir key’in değişip değişmediğine karar vermek ve saklanan değeri geçersiz kılmak için sınıfın equals implementasyonunu kullanır. Not: İlk bakışta, keyler ile remember kullanmak, derivedStateOf gibi diğer Compose API’lerini kullanmaya benzer görünebilir. Aradaki farkı öğrenmek için Jetpack Compose - Ne zaman derivedStateOf kullanmalıyım? blog gönderisine bakın. Store state with keys beyond recomposition . rememberSaveable API, verileri bir Bundle’da saklayabilen remember etrafında bir sarmalayıcıdır. Bu API, state’in yalnızca yeniden oluşturmaya değil, aynı zamanda activity recreation ve sistem tarafından başlatılan süreç ölümüne de dayanmasını sağlar. rememberSaveable, remember’ın key’leri almasıyla aynı amaçla input parametrelerini alır. Girdilerden herhangi biri değiştiğinde önbellek geçersiz kılınır. Fonksiyon bir sonraki kez yeniden oluşturulduğunda, rememberSaveable hesaplama lambda bloğunu yeniden yürütür. Not: API isimlendirmesinde dikkat etmeniz gereken bir fark vardır. remember API’sinde parametre adı key’leri kullanırsınız ve rememberSaveable’da aynı amaç için input’ları kullanırsınız. Bu parametrelerden herhangi biri değişirse, önbelleğe alınan değer geçersiz kılınır. Aşağıdaki örnekte, rememberSaveable, typedQuery değişene kadar userTypedQuery öğesini saklar: . var userTypedQuery by rememberSaveable(typedQuery, stateSaver = TextFieldValue.Saver) { mutableStateOf( TextFieldValue(text = typedQuery, selection = TextRange(typedQuery.length)) ) } . ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#retrigger-remember-caculations-when-keys-change",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#retrigger-remember-caculations-when-keys-change"
  },"238": {
    "doc": "Overview",
    "title": "Learn more",
    "content": "Bu belgede, Compose’da state’i yönetmenin temellerini öğrendiniz. Daha fazla bilgi için aşağıdaki kaynaklara bakın: . Samples . | Jetnews sample | Jetchat sample | Now in Android App | . Codelabs . | Using State in Jetpack Compose Videos . | A Compose state of mind Blogs . | Effective State Management for TextField in Compose | . ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#learn-more",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/#learn-more"
  },"239": {
    "doc": "Overview",
    "title": "Overview",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/overview/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/overview/"
  },"240": {
    "doc": "Overview",
    "title": "Layouts in Compose",
    "content": "Jetpack Compose, uygulamanız için verimli bir layout tasarlamanızı kolaylaştırır. Aşağıdaki sayfalar, layout’unuzu nasıl tasarlayacağınız ve uygulayacağınız hakkında ayrıntılar sağlar: . | Layout basics: Basit bir uygulama kullanıcı arayüzü için yapı taşları hakkında bilgi edinin. | Material Components and layouts: Compose’daki Material bileşenleri ve layout’ları hakkında bilgi edinin. | Custom layouts: Uygulamanızın layout’unun kontrolünü nasıl ele alacağınızı ve kendi özel layout’unuzu nasıl tasarlayacağınızı öğrenin. | Build adaptive layouts: Farklı ekran boyutlarına, yönlere ve form faktörlerine uyum sağlayan layout’lar oluşturmak için Compose’u nasıl kullanacağınızı öğrenin. | Alignment lines: UI öğelerinizi hassas bir şekilde hizalamak ve konumlandırmak için özel hizalama çizgilerini nasıl oluşturacağınızı öğrenin. | Intrinsic measurements: UI öğeleriniz için özgün bir yükseklik veya genişliği nasıl ayarlayacağınızı öğrenin, böylece öğelerin layout’da nasıl düzenleneceği üzerinde hassas kontrol sahibi olursunuz. | ConstraintLayout: Compose UI’nizde ConstraintLayout’u nasıl kullanacağınızı öğrenin. | . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/overview/#layouts-in-compose",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/overview/#layouts-in-compose"
  },"241": {
    "doc": "Overview",
    "title": "Overview",
    "content": " ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/overview/",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/overview/"
  },"242": {
    "doc": "Page from network and database",
    "title": "Page from network and database",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/page-from-network-and-database/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/page-from-network-and-database/"
  },"243": {
    "doc": "Pager",
    "title": "Pager in Compose",
    "content": "İçeriği sola ve sağa veya yukarı ve aşağı şekilde kaydırmak için HorizontalPager ve VerticalPager composablelar bulunmaktadır. Bu bileşenler, view sistemindeki ViewPager ile benzer işlevlere sahiptir. Varsayılan olarak, HorizontalPager ekranın tam genişliğini kaplar, VerticalPager tam yüksekliğini kaplar ve pager’lar bir seferde yalnızca bir sayfa kaydırır. Bu varsayılanların tümü ayarlanabilir. Not: Compose Pager test aşamasındadır. Herhangi bir sorunu issue tracker üzerinden bildirin. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#pager-in-compose",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#pager-in-compose"
  },"244": {
    "doc": "Pager",
    "title": "HorizontalPager",
    "content": "Yatay olarak sola ve sağa kaydırılan bir pager oluşturmak için HorizontalPager kullanın: . // 10 öğe görüntüle HorizontalPager(pageCount = 10) { page -&gt; // Sayfa içeriğimiz Text( text = \"Page: $page\", modifier = Modifier.fillMaxWidth() ) } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#horizontalpager",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#horizontalpager"
  },"245": {
    "doc": "Pager",
    "title": "VerticalPager",
    "content": "Yukarı ve aşağı kaydırılan bir pager oluşturmak için VerticalPager kullanın: . // 10 öğe görüntüle VerticalPager(pageCount = 10) { page -&gt; // Sayfa içeriğimiz Text( text = \"Page: $page\", modifier = Modifier.fillMaxWidth() ) } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#verticalpager",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#verticalpager"
  },"246": {
    "doc": "Pager",
    "title": "Lazy creation",
    "content": "Hem HorizontalPager hem de VerticalPager’daki sayfalar lazily olarak oluşturulur ve gerektiğinde düzenlenir. Kullanıcı sayfalar arasında ilerledikçe, composable artık gerekli olmayan sayfaları kaldırır. Load more pages offscreen . Varsayılan olarak, pager yalnızca ekrandaki görünür sayfaları yükler. Ekran dışında daha fazla sayfa yüklemek için beyondBoundsPageCount değerini sıfırdan büyük bir değere ayarlayın. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#lazy-creation",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#lazy-creation"
  },"247": {
    "doc": "Pager",
    "title": "Scroll to an item in the pager",
    "content": "Pager’da belirli bir sayfaya kaydırmak için, rememberPagerState() kullanarak bir PagerState nesnesi oluşturun ve bunu pager’a state parametresi olarak aktarın. Bu state üzerinde, bir CoroutineScope içinde PagerState#scrollToPage() fonksiyonunu çağırabilirsiniz: . val pagerState = rememberPagerState() HorizontalPager(pageCount = 10, state = pagerState) { page -&gt; // Sayfa içeriğimiz Text( text = \"Page: $page\", modifier = Modifier .fillMaxWidth() .height(100.dp) ) } // scroll to page val coroutineScope = rememberCoroutineScope() Button(onClick = { coroutineScope.launch { // Call scroll to on pagerState pagerState.scrollToPage(5) } }, modifier = Modifier.align(Alignment.BottomCenter)) { Text(\"Jump to Page 5\") } . Sayfaya animasyon uygulamak istiyorsanız, PagerState#animateScrollToPage() fonksiyonunu kullanın: . val pagerState = rememberPagerState() HorizontalPager(pageCount = 10, state = pagerState) { page -&gt; // Our page content Text( text = \"Page: $page\", modifier = Modifier .fillMaxWidth() .height(100.dp) ) } // scroll to page val coroutineScope = rememberCoroutineScope() Button(onClick = { coroutineScope.launch { // Call scroll to on pagerState pagerState.animateScrollToPage(5) } }, modifier = Modifier.align(Alignment.BottomCenter)) { Text(\"Jump to Page 5\") } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#scroll-to-an-item-in-the-pager",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#scroll-to-an-item-in-the-pager"
  },"248": {
    "doc": "Pager",
    "title": "Get notified about page state changes",
    "content": "PagerState, sayfalar hakkında bilgi içeren üç property’e sahiptir: currentPage, settledPage ve targetPage. | currentPage: Snap konumuna en yakın sayfa. Varsayılan olarak, snap konumu layout’un başlangıcındadır. | settledPage: Animasyon veya kaydırma çalışmazken sayfa numarası. Bu, currentPage property’sinden farklıdır, çünkü sayfa snap pozisyonuna yeterince yakınsa currentPage hemen güncellenir, ancak settledPage tüm animasyonlar çalışmayı bitirene kadar aynı kalır. | targetPage: Kaydırma hareketi için öngörülen durma konumu. | . Bu değişkenlerdeki değişiklikleri gözlemlemek ve bunlara tepki vermek için snapshotFlow fonksiyonunu kullanabilirsiniz. Örneğin, her sayfa değişikliğinde bir analytics event göndermek için aşağıdakileri yapabilirsiniz: . val pagerState = rememberPagerState() LaunchedEffect(pagerState) { // Collect from the a snapshotFlow reading the currentPage snapshotFlow { pagerState.currentPage }.collect { page -&gt; // Do something with each page change, for example: // viewModel.sendPageSelectedEvent(page) Log.d(\"Page change\", \"Page changed to $page\") } } VerticalPager( pageCount = 10, state = pagerState, ) { page -&gt; Text(text = \"Page: $page\") } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#get-notified-about-page-state-changes",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#get-notified-about-page-state-changes"
  },"249": {
    "doc": "Pager",
    "title": "Add a page indicator",
    "content": "Bir sayfaya indikatör eklemek için, PagerState nesnesini kullanarak sayfa sayısı içinden hangi sayfanın seçili olduğu hakkında bilgi alın ve custom indikatörünüzü çizin. Örneğin, basit bir daire indikatörü istiyorsanız, pagerState.currentPage kullanarak daire sayısını tekrarlayabilir ve sayfanın seçili olup olmadığına göre daire rengini değiştirebilirsiniz: . val pageCount = 10 val pagerState = rememberPagerState() HorizontalPager( pageCount = pageCount, state = pagerState ) { page -&gt; // Our page content Text( text = \"Page: $page\", modifier = Modifier .fillMaxSize() ) } Row( Modifier .height(50.dp) .fillMaxWidth() .align(Alignment.BottomCenter), horizontalArrangement = Arrangement.Center ) { repeat(pageCount) { iteration -&gt; val color = if (pagerState.currentPage == iteration) Color.DarkGray else Color.LightGray Box( modifier = Modifier .padding(2.dp) .clip(CircleShape) .background(color) .size(20.dp) ) } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#add-a-page-indicator",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#add-a-page-indicator"
  },"250": {
    "doc": "Pager",
    "title": "Apply item scroll effects to content",
    "content": "Yaygın bir kullanım durumu, pager öğelerinize efekt uygulamak için kaydırma konumunu kullanmaktır. Bir sayfanın o anda seçili olan sayfadan ne kadar uzakta olduğunu öğrenmek için PagerState.currentPageOffsetFraction öğesini kullanabilirsiniz. Ardından, seçilen sayfaya olan uzaklığa göre içeriğinize efektler uygulayabilirsiniz. Örneğin, öğelerin opaklığını merkezden ne kadar uzakta olduklarına göre ayarlamak için, pager içindeki bir öğede Modifier.graphicsLayer kullanarak alfayı değiştirin: . val pagerState = rememberPagerState() HorizontalPager(pageCount = 4, state = pagerState) { page -&gt; Card( Modifier .size(200.dp) .graphicsLayer { // Calculate the absolute offset for the current page from the // scroll position. We use the absolute value which allows us to mirror // any effects for both directions val pageOffset = ( (pagerState.currentPage - page) + pagerState .currentPageOffsetFraction ).absoluteValue // We animate the alpha, between 50% and 100% alpha = lerp( start = 0.5f, stop = 1f, fraction = 1f - pageOffset.coerceIn(0f, 1f) ) } ) { // Card content } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#apply-item-scroll-effects-to-content",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#apply-item-scroll-effects-to-content"
  },"251": {
    "doc": "Pager",
    "title": "Custom page sizes",
    "content": "Varsayılan olarak, HorizontalPager ve VerticalPager sırasıyla tam genişliği veya tam yüksekliği kaplar. pageSize değişkenini Fixed, Fill (varsayılan) veya custom (özel) bir boyut hesaplamasına sahip olacak şekilde ayarlayabilirsiniz. Örneğin, sabit genişlikte bir sayfa ayarlamak için 100.dp: . HorizontalPager( pageCount = 4, pageSize = PageSize.Fixed(100.dp) ) { page -&gt; // page content } . Sayfaları görüntü alanı boyutuna göre boyutlandırmak için özel bir sayfa boyutu hesaplaması kullanın. Özel bir PageSize nesnesi oluşturun ve öğeler arasındaki boşluğu dikkate alarak availableSpace değerini üçe bölün: . private val threePagesPerViewport = object : PageSize { override fun Density.calculateMainAxisPageSize( availableSpace: Int, pageSpacing: Int ): Int { return (availableSpace - 2 * pageSpacing) / 3 } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#custom-page-sizes",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#custom-page-sizes"
  },"252": {
    "doc": "Pager",
    "title": "Content padding",
    "content": "HorizontalPager ve VerticalPager, sayfaların maksimum boyutunu ve hizalamasını etkilemenizi sağlayan content padding’i değiştirmeyi destekler. Örneğin, start padding’i ayarlamak sayfaları sona doğru hizalar: . HorizontalPager( pageCount = 4, contentPadding = PaddingValues(start = 64.dp), ) { page -&gt; // page content } . HorizontalPager( pageCount = 4, contentPadding = PaddingValues(horizontal = 32.dp), ) { page -&gt; // page content } . Son padding’in ayarlanması sayfaları başlangıca doğru hizalar: . HorizontalPager( pageCount = 4, contentPadding = PaddingValues(end = 64.dp), ) { page -&gt; // page content } . VerticalPager için benzer efektler elde etmek üzere top ve bottom değerlerini ayarlayabilirsiniz. 32.dp değeri burada yalnızca örnek olarak kullanılmıştır; padding boyutlarının her birini herhangi bir değere ayarlayabilirsiniz. ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#content-padding",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#content-padding"
  },"253": {
    "doc": "Pager",
    "title": "Customize scroll behavior",
    "content": "Varsayılan HorizontalPager ve VerticalPager composablelari, kaydırma hareketlerinin pager ile nasıl çalışacağını belirtir. Ancak, pagerSnapDistance veya flingBehaviour gibi varsayılanları özelleştirebilir ve değiştirebilirsiniz. Snap distance . Varsayılan olarak, HorizontalPager ve VerticalPager bir fling hareketinin her seferinde bir sayfaya kaydırabileceği maksimum sayfa sayısını ayarlar. Bunu değiştirmek için flingBehavior üzerinde pagerSnapDistance öğesini ayarlayın: . val pagerState = rememberPagerState() val fling = PagerDefaults.flingBehavior( state = pagerState, pagerSnapDistance = PagerSnapDistance.atMost(10) ) Column(modifier = Modifier.fillMaxSize()) { HorizontalPager( state = pagerState, pageCount = 10, pageSize = PageSize.Fixed(200.dp), beyondBoundsPageCount = 10, flingBehavior = fling ) { PagerSampleItem(page = it) } } . ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#customize-scroll-behavior",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/#customize-scroll-behavior"
  },"254": {
    "doc": "Pager",
    "title": "Pager",
    "content": " ",
    "url": "/docs/jetpack-compose/develop-yout-apps-layout/pager/",
    
    "relUrl": "/docs/jetpack-compose/develop-yout-apps-layout/pager/"
  },"255": {
    "doc": "Paging 2",
    "title": "Paging 2",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/paging-2/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/paging-2/"
  },"256": {
    "doc": "Paging library",
    "title": "Paging library",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-library/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-library/"
  },"257": {
    "doc": "Parcelables and bundles",
    "title": "Parcelables and bundles",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/parcelables-and-bundles/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/parcelables-and-bundles/"
  },"258": {
    "doc": "Pass data between destinations",
    "title": "Pass data between destinations",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/pass-data-between-destinations/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/pass-data-between-destinations/"
  },"259": {
    "doc": "Per-app language preferences",
    "title": "Per-app language preferences",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/perapp-language-preferences/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/perapp-language-preferences/"
  },"260": {
    "doc": "Phases",
    "title": "Jetpack Compose Phases",
    "content": "Diğer birçok UI araç seti gibi Compose da bir frame’i birkaç farklı aşamadan geçirerek oluşturur. Android View sistemine bakarsak, üç ana aşaması vardır: ölçü, layout ve çizim. Compose çok benzerdir ancak başlangıçta composition adı verilen önemli bir ek aşamaya sahiptir. Composition, Thinking in Compose, State ve Jetpack Compose dahil olmak üzere Compose dokümanlarımızda açıklanmaktadır. From data to UI: Compose phases - MAD Skills . ",
    "url": "/docs/jetpack-compose/ui-architecture/phases/#jetpack-compose-phases",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/phases/#jetpack-compose-phases"
  },"261": {
    "doc": "Phases",
    "title": "The three phases of a frame",
    "content": "Compose’un üç ana aşaması vardır: . | Composition: Hangi kullanıcı arayüzünün gösterileceği. Compose, composable fonksiyonları çalıştırır ve kullanıcı arayüzünüzün bir tanımını oluşturur. | Layout (Düzen): Kullanıcı Arayüzünün nereye yerleştirileceği. Bu aşama iki adımdan oluşur: ölçüm ve yerleştirme. Layout öğeleri, layout ağacındaki her node için kendilerini ve tüm alt öğeleri 2D koordinatlarda ölçer ve yerleştirir. | Çizim: Nasıl render edileceği. UI öğeleri, genellikle bir cihaz ekranı olan bir Canvas’a çizilir. | . Bu aşamaların sırası genellikle aynıdır ve verilerin bir çerçeve oluşturmak için composition’dan layout’a ve çizime doğru tek yönde akmasına izin verir (tek yönlü veri akışı olarak da bilinir). BoxWithConstraints ve LazyColumn ve LazyRow, child’larının composition’ının parent’ın layout aşamasına bağlı olduğu dikkate değer istisnalardır. Bu üç aşamanın neredeyse her frame için gerçekleştiğini rahatlıkla varsayabilirsiniz, ancak performans adına Compose, bu aşamaların hepsinde aynı girdilerden aynı sonuçları hesaplayacak işleri tekrarlamaktan kaçınır. Compose, daha önceki bir sonucu yeniden kullanabiliyorsa composable bir fonksiyonu çalıştırmayı atlar ve Compose UI, gerekmedikçe tüm ağacı yeniden düzenlemez veya yeniden çizmez. Compose, yalnızca kullanıcı arayüzünü güncellemek için gereken minimum miktarda işi gerçekleştirir. Compose farklı aşamalardaki state okumalarını takip ettiği için bu optimizasyon mümkündür. ",
    "url": "/docs/jetpack-compose/ui-architecture/phases/#the-three-phases-of-a-frame",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/phases/#the-three-phases-of-a-frame"
  },"262": {
    "doc": "Phases",
    "title": "State reads",
    "content": "Yukarıda listelenen aşamalardan biri sırasında bir snapshot state değerini okuduğunuzda, Compose değer okunduğunda ne yaptığını otomatik olarak izler. Bu izleme, Compose’un state değeri değiştiğinde okuyucuyu yeniden çalıştırmasını sağlar ve Compose’da state gözlemlenebilirliğinin temelini oluşturur. State genellikle mutableStateOf() kullanılarak oluşturulur ve daha sonra iki yoldan biriyle erişilir: doğrudan value property’ye erişerek veya alternatif olarak bir Kotlin property delegate kullanarak. Bunlar hakkında daha fazla bilgiyi State in composables bölümünde okuyabilirsiniz. Bu kılavuzun amaçları doğrultusunda, bir “ state okuma” bu eşdeğer erişim metotlarından birini ifade eder. // Property delegate olmadan state okuma. val paddingState: MutableState&lt;Dp&gt; = remember { mutableStateOf(8.dp) } Text( text = \"Hello\", modifier = Modifier.padding(paddingState.value) ) . // Property delegate ile state okuma. var padding: Dp by remember { mutableStateOf(8.dp) } Text( text = \"Hello\", modifier = Modifier.padding(padding) ) . Property delegate kaputunun altında, State’in değerine erişmek ve bu değeri güncellemek için “getter” ve “setter” fonksiyonları kullanılır. Bu getter ve setter fonksiyonları yalnızca property’ye değer olarak başvurduğunuzda çağrılır, oluşturulduğunda değil, bu nedenle yukarıdaki iki yol eşdeğerdir. Bir okuma durumu değiştiğinde yeniden çalıştırılabilen her kod bloğu bir yeniden başlatma kapsamıdır. Compose, state değeri değişikliklerini ve yeniden başlatma scope’larını farklı aşamalarda takip eder. ",
    "url": "/docs/jetpack-compose/ui-architecture/phases/#state-reads",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/phases/#state-reads"
  },"263": {
    "doc": "Phases",
    "title": "Phased state reads",
    "content": "Yukarıda belirtildiği gibi, Compose’da üç ana aşama vardır ve Compose bunların her birinde hangi state’in okunduğunu izler. Bu, Compose’un yalnızca kullanıcı arayüzünüzün etkilenen her bir öğesi için iş yapması gereken belirli aşamaları bildirmesine olanak tanır. Not: Bir state instance’ının nerede oluşturulduğu ve depolandığı aşamalar üzerinde çok az etkiye sahiptir, yalnızca bir state değerinin ne zaman ve nerede okunduğu önemlidir. Her bir aşamayı gözden geçirelim ve içinde bir State değeri okunduğunda ne olduğunu açıklayalım. Phase 1: Composition . Bir @Composable fonksiyonu veya lambda bloğu içindeki state okumaları, composition ve potansiyel olarak sonraki aşamaları etkiler. State değeri değiştiğinde, recomposer bu state değerini okuyan tüm composable fonksiyonların yeniden çalışmasını planlar. Çalışma zamanının, girdiler değişmemişse composable fonksiyonların bazılarını veya tamamını atlamaya karar verebileceğini unutmayın. Daha fazla bilgi için Skipping if the inputs haven’t changed bölümüne bakın. Compose UI, composition’un sonucuna bağlı olarak layout ve çizim aşamalarını çalıştırır. İçerik aynı kalırsa ve boyut ve layout değişmezse bu aşamaları atlayabilir. var padding by remember { mutableStateOf(8.dp) } Text( text = \"Hello\", // `Padding` state'i, modifier oluşturulduğunda composition aşamasında okunur. // Padding`deki değişiklikler recomposition'ı çağıracaktır. modifier = Modifier.padding(padding) ) . Phase 2: Layout . Layout aşaması iki adımdan oluşur: ölçüm ve yerleştirme. Ölçüm adımı, Layout composable’a aktarılan ölçüm lambdasını, LayoutModifier arayüzünün MeasureScope.measure yöntemini vb. çalıştırır. Yerleştirme adımı, yerleşim fonksiyonunun yerleştirme bloğunu, Modifier.offset { … } lambda bloğunu ve benzerlerini çalıştırır. Bu adımların her biri sırasında okunan state değerleri layout’u ve potansiyel olarak çizim aşamasını etkiler. State değeri değiştiğinde, Compose UI layout aşamasını planlar. Boyut veya konum değişmişse çizim aşamasını da çalıştırır. Daha kesin olmak gerekirse, ölçüm adımı ve yerleştirme adımı ayrı yeniden başlatma scopelarina sahiptir, yani yerleştirme adımındaki state okumaları bundan önceki ölçüm adımını yeniden çağırmaz. Ancak bu iki adım genellikle iç içe geçtiğinden, yerleştirme adımında okunan bir state ölçüm adımına ait diğer yeniden başlatma scope’larını etkileyebilir. var offsetX by remember { mutableStateOf(8.dp) } Text( text = \"Hello\", modifier = Modifier.offset { // `OfsetX` state'i, ofset hesaplandığında layout aşamasının yerleştirme adımında okunur. // OffsetX`deki değişiklikler layout'u yeniden başlatır. IntOffset(offsetX.roundToPx(), 0) } ) . Phase 3: Drawing . Çizim kodu sırasında okunan state, çizim aşamasını etkiler. Yaygın örnekler arasında Canvas(), Modifier.drawBehind ve Modifier.drawWithContent yer alır. State değeri değiştiğinde, Compose UI yalnızca çizim aşamasını çalıştırır. var color by remember { mutableStateOf(Color.Red) } Canvas(modifier = modifier) { // `Renk` state'i, canvas render edildiğinde çizim aşamasında okunur. // Renk`teki değişiklikler çizimi yeniden başlatır. drawRect(color) } . ",
    "url": "/docs/jetpack-compose/ui-architecture/phases/#phased-state-reads",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/phases/#phased-state-reads"
  },"264": {
    "doc": "Phases",
    "title": "Optimizing state reads",
    "content": "Compose yerelleştirilmiş state okuma takibi gerçekleştirdiğinden, her state’i uygun bir aşamada okuyarak gerçekleştirilen iş miktarını en aza indirebiliriz. Bir örneğe göz atalım. Burada, son layout pozisyonunu kaydırmak için offset değiştiricisini kullanan ve kullanıcı kaydırdıkça parallax efektine neden olan bir Image() var. Box { val listState = rememberLazyListState() Image( // ... // İdeal olmayan implementasyon! Modifier.offset( with(LocalDensity.current) { // Composition'da firstVisibleItemScrollOffset state'inin okunması (listState.firstVisibleItemScrollOffset / 2).toDp() } ) ) LazyColumn(state = listState) { // ... } } . Bu kod çalışır, ancak optimum olmayan performansla sonuçlanır. Yazıldığı gibi, kod firstVisibleItemScrollOffset state değerini okur ve bunu Modifier.offset(offset: Dp) fonksiyonuna geçirir. Kullanıcı kaydırdıkça firstVisibleItemScrollOffset değeri değişecektir. Bildiğimiz gibi, Compose okunan state’leri izler, böylece örneğimizde Box’ın içeriği olan okuma kodunu yeniden başlatabilir (yeniden çağırabilir). Bu, composition aşaması içinde okunan state’e bir örnektir. Bu hiç de kötü bir şey değildir ve aslında veri değişikliklerinin yeni kullanıcı arayüzü yaymasına izin veren recomposition’ın temelidir. Ancak bu örnekte, her kaydırma olayı tüm oluşturulabilir içeriğin yeniden değerlendirilmesine ve ardından ölçülmesine, yerleştirilmesine ve son olarak da çizilmesine neden olacağından, bu durum optimal değildir. Gösterdiğimiz şey değişmemiş olsa bile her kaydırmada Compose aşamasını tetikliyoruz, sadece gösterildiği yer değişiyor. State okumamızı yalnızca layout aşamasını yeniden tetikleyecek şekilde optimize edebiliriz. Ofset değiştiricisinin başka bir versiyonu da mevcuttur: Modifier.offset(offset: Density.() -&gt; IntOffset). Bu versiyon bir lambda parametresi alır ve elde edilen ofset lambda bloğu tarafından döndürülür. Bunu kullanmak için kodumuzu güncelleyelim: . Box { val listState = rememberLazyListState() Image( // ... // İdeal implementasyon! Modifier.offset { // Layout'ta firstVisibleItemScrollOffset state'inin okunması IntOffset(x = 0, y = listState.firstVisibleItemScrollOffset / 2) } ) LazyColumn(state = listState) { // ... } } . Peki bu neden daha performanslı? Değiştiriciye sağladığımız lambda bloğu, layout aşaması sırasında (özellikle, layout aşamasının yerleştirme adımı sırasında) çağrılır, yani firstVisibleItemScrollOffset state’imiz artık composition sırasında okunmaz. Compose state’in ne zaman okunduğunu takip ettiğinden, bu değişiklik firstVisibleItemScrollOffset değeri değişirse Compose’un yalnızca layout ve çizim aşamalarını yeniden başlatması gerektiği anlamına gelir. Not: Bir lambda parametresi almanın basit bir değer almaya kıyasla ekstra maliyet getirip getirmeyeceğini merak edebilirsiniz. Ekler. Ancak, state okumasını layout aşamasıyla sınırlandırmanın faydası bu durumda maliyetten daha ağır basar. firstVisibleItemScrollOffset değeri kaydırma sırasında her karede değişir ve state okumasını layout aşamasına erteleyerek baştan sona recompositions’tan kaçınabiliriz. Bu örnek, ortaya çıkan kodu optimize edebilmek için farklı ofset modifierlarina dayanmaktadır, ancak genel fikir doğrudur: State okumalarını mümkün olan en düşük aşamaya lokalize etmeye çalışın, böylece Compose’un minimum miktarda iş yapmasını sağlayın. Elbette, Compose aşamasında state’leri okumak genellikle kesinlikle gereklidir. Öyle olsa bile, state değişikliklerini filtreleyerek recomposition sayısını en aza indirebileceğimiz durumlar vardır. Bu konuda daha fazla bilgi için bakınız: derivedStateOf: bir veya birden fazla state nesnesini başka bir state’e dönüştürme. ",
    "url": "/docs/jetpack-compose/ui-architecture/phases/#optimizing-state-reads",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/phases/#optimizing-state-reads"
  },"265": {
    "doc": "Phases",
    "title": "Recomposition loop (cyclic phase dependency)",
    "content": "Daha önce, Compose aşamalarının her zaman aynı sırayla çağrıldığından ve aynı frame içindeyken geriye doğru gitmenin bir yolu olmadığından bahsetmiştik. Ancak bu, uygulamaların farklı frame’ler arasında composition döngülerine girmesini engellemez. Bu örneği düşünün: . Box { var imageHeightPx by remember { mutableStateOf(0) } Image( painter = painterResource(R.drawable.rectangle), contentDescription = \"I'm above the text\", modifier = Modifier .fillMaxWidth() .onSizeChanged { size -&gt; // Yapma bunu. imageHeightPx = size.height } ) Text( text = \"I'm below the image\", modifier = Modifier.padding( top = with(LocalDensity.current) { imageHeightPx.toDp() } ) ) } . Burada (kötü bir şekilde) dikey bir column uyguladık, en üstte görüntü ve altında metin var. Resmin çözümlenmiş boyutunu bilmek için Modifier.onSizeChanged() kullanıyoruz ve ardından aşağı kaydırmak için metin üzerinde Modifier.padding() kullanıyoruz. Px’den Dp’ye doğal olmayan dönüşüm zaten kodda bir sorun olduğunu gösteriyor. Bu örnekteki sorun, “son” layout’a tek bir frame içinde ulaşmamamızdır. Kod, gereksiz iş yapan ve kullanıcı için ekranda atlayan UI ile sonuçlanan birden fazla frame’in gerçekleşmesine dayanır. Neler olduğunu görmek için her bir frame’i adım adım inceleyelim: . İlk frame’in composition aşamasında, imageHeightPx 0 değerine sahiptir ve metin Modifier.padding(top = 0) ile sağlanır. Ardından, layout aşaması gelir ve onSizeChanged modifier için callback çağrılır. Bu, imageHeightPx değerinin görüntünün gerçek yüksekliğine güncellendiği zamandır. Compose, bir sonraki frame için recomposition zamanlaması yapar. Çizim aşamasında, değer değişikliği henüz yansıtılmadığından metin 0 padding ile render edilir. Compose daha sonra imageHeightPx değer değişikliği tarafından zamanlanan ikinci frame’i başlatır. State, Box content bloğunda okunur ve composition aşamasında çağrılır. Bu kez metin, görüntü yüksekliğiyle eşleşen bir padding ile sağlanır. Layout aşamasında, kod imageHeightPx değerini tekrar ayarlar, ancak değer aynı kaldığı için recomposition planlanmaz. Sonunda, metin üzerinde istenen padding’i elde ederiz, ancak padding değerini farklı bir aşamaya geri aktarmak için fazladan bir frame harcamak optimal değildir ve üst üste binen içeriğe sahip bir frame üretilmesine neden olur. Bu örnek yapmacık görünebilir, ancak bu genel modele dikkat edin: . | Modifier.onSizeChanged(), onGloballyPositioned() veya diğer bazı layout işlemleri | Bazı state’leri güncelleyin | Bu state’i bir layout modifier’a (padding(), height() veya benzeri) girdi olarak kullanın | Potansiyel olarak tekrar | . Yukarıdaki örnek için çözüm, uygun layout primitiflerini kullanmaktır. Yukarıdaki örnek basit bir Column() ile uygulanabilir, ancak özel bir şey gerektiren daha karmaşık bir örneğiniz olabilir, bu da özel bir layout yazmayı gerektirecektir. Daha fazla bilgi için Custom layouts kılavuzuna bakın. Buradaki genel prensip, birbirlerine göre ölçülmesi ve yerleştirilmesi gereken birden fazla UI öğesi için tek bir doğruluk kaynağına sahip olmaktır. Uygun bir layout primitive kullanmak veya özel bir layout oluşturmak, minimum paylaşılan üst öğenin birden fazla öğe arasındaki ilişkiyi koordine edebilecek doğruluk kaynağı olarak hizmet ettiği anlamına gelir. Dinamik bir state eklemek bu prensibi bozar. ",
    "url": "/docs/jetpack-compose/ui-architecture/phases/#recomposition-loop-cyclic-phase-dependency",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/phases/#recomposition-loop-cyclic-phase-dependency"
  },"266": {
    "doc": "Phases",
    "title": "Phases",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/phases/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/phases/"
  },"267": {
    "doc": "Play Feature Delivery",
    "title": "Play Feature Delivery",
    "content": " ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/play-feature-delivery/",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/play-feature-delivery/"
  },"268": {
    "doc": "Predictive back gesture",
    "title": "Predictive back gesture",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/predictive-back-gesture/",
    
    "relUrl": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/predictive-back-gesture/"
  },"269": {
    "doc": "Principles of navigation",
    "title": "Principles of navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/principles-of-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/principles-of-navigation/"
  },"270": {
    "doc": "Processes and app lifecycle",
    "title": "Processes and app lifecycle",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/processes-and-app-lifecycle/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/processes-and-app-lifecycle/"
  },"271": {
    "doc": "Quick Start",
    "title": "Quick Start",
    "content": "Bu sayfa surekli guncellenmekte oldugu icin bu link uzerinden takip edebilirsiniz. ",
    "url": "/docs/jetpack-compose/introduction/quick-start/",
    
    "relUrl": "/docs/jetpack-compose/introduction/quick-start/"
  },"272": {
    "doc": "Recents screen",
    "title": "Recents screen",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/recents-screen/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/recents-screen/"
  },"273": {
    "doc": "Recipes",
    "title": "Recipes",
    "content": " ",
    "url": "/docs/app-architecture/modularization/recipes/",
    
    "relUrl": "/docs/app-architecture/modularization/recipes/"
  },"274": {
    "doc": "Resource types",
    "title": "Resource types",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/resource-types/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/resource-types/"
  },"275": {
    "doc": "Restrictions on starting activities from the background",
    "title": "Restrictions on starting activities from the background",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/restrictions-on-starting-activities-from-the-background/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/restrictions-on-starting-activities-from-the-background/"
  },"276": {
    "doc": "Save UI State",
    "title": "Save UI state in Compose",
    "content": "State’inizin nereye hoist edildigine ve gerekli olan logic’e bagli olarak, UI state‘inizi depolamak ve geri yüklemek için farkli API’ler kullanabilirsiniz. Her uygulama bunu en iyi şekilde başarmak için API’lerin bir kombinasyonunu kullanır. Not: Uygulanan lojiğe bağlı olarak state’inizin nereye hoist edilecegi hakkında daha fazla bilgiyi Where to hoist state belgesinde görebilirsiniz. Herhangi bir Android uygulaması, activity veya process yeniden oluşturma nedeniyle UI state’ini kaybedebilir. Bu state kaybı aşağıdaki olaylar nedeniyle meydana gelebilir: . | Konfigürasyon değişiklikleri. Konfigürasyon değişikliği manuel olarak yapılmadığı sürece activity yok edilir ve yeniden oluşturulur. | Sistem tarafından başlatılan proses ölümü. Uygulama arka plandadır ve cihaz diğer işlemler tarafından kullanılmak üzere kaynakları (bellek gibi) serbest bırakır. | . Not: Sistem tarafından başlatılan proses ölümü, kullanıcının aktiviteyi açıkça sonlandırdığı kullanıcı tarafından başlatılan proses ölümünden farklıdır. Kullanıcı tarafından başlatılan proses ölümü durumunda, geçici state kaybı genellikle makuldür (örneğin, bir form doldurulurken animasyon state’inin veya bir TextField içeriğinin kaybedilmesi). Bu olaylardan sonra state’i korumak, olumlu bir kullanıcı deneyimi için çok önemlidir. Hangi state’in korunacağının seçilmesi, uygulamanızın benzersiz kullanıcı akışlarına bağlıdır. En iyi pratik olarak, en azından kullanıcı girdisini ve navigasyonla ilgili state’i korumalısınız. Buna örnek olarak bir listenin kaydırma konumu, kullanıcının hakkında daha fazla ayrıntı istediği öğenin ID’si, kullanıcı tercihlerinin devam eden seçimi veya metin alanlarındaki girdi verilebilir. Bu sayfa, state’inizin nereye hoist edildiğine ve buna ihtiyaç duyan logic’e bağlı olarak UI state’ini depolamak için kullanılabilen API’leri özetlemektedir. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/save-ui-state/#save-ui-state-in-compose",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/save-ui-state/#save-ui-state-in-compose"
  },"277": {
    "doc": "Save UI State",
    "title": "UI logic",
    "content": "State’iniz UI’da, composable fonksiyonlarda ya da Composition’a scope edilmiş düz state holder sınıflarında tutuluyorsa, activity ve process yeniden oluşturulurken state’i korumak için rememberSaveable’ı kullanabilirsiniz. Aşağıdaki kod parçasında, rememberSaveable tek bir boolean UI öğesi state’ini saklamak için kullanılmaktadır: . @Composable fun ChatBubble( message: Message ) { var showDetails by rememberSaveable { mutableStateOf(false) } ClickableText( text = AnnotatedString(message.content), onClick = { showDetails = !showDetails } ) if (showDetails) { Text(message.timestamp) } } . showDetails, sohbet balonunun daraltılmış veya genişletilmiş olup olmadığını saklayan boolean bir değişkendir. Önemli: Genellikle, saved instance state’te depolanan veriler, kullanıcı girdisine veya navigasyona bağlı olan geçici state’tir. Bunun örnekleri arasında bir listenin kaydırma konumu, kullanıcının hakkında daha fazla ayrıntı istediği öğenin ID’si, kullanıcı tercihlerinin devam eden seçimi veya metin alanlarındaki girdi yer alır. rememberSaveable, saved instance state mekanizması aracılığıyla UI öğesi state’ini bir Bundle‘da saklar. Primitif türleri otomatik olarak bundle’a depolayabilir. State öğeniz data class gibi primitive olmayan bir türde tutuluyorsa, Parcelize annotation’ını kullanmak, listSaver ve mapSaver gibi Compose API’lerini kullanmak veya Compose runtime Saver sınıfını extend eden özel bir saver sınıfı implemente etmek gibi farklı depolama mekanizmaları kullanabilirsiniz. Bu yöntemler hakkında daha fazla bilgi edinmek için Ways to store state belgesine bakın. Aşağıdaki kod parçasında, rememberLazyListState Compose API’si, bir LazyColumn veya LazyRow‘un kaydırma state’inden oluşan LazyListState‘i rememberSaveable kullanarak saklar. Kaydırma state’ini saklayabilen ve geri yükleyebilen özel bir saver olan bir LazyListState.Saver kullanır. Bir activity veya process yeniden oluşturulduktan sonra (örneğin, cihaz yönünü değiştirmek gibi bir konfigürasyon değişikliğinden sonra), kaydırma state’i korunur. @Composable fun rememberLazyListState( initialFirstVisibleItemIndex: Int = 0, initialFirstVisibleItemScrollOffset: Int = 0 ): LazyListState { return rememberSaveable(saver = LazyListState.Saver) { LazyListState( initialFirstVisibleItemIndex, initialFirstVisibleItemScrollOffset ) } } . Best practice . rememberSaveable, UI state’ini depolamak için bir Bundle kullanır; bu Bundle, activity’nizdeki onSaveInstanceState() çağrıları gibi ona yazan diğer API’ler tarafından da paylaşılır. Ancak bu Bundle’ın boyutu sınırlıdır ve büyük nesnelerin depolanması çalışma zamanında TransactionTooLarge exception’larına yol açabilir. Bu, özellikle uygulama genelinde aynı Bundle’ın kullanıldığı tek Activity uygulamalarında sorun yaratabilir. Bu tür bir çökmeyi önlemek için, büyük karmaşık nesneleri veya nesne listelerini Bundle’da depolamamalısınız. Bunun yerine, ID’ler veya key’ler gibi gereken minimum state’i depolayın ve daha karmaşık UI state’lerini kalıcı depolama gibi diğer mekanizmalara geri yüklemek için bunları kullanın. Not: Bazı durumlarda, tüm UI öğelerinin state’ini depolamamak kabul edilebilir. Bu tasarım seçimleri, uygulamanızın özel kullanım durumlarına ve kullanıcılarınızın nasıl davranmasını beklediğine bağlıdır. Verify state restoration . Compose öğelerinizde rememberSaveable ile saklanan state’in, activity veya process yeniden oluşturulduğunda doğru şekilde geri yüklendiğini doğrulayabilirsiniz. Bunu başarmak için StateRestorationTester gibi özel API’ler vardır. Daha fazla bilgi edinmek için Test belgelerine göz atın. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/save-ui-state/#ui-logic",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/save-ui-state/#ui-logic"
  },"278": {
    "doc": "Save UI State",
    "title": "Business logic",
    "content": "UI öğesi state‘iniz business logic’i gerektirdiği için ViewModel’e hoist edilmis ise ViewModel’in API’lerini kullanabilirsiniz. Android uygulamanızda ViewModel kullanmanın en önemli avantajlarından biri, konfigürasyon değişikliklerini sorunsuz bir şekilde gerçekleştirmesidir. Bir konfigürasyon değişikliği olduğunda ve aktivite yok edilip yeniden oluşturulduğunda, ViewModel’e hoist edilen UI state’i bellekte tutulur. Yeniden oluşturulduktan sonra, eski ViewModel instance’ı yeni activity instance’ına eklenir. Not: ViewModel, ekran düzeyinde bir state holder implementasyonu olarak, ekran UI state’ini üretmek için kullanılan business logic’i yönetir. UI state’ini ViewModel’e, konfigürasyon değişikliklerini kolayca halledeceği için değil, mimariniz için mantıklı olduğu için hoist etmelisiniz. Ancak, bir ViewModel instance’ı sistem tarafından başlatılan proses ölümünde hayatta kalamaz. UI state’inin bu durumdan kurtulmasını sağlamak için, SavedStateHandle API’sini içeren ViewModel için Saved State modülünü kullanın. Best practice . SavedStateHandle ayrıca UI state’ini depolamak için Bundle mekanizmasını kullanır, bu nedenle bunu yalnızca basit UI öğesi state’ini depolamak için kullanmalısınız. Business rule uygulayarak ve uygulamanızın UI dışındaki katmanlarına erişerek üretilen Screen UI state, potansiyel karmaşıklığı ve boyutu nedeniyle SavedStateHandle’da saklanmamalıdır. Karmaşık veya büyük verileri depolamak için lokal kalıcı depolama gibi farklı mekanizmalar kullanabilirsiniz. Bir proses yeniden oluşturulduktan sonra ekran, SavedStateHandle’da (varsa) saklanan geri yüklenmiş geçici state ile yeniden oluşturulur ve ekran UI state’i data katmanından tekrar üretilir. Not: UI state’i kaydetmenin farklı yolları hakkında daha fazla bilgi için Save UI states belgesine bakın. SavedStateHandle APIs . SavedStateHandle, özellikle UI öğesi state’ini saklamak için farklı API’lere sahiptir: . | Compose State | saveable() | . | StateFlow | getStateFlow() | . Compose State . UI öğesi state’ini MutableState olarak okumak ve yazmak için SavedStateHandle’ın saveable API’sini kullanın, böylece en az kod kurulumuyla activity ve process yeniden yaratımından kurtulur. Saveable API, kutudan çıktığı haliyle primitif türleri destekler ve tıpkı rememberSaveable() gibi custom saver kullanmak için bir stateSaver parametresi alır. Aşağıdaki kod parçacığında, message kullanıcı giriş türlerini bir TextField içine kaydeder: . class ConversationViewModel( savedStateHandle: SavedStateHandle ) : ViewModel() { var message by savedStateHandle.saveable(stateSaver = TextFieldValue.Saver) { mutableStateOf(TextFieldValue(\"\")) } private set fun update(newMessage: TextFieldValue) { message = newMessage } /*...*/ } val viewModel = ConversationViewModel(SavedStateHandle()) @Composable fun UserInput(/*...*/) { TextField( value = viewModel.message, onValueChange = { viewModel.update(it) } ) } . Saveable API kullanımı hakkında daha fazla bilgi için SavedStateHandle belgelerine bakın. Dikkat: saveable API deneyseldir. StateFlow . UI öğesi state’ini depolamak ve SavedStateHandle‘dan bir flow olarak tüketmek için getStateFlow() metodunu kullanın. StateFlow salt okunurdur ve API, yeni bir değer emit etmek üzere flow’u değiştirebilmeniz için bir key belirtmenizi gerektirir. Ayarladığınız key ile StateFlow’u alabilir ve en son değeri collect edebilirsiniz. Aşağıdaki kod parçasında, savedFilterType, bir sohbet uygulamasındaki sohbet kanalları listesine uygulanan filtre tipini saklayan bir StateFlow değişkenidir: . private const val CHANNEL_FILTER_SAVED_STATE_KEY = \"ChannelFilterKey\" class ChannelViewModel( channelsRepository: ChannelsRepository, private val savedStateHandle: SavedStateHandle ) : ViewModel() { private val savedFilterType: StateFlow&lt;ChannelsFilterType&gt; = savedStateHandle.getStateFlow( key = CHANNEL_FILTER_SAVED_STATE_KEY, initialValue = ChannelsFilterType.ALL_CHANNELS ) private val filteredChannels: Flow&lt;List&lt;Channel&gt;&gt; = combine(channelsRepository.getAll(), savedFilterType) { channels, type -&gt; filter(channels, type) }.onStart { emit(emptyList()) } fun setFiltering(requestType: ChannelsFilterType) { savedStateHandle[CHANNEL_FILTER_SAVED_STATE_KEY] = requestType } /*...*/ } enum class ChannelsFilterType { ALL_CHANNELS, RECENT_CHANNELS, ARCHIVED_CHANNELS } . Kullanıcı her yeni filtre türü seçtiğinde setFiltering çağrılır. Bu, _CHANNEL_FILTER_SAVED_STATE_KEY_ key’i ile saklanan SavedStateHandle’a yeni bir değer kaydeder. savedFilterType, key’e saklanan en son değeri emit eden bir flow’dur. filteredChannels, kanal filtrelemesini gerçekleştirmek için flow’a abone olur. getStateFlow() API’si hakkında daha fazla bilgi için SavedStateHandle belgelerine bakın. Summary . Aşağıdaki tabloda, bu bölümde ele alınan API’ler ve UI state’ini kaydetmek için her birinin ne zaman kullanılacağı özetlenmektedir: . | Event | UI logic | Business logici in a ViewModel | . | Configuration changes | rememberSaveable | Automatic | . | System-initiated process death | rememberSaveable | SavedStateHandle | . Kullanılacak API, state’in nerede tutulduğuna ve gerektirdiği lojiğe bağlıdır. UI logic‘te kullanılan state için rememberSaveable kullanın. Business logic‘te kullanılan state için, eğer bir ViewModel’de tutuyorsanız, SavedStateHandle kullanarak kaydedin. Küçük miktarlarda UI state saklamak için bundle API’lerini (rememberSaveable ve SavedStateHandle) kullanmalısınız. Bu veriler, diğer saklama mekanizmalarıyla birlikte UI’yi önceki state’ine geri döndürmek için gerekli minimum verilerdir. Örneğin, kullanıcının baktığı bir profilin ID’sini bundle’da saklarsanız, profil ayrıntıları gibi ağır verileri data katmanından getirebilirsiniz. UI state’i kaydetmenin farklı yolları hakkında daha fazla bilgi için genel Saving UI State belgesine ve mimari kılavuzunun data layer sayfasına bakın. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/save-ui-state/#business-logic",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/save-ui-state/#business-logic"
  },"279": {
    "doc": "Save UI State",
    "title": "Save UI State",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/save-ui-state/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/save-ui-state/"
  },"280": {
    "doc": "Save UI states",
    "title": "Save UI states",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/save-ui-states/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/save-ui-states/"
  },"281": {
    "doc": "Saved state module for ViewModel",
    "title": "Saved state module for ViewModel",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/saved-state-module-for-viewmodel/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/saved-state-module-for-viewmodel/"
  },"282": {
    "doc": "Saving state with fragments",
    "title": "Saving state with fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/saving-state-with-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/saving-state-with-fragments/"
  },"283": {
    "doc": "Side-effects",
    "title": "Side-effects in Compose",
    "content": "Side-effect, bir composable fonksiyonun scope’u dışında gerçekleşen, uygulamanın state’indeki bir değişikliktir. Composable’ların yaşam döngüsü ve öngörülemeyen recompositionlar, farklı sıralarda composable’ların recompositionlarını yürütme veya atılabilen recompositionlar gibi özellikleri nedeniyle, composable’lar ideal olarak side-effect içermemelidir. Bununla birlikte, bazen side-effectler, örneğin bir snackbar göstermek veya belirli bir state koşulunda başka bir ekrana gitmek gibi tek seferlik bir eylemi tetiklemek için gereklidir. Bu eylemler, composable’ın yaşam döngüsünün farkında olan kontrollü bir ortamdan çağrılmalıdır. Bu sayfada, Jetpack Compose’un sunduğu farklı side effect API’leri hakkında bilgi edineceksiniz. ",
    "url": "/docs/jetpack-compose/ui-architecture/side-effects/#side-effects-in-compose",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/side-effects/#side-effects-in-compose"
  },"284": {
    "doc": "Side-effects",
    "title": "State and effect use cases",
    "content": "Thinking in Compose belgesinde ele alındığı gibi, bileşenler side-effectsiz olmalıdır. Uygulamanın state’inde değişiklik yapmanız gerektiğinde (Managing state dokümantasyon belgesinde açıklandığı gibi), bu side-effectlerin öngörülebilir bir şekilde yürütülmesi için Effect API’lerini kullanmalısınız. Anahtar Terim: Efekt, kullanıcı arayüzü üretmeyen ve bir compostion tamamlandığında side effectlerin çalışmasına neden olan composable bir fonksiyondur. Compose’da açılan farklı olasılıklar nedeniyle, efektler kolayca aşırı kullanılabilir. İçlerinde yaptığınız işin UI ile ilgili olduğundan ve Managing state belgelerinde açıklandığı gibi tek yönlü veri akışını(Undirectional data flow) bozmadığından emin olun. Not: Responsive bir kullanıcı arayüzü doğası gereği asenkrondur ve Jetpack Compose bunu callback kullanmak yerine API seviyesinde coroutine’leri benimseyerek çözer. Coroutines hakkında daha fazla bilgi edinmek için Android’de Kotlin coroutines kılavuzuna göz atın. LaunchedEffect: bir composable scope’unda suspend fonksiyonları çalıştırır . Suspend fonksiyonlarını bir composable’ın içinden güvenli bir şekilde çağırmak için LaunchedEffect composable’ını kullanın. LaunchedEffect Composition’a girdiğinde, parametre olarak aktarılan kod bloğu ile bir coroutine başlatır. LaunchedEffect composition’dan ayrılırsa coroutine iptal edilir. LaunchedEffect farklı key’lerle yeniden oluşturulursa (aşağıdaki Restarting effects bölümüne bakın), mevcut coroutine iptal edilir ve yeni askıya alma fonksiyonu yeni bir coroutine’de başlatılır. Örneğin, bir Snackbar’ın bir Scaffold’da gösterilmesi) bir suspend fonksiyonu olan SnackbarHostState.showSnackbar fonksiyonu ile yapılır. @OptIn(ExperimentalMaterial3Api::class) @Composable fun MyScreen( state: UiState&lt;List&lt;Movie&gt;&gt;, snackbarHostState: SnackbarHostState ) { // UI state bir hata içeriyorsa, snackbar'ı göster if (state.hasError) { // LaunchedEffect`, `scaffoldState.snackbarHostState` değişirse // iptal edilecek ve yeniden başlatılacaktır LaunchedEffect(snackbarHostState) { //Bir coroutine kullanarak snackbar'ı gösterin, coroutine iptal edildiğinde snackbar //otomatik olarak kapanacaktır. state.hasError` false olduğunda ve yalnızca //`state.hasError` true olduğunda başlayın (yukarıdaki if kontrolü nedeniyle) veya //`scaffoldState.snackbarHostState` değişirse. snackbarHostState.showSnackbar( message = \"Error message\", actionLabel = \"Retry message\" ) } } Scaffold( snackbarHost = { SnackbarHost(hostState = snackbarHostState) } ) { contentPadding -&gt; // ... } } . Yukarıdaki kodda, state bir hata içeriyorsa bir coroutine tetiklenir ve içermediğinde iptal edilir. LaunchedEffect call site’i bir if ifadesi içinde olduğundan, ifade false olduğunda, eğer LaunchedEffect Composition içindeyse, kaldırılacak ve dolayısıyla coroutine iptal edilecektir. rememberCoroutineScope: composable bir coroutine dışında bir coroutine başlatmak için composition-aware bir scope elde etmek . LaunchedEffect bir composable fonksiyon olduğundan, yalnızca diğer composable fonksiyonların içinde kullanılabilir. Bir coroutine’i bir composable dışında başlatmak, ancak composition’dan ayrıldığında otomatik olarak iptal edilecek şekilde scoplamak için rememberCoroutineScope kullanın. Ayrıca, bir veya daha fazla coroutine’in yaşam döngüsünü manuel olarak kontrol etmeniz gerektiğinde, örneğin bir kullanıcı olayı gerçekleştiğinde bir animasyonu iptal etmek için rememberCoroutineScope kullanın. rememberCoroutineScope, çağrıldığı Composition noktasına bağlı bir CoroutineScope döndüren composable bir fonksiyondur. Çağrı Composition’dan ayrıldığında scope iptal edilecektir. Önceki örneği izleyerek, kullanıcı bir Button’a dokunduğunda bir Snackbar göstermek için bu kodu kullanabilirsiniz: . @OptIn(ExperimentalMaterial3Api::class) @Composable fun MoviesScreen(snackbarHostState: SnackbarHostState) { // MoviesScreen'in yaşam döngüsüne bağlı bir CoroutineScope oluşturur val scope = rememberCoroutineScope() Scaffold( snackbarHost = { SnackbarHost(hostState = snackbarHostState) } ) { contentPadding -&gt; Column(Modifier.padding(contentPadding)) { Button( onClick = { // Snackbar'ı göstermek için event handler'da yeni bir coroutine oluşturun scope.launch { snackbarHostState.showSnackbar(\"Something happened!\") } } ) { Text(\"Press me\") } } } } . rememberUpdatedState: değer değiştiğinde yeniden başlatılmaması gereken bir efektteki bir değere referans verir . Key parametrelerden biri değiştiğinde LaunchedEffect yeniden başlar. Ancak, bazı durumlarda efektinizde, değişmesi halinde efektin yeniden başlamasını istemediğiniz bir değeri yakalamak isteyebilirsiniz. Bunu yapmak için, bu değere yakalanabilecek ve güncellenebilecek bir referans oluşturmak üzere rememberUpdatedState kullanılması gerekir. Bu yaklaşım, yeniden oluşturulması ve yeniden başlatılması pahalı veya engelleyici olabilecek uzun ömürlü işlemler içeren efektler için yararlıdır. Örneğin, uygulamanızda bir süre sonra kaybolan bir LandingScreen olduğunu varsayalım. LandingScreen yeniden oluşturulsa bile, bir süre bekleyen ve zamanın geçtiğini bildiren efekt yeniden başlatılmamalıdır: . @Composable fun LandingScreen(onTimeout: () -&gt; Unit) { // Bu her zaman LandingScreen'in yeniden oluşturulduğu // en son onTimeout fonksiyonuna referansta bulunacaktır val currentOnTimeout by rememberUpdatedState(onTimeout) // LandingScreen'in yaşam döngüsüyle eşleşen bir efekt oluşturun. // LandingScreen yeniden oluşturulursa, delay yeniden başlamamalıdır. LaunchedEffect(true) { delay(SplashWaitTimeMillis) currentOnTimeout() } /* Landing screen content */ } . Call site’in yaşam döngüsüyle eşleşen bir efekt oluşturmak için Unit veya true gibi hiç değişmeyen bir constant parametre olarak geçirilir. Yukarıdaki kodda, LaunchedEffect(true) kullanılmıştır. onTimeout lambda’sının her zaman LandingScreen’in yeniden oluşturulduğu en son değeri içerdiğinden emin olmak için, onTimeout’un rememberUpdatedState fonksiyonuyla sarılması gerekir. Döndürülen State, koddaki currentOnTimeout, efektte kullanılmalıdır. Uyarı: LaunchedEffect(true), while(true) kadar şüphelidir. Bunun için geçerli kullanım durumları olsa da, her zaman duraklayın ve ihtiyacınız olanın bu olduğundan emin olun. DisposableEffect: temizlenmesi gereken efektler . Key’ler değiştikten sonra veya composable Composition’dan ayrıldığında temizlenmesi gereken side-effectler için DisposableEffect kullanın. DisposableEffect key’leri değişirse, composable’ın mevcut efektini dispose etmesi (temizlemesi) ve efekti tekrar çağırarak sıfırlaması gerekir. Örnek olarak, bir LifecycleObserver kullanarak Yaşam Döngüsü olaylarına dayalı analiz olayları göndermek isteyebilirsiniz. Compose’da bu olayları dinlemek için, gerektiğinde gözlemciyi kaydetmek ve kaydını kaldırmak üzere bir DisposableEffect kullanın. @Composable fun HomeScreen( lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current, onStart: () -&gt; Unit, // 'Başlatıldı' analitik olayını gönderin onStop: () -&gt; Unit // 'Durduruldu' analitik olayını gönderin ) { // Yeni bir lambda sağlandığında mevcut lambdaları güvenli bir şekilde güncelleyin val currentOnStart by rememberUpdatedState(onStart) val currentOnStop by rememberUpdatedState(onStop) // Eğer `lifecycleOwner` değişirse, efekti atın ve sıfırlayın DisposableEffect(lifecycleOwner) { // Analitik olayları göndermek için hatırlanan geri aramalarımızı (remembered callbacks) // tetikleyen bir gözlemci oluşturun val observer = LifecycleEventObserver { _, event -&gt; if (event == Lifecycle.Event.ON_START) { currentOnStart() } else if (event == Lifecycle.Event.ON_STOP) { currentOnStop() } } // Gözlemciyi yaşam döngüsüne ekleme lifecycleOwner.lifecycle.addObserver(observer) // Efekt Composition'dan ayrıldığında, gözlemciyi kaldırın onDispose { lifecycleOwner.lifecycle.removeObserver(observer) } } /* Home screen content */ } . Yukarıdaki kodda, efekt gözlemciyi lifecycleOwner’a ekleyecektir. LifecycleOwner değişirse, efekt dispose edilir ve yeni lifecycleOwner ile yeniden başlatılır. Bir DisposableEffect, kod bloğundaki son deyim olarak bir onDispose cümlesi içermelidir. Aksi takdirde, IDE derleme zamanı hatası görüntüler. Not: onDispose’da boş bir blok olması iyi bir pratik değildir. Kullanım durumunuza daha iyi uyan bir efekt olup olmadığını görmek için her zaman yeniden düşünün . SideEffect: Compose state’i compose olmayan koda yayınla . Compose state’i compose tarafından yönetilmeyen nesnelerle paylaşmak için SideEffect composable’ı kullanın, çünkü her başarılı recomposition’da çağrılır. Örneğin, analiz kütüphaneniz, sonraki tüm analiz olaylarına özel meta veriler (bu örnekte “kullanıcı özellikleri”) ekleyerek kullanıcı popülasyonunuzu bölümlere ayırmanıza izin verebilir. Geçerli kullanıcının kullanıcı türünü analiz kütüphanenize iletmek için, değerini güncellemek üzere SideEffect’i kullanın. @Composable fun rememberFirebaseAnalytics(user: User): FirebaseAnalytics { val analytics: FirebaseAnalytics = remember { FirebaseAnalytics() } // Her başarılı composition'da, FirebaseAnalytics'i mevcut Kullanıcının userType'ı ile // güncelleyerek gelecekteki analizlerin olaylarına // bu meta veri eklenmiştir SideEffect { analytics.setUserProperty(\"userType\", user.userType) } return analytics } . produceState: Compose olmayan state’i Compose state’e dönüştürür . produceState, değerleri döndürülen bir State’e aktarabilen Composition scope’ndaki bir coroutine’i başlatır. Compose olmayan state’i Compose state’e dönüştürmek için kullanın, örneğin Flow, LiveData veya RxJava gibi harici abonelik odaklı state’i Composition’a getirmek gibi. Producer, produceState Composition’a girdiğinde başlatılır ve Composition’dan çıktığında iptal edilir. Döndürülen State birleştirilir; aynı değerin ayarlanması recomposition’u tetiklemez. produceState bir coroutine oluştursa da, non-suspending veri kaynaklarını gözlemlemek için de kullanılabilir. Bu kaynağa aboneliği kaldırmak için awaitDispose fonksiyonunu kullanın. Aşağıdaki örnekte, ağdan bir görüntü yüklemek için produceState’in nasıl kullanılacağı gösterilmektedir. loadNetworkImage composable fonksiyonu, diğer composable’larda kullanılabilecek bir State döndürür. @Composable fun loadNetworkImage( url: String, imageRepository: ImageRepository = ImageRepository() ): State&lt;Result&lt;Image&gt;&gt; { //Başlangıç değeri olarak Result.Loading ile bir State&lt;T&gt; oluşturur // Eğer `url` veya `imageRepository` değişirse, çalışan producer iptal olur // ve yeni girdilerle yeniden başlatılır. return produceState&lt;Result&lt;Image&gt;&gt;(initialValue = Result.Loading, url, imageRepository) { // Bir coroutine içinde, suspend çağrıları yapabilir val image = imageRepository.load(url) // State'i bir Error veya Success sonucuyla güncelleyin. // Bu, bu State'in okunduğu bir recomposition'ı tetikleyecektir value = if (image == null) { Result.Error } else { Result.Success(image) } } } . Not: Geri dönüş türüne sahip Composable’lar, normal bir Kotlin fonksiyonunu adlandırdığınız şekilde, küçük harfle başlayarak adlandırılmalıdır. Anahtar Nokta: Kaputun altında, produceState diğer efektlerden yararlanır! remember { mutableStateOf(initialValue) } kullanarak bir sonuç değişkenini tutar ve bir LaunchedEffect’teki producer bloğunu tetikler. Producer bloğunda değer her güncellendiğinde, sonuç durumu yeni değere güncellenir. Mevcut API’lerin üzerine inşa ederek kendi efektlerinizi kolayca oluşturabilirsiniz. derivedStateOf: bir veya birden fazla state nesnesini başka bir state’e dönüştürür . Belirli bir state hesaplandığında veya diğer state nesnelerinden türetildiğinde derivedStateOf fonksiyonunu kullanın. Bu fonksiyonun kullanılması, hesaplamanın yalnızca hesaplamada kullanılan state’lerden biri değiştiğinde gerçekleşeceğini garanti eder. Aşağıdaki örnekte, kullanıcı tanımlı yüksek öncelikli anahtar kelimelere sahip görevlerin önce göründüğü temel bir Yapılacaklar listesi gösterilmektedir: . @Composable fun TodoList(highPriorityKeywords: List&lt;String&gt; = listOf(\"Review\", \"Unblock\", \"Compose\")) { val todoTasks = remember { mutableStateListOf&lt;String&gt;() } //Yüksek öncelikli görevleri yalnızca todoTasks veya highPriorityKeywords olduğunda hesaplayın //değişim, her recomposition'da değil val highPriorityTasks by remember(highPriorityKeywords) { derivedStateOf { todoTasks.filter { task -&gt; highPriorityKeywords.any { keyword -&gt; task.contains(keyword) } } } } Box(Modifier.fillMaxSize()) { LazyColumn { items(highPriorityTasks) { /* ... */ } items(todoTasks) { /* ... */ } } /* Rest of the UI where users can add elements to the list */ } } . Yukarıdaki kodda, derivedStateOf todoTasks değiştiğinde highPriorityTasks hesaplamasının gerçekleşeceğini ve kullanıcı arayüzünün buna göre güncelleneceğini garanti eder. highPriorityKeywords değişirse, remember bloğu çalıştırılacak ve yeni bir türetilmiş state nesnesi oluşturulacak ve eskisinin yerine hatırlanacaktır. highPriorityTasks’ı hesaplamak için filtreleme pahalı olabileceğinden, her recomposition’da değil, yalnızca listelerden herhangi biri değiştiğinde çalıştırılmalıdır. Ayrıca, derivedStateOf tarafından üretilen state’te yapılan bir güncelleme, bildirildiği composable’ın yeniden oluşturulmasına neden olmaz, Compose yalnızca döndürülen state’in okunduğu composable’ları yeniden oluşturur, örnekteki LazyColumn içinde. Kod ayrıca highPriorityKeywords’ün todoTasks’tan çok daha az sıklıkta değiştiğini varsayar. Eğer durum böyle olmasaydı, kod derivedStateOf yerine remember(todoTasks, highPriorityKeywords) kullanabilirdi. snapshotFlow: Compose’un State’ini Flow’lara dönüştürür . [State ](https://developer.android.com/reference/kotlin/androidx/compose/runtime/State) nesnelerini cold Flow'a dönüştürmek için [snapshotFlow](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#snapshotFlow(kotlin.Function0)) kullanın. snapshotFlow collect edidiginde bloğunu çalıştırır ve içinde okunan State nesnelerinin sonucunu yayar(emit eder). snapshotFlow bloğu içinde okunan State nesnelerinden biri değiştiğinde, yeni değer önceki yayılan değere [eşit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html) değilse Flow yeni değeri collector'ına yayar (bu davranış [Flow.distinctUntilChanged](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html)'e benzer). Aşağıdaki örnekte, kullanıcı bir listedeki ilk öğeyi analize scroll ettiginde kayıt yapan bir side effect gösterilmektedir: . val listState = rememberLazyListState() LazyColumn(state = listState) { // ... } LaunchedEffect(listState) { snapshotFlow { listState.firstVisibleItemIndex } .map { index -&gt; index &gt; 0 } .distinctUntilChanged() .filter { it == true } .collect { MyAnalyticsService.sendScrolledPastFirstItemEvent() } } . Yukarıdaki kodda, listState.firstVisibleItemIndex, Flow’un operatörlerinin gücünden yararlanabilen bir Flow’a dönüştürülür. ",
    "url": "/docs/jetpack-compose/ui-architecture/side-effects/#state-and-effect-use-cases",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/side-effects/#state-and-effect-use-cases"
  },"285": {
    "doc": "Side-effects",
    "title": "Restarting effects",
    "content": "Compose’daki LaunchedEffect, produceState veya DisposableEffect gibi bazı efektler, çalışan efekti iptal etmek ve yeni key’lerle yeni bir efekt başlatmak için kullanılan değişken sayıda argüman, key alır. Bu API’ler için tipik biçim şöyledir: . EffectName(restartIfThisKeyChanges, orThisKey, orThisKey, ...) { block } . Bu davranışın incelikleri nedeniyle, efekti yeniden başlatmak için kullanılan parametreler doğru değilse sorunlar ortaya çıkabilir: . | Efektleri olması gerekenden daha az yeniden başlatmak uygulamanızda hatalara neden olabilir. | Efektleri olması gerekenden daha fazla yeniden başlatmak verimsiz olabilir. | . Genel bir kural olarak, efekt kod bloğunda kullanılan mutable ve immutable değişkenler efekt composable’a parametre olarak eklenmelidir. Bunların dışında, efekti yeniden başlatmaya zorlamak için daha fazla parametre eklenebilir. Eğer bir değişkenin değişmesi efektin yeniden başlamasına neden olmuyorsa, değişken rememberUpdatedState’e sarılmalıdır. Değişken hiçbir zaman değişmiyorsa, çünkü hiçbir key’i olmayan bir remember’a sarılmışsa, değişkeni efekte key olarak geçirmenize gerek yoktur. Önemli Nokta: Bir efektte kullanılan değişkenler, efektin composable parametresi olarak eklenmeli veya rememberUpdatedState kullanılmalıdır. Yukarıda gösterilen DisposableEffect kodunda, efekt parametre olarak bloğunda kullanılan lifecycleOwner’ı alır, çünkü bunlarda yapılacak herhangi bir değişiklik efektin yeniden başlamasına neden olmalıdır. @Composable fun HomeScreen( lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current, onStart: () -&gt; Unit, // 'started' analiz olayını gönder onStop: () -&gt; Unit // 'stopped' analiz olayını gönder ) { // Bu değerler Composition'da asla değişmez val currentOnStart by rememberUpdatedState(onStart) val currentOnStop by rememberUpdatedState(onStop) DisposableEffect(lifecycleOwner) { val observer = LifecycleEventObserver { _, event -&gt; /* ... */ } lifecycleOwner.lifecycle.addObserver(observer) onDispose { lifecycleOwner.lifecycle.removeObserver(observer) } } } . currentOnStart ve currentOnStop, DisposableEffect key’leri olarak gerekli değildir, çünkü rememberUpdatedState kullanımı nedeniyle değerleri Composition’da asla değişmez. LifecycleOwner’ı bir parametre olarak geçmezseniz ve değişirse, HomeScreen yeniden oluşturulur, ancak DisposableEffect atılmaz ve yeniden başlatılmaz. Bu sorunlara neden olur çünkü o noktadan itibaren yanlış lifecycleOwner kullanılır. Key olarak sabitler . Call site’in yaşam döngüsünü takip etmesini sağlamak için efekt key’i olarak true gibi bir sabit kullanabilirsiniz. Yukarıda gösterilen LaunchedEffect örneğinde olduğu gibi, bunun için geçerli kullanım durumları vardır. Ancak, bunu yapmadan önce iki kez düşünün ve ihtiyacınız olanın bu olduğundan emin olun. ",
    "url": "/docs/jetpack-compose/ui-architecture/side-effects/#restarting-effects",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/side-effects/#restarting-effects"
  },"286": {
    "doc": "Side-effects",
    "title": "Side-effects",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/side-effects/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/side-effects/"
  },"287": {
    "doc": "State holders and UI state",
    "title": "State holders and UI state",
    "content": "UI layer kılavuzu, UI katmanı için UI State oluşturma ve yönetme aracı olarak tek yönlü veri akışını (UDF) tartışır. Ayrıca, UDF yönetimini state holder adı verilen özel bir sınıfa devretmenin faydalarını da vurgular. Bir state holderi ViewModel veya düz bir sınıf aracılığıyla uygulayabilirsiniz. Bu dokümantasyon, state holderleri ve UI katmanında oynadıkları role daha yakından bakıyor. Bu belgenin sonunda, UI katmanında application state’inin nasıl yönetileceğini anlamalısınız; bu, UI state production pipelinedir. Aşağıdakileri anlayabilmeli ve bilmelisiniz: . | UI katmanında bulunan UI state türlerini anlayın. | UI katmanındaki bu UI stateleri üzerinde çalışan logic türlerini anlayın. | ViewModel veya basit bir sınıf gibi bir state holderin uygun implementasyonunu nasıl seçeceğinizi öğrenin. | . State holders and state production in the UI Layer . Elements of the UI state production pipeline . UI state ve onu üreten logic, UI katmanını tanımlar. UI state . UI state, UI’yi tanımlayan propertydir. İki tür UI state vardır: . | Screen UI State, ekranda görüntülemeniz gereken şeydir. Örneğin, bir NewsUiState sınıfı, UI oluşturmak için gereken haber makalelerini ve diğer bilgileri içerebilir. Bu state, uygulama verilerini içerdiğinden genellikle hiyerarşinin diğer katmanlarıyla bağlantılıdır. | UI element state, UI elementlerinin nasıl oluşturulduğunu etkileyen, onlara özgü propertyleri ifade eder. Bir UI elementi gösterilebilir veya gizlenebilir ve belirli bir yazı tipine, yazı tipi boyutuna veya yazı tipi rengine sahip olabilir. Androide, View, doğası gereği stateful olduğu için bu state’i kendisi yönetir ve state’i değiştirmek veya sorgulamak için methodlar sunar. Bunun bir örneği, text için TextView sınıfının get ve set methodlaridir. Jetpack Compose’da state composable olanın dışındadır ve hatta onu composable olanın hemen yakınından çağıran composable fonksiyona veya bir state holderine hoist edebilirsiniz. Bunun bir örneği, composable Scaffold için ScaffoldState’tir. | . Logic . Uygulama verileri ve kullanıcı eventleri, UI state’inin zaman içinde değişmesine neden olduğundan, UI state statik bir property değildir. Logic, UI state’inin hangi bölümlerinin değiştiği, neden değiştiği ve ne zaman değişmesi gerektiği dahil olmak üzere değişikliğin özelliklerini belirler. Logic, business logic veya UI logic olabilir: . | Business logic, uygulama verileri için ürün gereksinimlerinin implemente edilmesidir. Örneğin, kullanıcı butona dokunduğunda bir haber okuyucu uygulamasında bir makaleye yer işareti koyma. Bir yer imini bir dosyaya veya veritabanına kaydetme logic’i genellikle domain veya data katmanlarına yerleştirilir. State holder genellikle bu logic’i, ortaya çıkardıkları metodları çağırarak bu katmanlara devreder. | UI logic, UI state’inin ekranda nasıl görüntüleneceği ile ilgilidir. Örneğin, kullanıcı bir kategori seçtiğinde doğru arama çubuğu hint elde etmek, bir listede belirli bir öğeye kaydırma yapmak veya kullanıcı bir butona tıkladığında belirli bir ekrana navigate etme logic’i. | . Android lifecycle and the types of UI state and logic . UI katmanının iki bölümü vardır: UI lifecycle’a biri bağımlı, diğeri bağımsız. Bu ayrım, her fragmentin kullanabileceği veri kaynaklarını belirler ve bu nedenle farklı türde UI state ve logic gerektirir. | UI yaşam döngüsünden bağımsız(UI lifecycle independent): UI katmanının bu kısmı, uygulamanın veri üreten katmanlarıyla (data veya domain katmanları) ilgilenir ve business logic tarafından tanımlanır. UI’deki lifecycle, configuration changes ve activity oluşturma, UI state production pipeline in etkin olup olmadığını etkileyebilir, ancak üretilen verilerin geçerliliğini etkilemez. | UI yaşam döngüsüne bağlı(UI lifecycle dependent): UI katmanının bu kısmı, UI logici ile ilgilenir ve lifecycle veya configuration changeden doğrudan etkilenir. Bu değişiklikler, içinde okunan veri kaynaklarının geçerliliğini doğrudan etkiler ve sonuç olarak state ancak lifecycle aktif olduğunda değişebilir. Buna örnek olarak runtime izinleri ve localized stringler gibi yapılandırmaya bağlı kaynakların alınması dahildir. | . Yukarıdakiler aşağıdaki tablo ile özetlenebilir: . | Ui Lifecycle independent | Ui Lifecycle dependent | . | Business logic | UI logic | . | Screen UI state |   | . The UI state production pipeline . UI state production pipeline, UI state oluşturmak için atilan adımları ifade eder. Bu adımlar, daha önce tanımlanan logic türlerinin uygulanmasını içerir ve tamamen UI gereksinimlerine bağlıdır. Bazı UI’ler, pipeline’in hem UI Lifecycle independent hem de UI Lifecycle dependent bölümlerinden yararlanabilir veya hiçbirinden yararlanamaz. Yani, UI katman pipeline’in aşağıdaki permütasyonları geçerlidir: . | UI’in kendisi tarafından üretilen ve yönetilen UI state. Örneğin, basit, yeniden kullanılabilir bir temel sayaç: | . @Composable fun Counter() { // The UI state is managed by the UI itself var count by remember { mutableStateOf(0) } Row { Button(onClick = { ++count }) { Text(text = \"Increment\") } Button(onClick = { --count }) { Text(text = \"Decrement\") } } } . | UI logic → UI. Örneğin, kullanıcının bir listenin en üstüne atlamasına olanak tanıyan bir butonu göstermek veya gizlemek. | . @Composable fun ContactsList(contacts: List&lt;Contact&gt;) { val listState = rememberLazyListState() val isAtTopOfList by remember { derivedStateOf { listState.firstVisibleItemIndex &lt; 3 } } // Create the LazyColumn with the lazyListState ... // Show or hide the button (UI logic) based on the list scroll position AnimatedVisibility(visible = !isAtTopOfList) { ScrollToTopButton() } } . | Business logic → UI. Geçerli kullanıcının fotoğrafını ekranda gösteren bir UI elementi. | . @Composable fun UserProfileScreen(viewModel: UserProfileViewModel = hiltViewModel()) { // Read screen UI state from the business logic state holder val uiState by viewModel.uiState.collectAsStateWithLifecycle() // Call on the UserAvatar Composable to display the photo UserAvatar(picture = uiState.profilePicture) } . | Business logic → UI logic → UI.Belirli bir UI state için ekranda doğru bilgileri görüntülemek üzere kayan bir UI element. | . @Composable fun ContactsList(viewModel: ContactsViewModel = hiltViewModel()) { // Read screen UI state from the business logic state holder val uiState by viewModel.uiState.collectAsStateWithLifecycle() val contacts = uiState.contacts val deepLinkedContact = uiState.deepLinkedContact val listState = rememberLazyListState() // Create the LazyColumn with the lazyListState ... // Perform UI logic that depends on information from business logic if (deepLinkedContact != null &amp;&amp; contacts.isNotEmpty()) { LaunchedEffect(listState, deepLinkedContact, contacts) { val deepLinkedContactIndex = contacts.indexOf(deepLinkedContact) if (deepLinkedContactIndex &gt;= 0) { // Scroll to deep linked item listState.animateScrollToItem(deepLinkedContactIndex) } } } } . UI state production pipeline her iki tür mantığın da uygulandığı durumda, business logic her zaman UI logicten önce uygulanmalıdır. UI logicinden sonra busines logici uygulamaya çalışmak, business logicin UI logice bağlı olduğu anlamına gelir. Aşağıdaki bölümler, farklı logic türlerine ve state holderlerine derinlemesine bir bakışla bunun neden bir sorun olduğunu ele almaktadır. State holders and their responsibilities . State holderin sorumluluğu, uygulamanın okuyabilmesi için state’i saklamaktır. Logice ihtiyaç duyulan durumlarda aracılık yaparak gerekli logici barındıran veri kaynaklarına erişim sağlar. Bu şekilde, state holder logici uygun veri kaynağına devreder. Bu, aşağıdaki faydaları sağlar: . | Basit UI’lar: UIsadece state’ini bağlar. | Sürdürülebilirlik: State holderda tanımlanan logic, UI’in kendisi değiştirilmeden yinelenebilir. | Test Edilebilirlik: UI ve state production logici bağımsız olarak test edilebilir. | Okunabilirlik: Kodu okuyanlar, UI presentation kodu ile UI state production kodu arasındaki farkları açıkça görebilir. | . Boyutu veya kapsamı ne olursa olsun, her UI elementinin karşılık gelen state holderi ile 1:1 ilişkisi vardır. Ayrıca, bir state holderin, bir UI state değişikliği ile sonuçlanabilecek herhangi bir kullanıcı eylemini kabul edebilmesi ve işleyebilmesi ve ardından gelen state değişikliğini üretebilmesi gerekir. Not: State holderler kesinlikle gerekli değildir. Basit UI’kar, logiclerini presentation kodlarıyla inline olarak barındırabilir. Types of state holders . UI state’i ve logic’i tiplerini benzer şekilde, UI katmanında, UI yaşam döngüsüyle olan ilişkilerine göre tanımlanan iki tür state holder vardır: . | The business logic state holder. | The UI logic state holder. | . Aşağıdaki bölümlerde, business logic state holderinden başlayarak state holderlerin türlerine daha yakından bakılmaktadır. Not: Bir UI logic state holderi, data veya domain katmanlarından gelen bilgilere bağlıysa, bu bilgileri ona bir business logic state holderinden iletmelisiniz. Bunun nedeni, business logic state holderinin, UI yaşam döngüsünden bağımsız olduğu için UI logici state holderinden daha uzun ömürlü olmasıdır. Business logic and its state holder . Business logic state holderlari, kullanıcı eventlerini handle eder ve verileri data veya domain katmanlarından ekran UI state’ine dönüştürür. Android yaşam döngüsü ve uygulama configuration changes göz önünde bulundurulduğunda optimum kullanıcı deneyimi sağlamak için business logic kullanan state holderlerini aşağıdaki özelliklere sahip olması gerekir: . | Property | Detail | . | Produces UI State(UI State uretmek) | Business logic state holderlar, UI için UI state’i oluşturmaktan sorumludur. Bu UI state’i, genellikle kullanıcı eventlerinin handle edilmesiyle ve domain ve data katmanlarından verilerin okunmasının sonucudur. | . | Retained through activity recreation(activitynin yeniden olusturulmasina karsi korumak) | Business logic state holderlar, Activity’nin yeniden oluşturulması karsisinda state ve state processing pipelinelerini koruyarak sorunsuz bir kullanıcı deneyimi sağlamaya yardımcı olur. State holderin korunmadigi ve yeniden yaratıldığı durumlarda (genellikle işlem ölümünden sonra), state holderin tutarlı bir kullanıcı deneyimi sağlamak için son state’i kolayca yeniden oluşturabilmesi gerekir. | . | Possess long lived state(uzun omurlu state tutmak) | Business logic state holderlari genellikle navigasyon destinationlari için state’i yönetmek amacila kullanılır. Sonuç olarak, genellikle navigasyon graphden kaldırılana kadar statelerini navigasyon değişikliklerinde korurlar. | . | Is unique to its UI and is not reusable(Kullanıcı arayüzüne özgüdür ve yeniden kullanılamaz) | Business logic state holderleri tipik olarak belirli bir uygulama fonksiyonaltesi icin üretilir, örneğin bir TaskEditViewModel veya bir TaskListViewModel için state üretir ve bu nedenle yalnızca o uygulama fonksiyonalitesi için geçerlidir. Aynı state holder, farklı form faktörlerinde bu uygulama fonksiyonalitelerini destekleyebilir. Örneğin, uygulamanın mobil, TV ve tablet sürümleri aynı business logic state holderini yeniden kullanabilir. | . Not: Business logic state holderlar; ViewModel instancelari yukarıda belirtilen özelliklerin birçoğunu, özellikle de Activity yeniden oluşturma sırasında hayatta kaldigi icin, tipik olarak bir ViewModel instance ile implement edilirler. Örneğin, “Now in Android” uygulamasında yazar navigation hedefini göz önünde bulundurun: . Business logic state holder olarak hareket eden AuthorViewModel, bu durumda UI state’ini üretir: . @HiltViewModel class AuthorViewModel @Inject constructor( savedStateHandle: SavedStateHandle, private val authorsRepository: AuthorsRepository, newsRepository: NewsRepository ) : ViewModel() { val uiState: StateFlow&lt;AuthorScreenUiState&gt; = … // Business logic fun followAuthor(followed: Boolean) { … } } . AuthorViewModel’in daha önce belirtilen business logic state holder özelliklere sahip olduğuna dikkat edin: . | Property | Detail | . | Produces AuthorScreenUiState | The AuthorViewModel reads data from the AuthorsRepository and NewsRepository and uses that data to produce AuthorScreenUiState. It also applies business logic when the user wants to follow or unfollow an Author by delegating to the AuthorsRepository. | . | Has access to the data layer | An instance of AuthorsRepository and NewsRepository are passed to it in its constructor, allowing it to implement the business logic of following an Author. | . | Survives Activity recreation | Because it is implemented with a ViewModel, it will be retained across quick Activity recreation. In the case of process death, the SavedStateHandle object can be read from to provide the minimum amount of information required to restore the UI state from the data layer. | . | Possesses long lived state | The ViewModel is scoped to the navigation graph, therefore unless the author destination is removed from the nav graph, the UI state in the uiState StateFlow remains in memory. The use of the StateFlow also adds the benefit of making the application of the business logic that produces the state lazy because state is only produced if there is a collector of the UI state. | . | Is unique to its UI | The AuthorViewModel is only applicable to the author navigation destination and cannot be reused anywhere else. If there is any business logic that is reused across navigation destinations, that business logic must be encapsulated in a data- or domain-layer-scoped component. | . Not: ViewModel’i yalnızca destination düzeyinde UI ile kullanmalısınız. Bunları, UI’in arama çubukları veya chip grupları gibi yeniden kullanılabilir parçalarında kullanmamalısınız. Bu durumlarda düz sınıflar daha uygundur. Uyarı: ViewModel instancelarini diğer composable fonksiyonlara argüman olarak vermeyin. Bunu yapmak, composable fonksiyonu ViewModel türüyle birleştirerek daha az yeniden kullanılabilir ve test edilmesini ve önizlemesini zorlaştırır. Ayrıca, ViewModel instancesini yöneten net bir tek doğruluk kaynağı (SSOT) olmayacaktır. ViewModel’i devre dışı bırakmak, birden çok composable öğenin ViewModel fonksiyonlarini çağırmasına ve state’i değiştirmesine izin vererek hataların debugini zorlaştırır. Bunun yerine, UDF best practicelerini izleyin ve yalnızca gerekli state’i iletin. Aynı şekilde, yayılan eventleri ViewModel’in composable SSOT’sine ulaşana kadar iletin. Eventi handle eden ve karşılık gelen ViewModel methodlarini çağıran SSOT budur. The ViewModel as a business logic state holder . ViewModels’in Android geliştirmedeki faydaları, onları business logice erişim sağlamak ve uygulama verilerini ekranda presentation için hazırlamak için uygun hale getirir. Bu faydalar aşağıdakileri içerir: . | ViewModels tarafından tetiklenen işlemler configuration changelerden kurtulur . | Navigasyon ile Entegrasyon saglar; . | Navigasyon, ekran backstackde iken ViewModels’i önbelleğe(cacheler) alır. Bu, destinationunuza döndüğünüzde önceden yüklenmiş verilerinizin anında kullanılabilir olması açısından önemlidir. Bu, composable ekranın yaşam döngüsünü observe eden bir state holder ile yapılması daha zor bir şeydir. | ViewModel, hedef backstackden çıkarıldığında da temizlenir ve state’inizin otomatik olarak temizlenmesini sağlar. Bu, yeni bir ekrana gitme, bir configuration change nedeniyle veya başka nedenler gibi birçok nedenden dolayı meydana gelebilecek composable imhayı dinlemekten farklıdır. | . | Hilt gibi diğer Jetpack library ile entegrasyon saglar. | . Not: ViewModel avantajları kullanım durumunuz için geçerli değilse veya işleri farklı bir şekilde yapıyorsanız, ViewModel’in sorumluluklarını düz state holder sınıflara taşıyabilirsiniz. UI logic and its state holder . UI logic, UI’nin kendisinin sağladığı veriler üzerinde çalışan logictir. Bu, UI elementlerinin state’inde veya permissions API’si veya Resources gibi UI data kaynaklarında olabilir. UI logicini kullanan state holderlar tipik olarak aşağıdaki özelliklere sahiptir: . | UI state’ini üretir ve UI elementlerinin state’ini yönetir. | Activity’i yeniden olusturma durumunda hayatta kalmaz; UI logicinde barındırılan state holderlar, genellikle UI’nin kendisinden gelen veri kaynaklarına bağımlıdır ve bu bilgileri yapılandırma değişiklikleri boyunca tutmaya çalışmak, genellikle bir bellek sızıntısına neden olur. State holderlar, yapılandırma değişikliklerinde devam etmek için verilere ihtiyaç duyarsa, hayatta kalan Aktivite yeniden olusturulmasina daha uygun başka bir componente yetki vermeleri gerekir. Örneğin, Jetpack Compose’da, remembered fonksiyonlarla oluşturulan Composable UI element stateleri, Activity yeniden olusturulmasi boyunca state’i korumak için genellikle rememberSaveable’a yetki verir. Bu tür fonksiyonlarin örnekleri arasında, rememberScaffoldState() ve rememberLazyListState() bulunur. | UI scopeindaki veri kaynaklarına referansları vardır: UI logic state holder, UI ile aynı yaşam döngüsüne sahip olduğundan, yaşam döngüsü API’leri ve Resources gibi veri kaynaklarına güvenle başvurulabilir ve okunabilir. | Birden çok UI’de yeniden kullanılabilir: Aynı UI logic state holderinin farklı instancelari, uygulamanın farklı bölümlerinde yeniden kullanılabilir. Örneğin, bir chip grubu için kullanıcı input eventlerini yönetmek için bir state holder, filter chipleri için bir arama sayfasında ve ayrıca bir e-posta alıcıları için “to” fieldi için kullanılabilir. | . UI logic state holder, tipik olarak düz bir sınıfla uygulanır. Bunun nedeni, UI logic state holderinin oluşturulmasından UI’nin kendisinin sorumlu olması ve UI logic state holderinin, UI’nin kendisi ile aynı yaşam döngüsüne sahip olmasıdır. Örneğin Jetpack Compose’da state holder, Composition’un bir parçasıdır ve Composition’un yaşam döngüsünü takip eder. Not: Düz sınıf state holderleri, UI logici, UI’den taşınacak kadar karmaşık olduğunda kullanılır. Aksi takdirde, UI logici, UI’de inline olarak uygulanabilir. Now in Android örneğindeki aşağıdaki örnekte gösterilebilir: Now in Android örneği, cihazın ekran boyutuna bağlı olarak navigtion için bir bottom appbar veya bir navigation raili gösterir. Daha küçük ekranlar alttaki appbari ve daha büyük ekranlar navigation rail kullanır. NiaApp composable fonksiyonunda kullanılan uygun navigation UI elementine karar verme logici, business logice bağlı olmadığından, NiaAppState adlı düz bir sınıf state holder tarafından yönetilebilir: . @Stable class NiaAppState( val navController: NavHostController, val windowSizeClass: WindowSizeClass ) { // UI logic val shouldShowBottomBar: Boolean get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact || windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact // UI logic val shouldShowNavRail: Boolean get() = !shouldShowBottomBar // UI State val currentDestination: NavDestination? @Composable get() = navController .currentBackStackEntryAsState().value?.destination // UI logic fun navigate(destination: NiaNavigationDestination, route: String? = null) { /* ... */ } /* ... */ } . Yukarıdaki örnekte, NiaAppState ile ilgili aşağıdaki ayrıntılar dikkat çekicidir: . | Activity yeniden olustugunda hayatta kalamaz: NiaAppState, Compose adlandırma kurallarına uygun bir Composable fonksiyonu ile rememberNiaAppState oluşturularak Compositionda hatırlanır. Activity yeniden oluşturulduktan sonra, önceki instancelar kaybolur ve yeniden oluşturulan Activity’nin yeni yapılandırmasına uygun olarak tüm bağımlılıkları iletilmiş yeni bir instance oluşturulur. Bu bağımlılıklar yeni olabilir veya önceki yapılandırmadan geri yüklenebilir. Örneğin, rememberNavController(), niaAppState constructorunda kullanılır ve Activity yeniden olusturulmasi boyunca state’i korumak için rememberSaveable’a yetki verir. | UI kapsamlı veri kaynaklarına referansları vardır: NavigationController, Resources ve diğer benzer yaşam döngüsü kapsamındaki tiplere yapılan refereanslar, aynı yaşam döngüsü kapsamını paylaştıklarından NiaAppState’te güvenle tutulabilir. | . Not: Düz state holder sınıfları, arama çubukları veya chip grupları gibi yeniden kullanılabilir kullanıcı arabirimi parçaları için önerilir. Bu durumda ViewModels’i kullanmamalısınız çünkü bunlar en iyi navigation destination için state’i yönetmek ve business logice erişim için kullanılır. Choose between a ViewModel and plain class for a state holder . Yukarıdaki bölümlerden, bir ViewModel ve bir düz sınıf state holder arasında seçim yapmak, UI state’ine uygulanan logice ve logicin üzerinde çalıştığı veri kaynaklarına iner. Not: Çoğu uygulama, aksi takdirde düz sınıf state holderine yerleştirilebilecek olan UI logicini UI’in kendisinde inline olarak gerçekleştirmeyi seçer. Bu, basit durumlar için iyidir, ancak diğer durumlar için, logici düz bir sınıf state holderine çekerek okunabilirliği artırabilirsiniz . Özetle, aşağıdaki diyagram, UI State’i production pipelinedaki state holderlerinin pozisyonunu gösterir: Sonuç olarak, tüketildiği yere en yakın state holderlerini kullanarak UI state’i üretmelisiniz. Daha az resmi olarak, uygun ownershipligi surdururken state’i mümkün olduğunca düşük tutmalısınız. Business logice erişmeniz gerekiyorsa ve UI state’inin, Activity yeniden olusturulmasi genelinde bile bir ekrana gidilebildiği sürece devam etmesi gerekiyorsa, bir ViewModel, business logic state holder implement etmeniz için harika bir seçimdir. Daha kısa ömürlü UI state ve UI logic için, yaşam döngüsü yalnızca UI’ye bağlı olan düz bir sınıf yeterli olmalıdır. State holders are compoundable . Bağımlılıklar eşit veya daha kısa bir ömre sahip olduğu sürece state holderlar diğer state holderlara bağımlı olabilir. Bunun örnekleri şunlardır: . | bir UI logic state holder başka bir UI logic state holder’a bağlı olabilir. | bir screen level state holder, bir UI logic state holder’a bağlı olabilir. | . Aşağıdaki kod parçacığı, Compose’un DrawerState‘inin başka bir dahili state holder olan SwipeableState‘e nasıl bağlı olduğunu ve bir uygulamanın UI logic state holder’ının DrawerState’e nasıl bağlı olabileceğini göstermektedir: . @Stable class DrawerState(/* ... */) { internal val swipeableState = SwipeableState(/* ... */) // ... } @Stable class MyAppState( private val drawerState: DrawerState, private val navController: NavHostController ) { /* ... */ } @Composable fun rememberMyAppState( drawerState: DrawerState = rememberDrawerState(DrawerValue.Closed), navController: NavHostController = rememberNavController() ): MyAppState = remember(drawerState, navController) { MyAppState(drawerState, navController) } . Dikkat: Screen level state holderların bir ekranın veya ekranın bir kısmının business logic karmaşıklığını yönettiği göz önüne alındığında, bir screen level state holderın başka bir screen level state holdera bağlı olması mantıklı olmayacaktır. Bu senaryodaysanız, ekranlarınızı ve state holder'larınızı yeniden gözden geçirin ve ihtiyacınız olanın bu olduğundan emin olun. Bir state holder’dan daha uzun ömürlü bir bağımlılık örneği, bir screen level state holder’a bağlı olan bir UI logic state holder olabilir. Bu, daha kısa ömürlü state holder’ın yeniden kullanılabilirliğini azaltır ve gerçekte ihtiyaç duyduğundan daha fazla logic ve state’e erişmesini sağlar. Daha kısa ömürlü state holder’ın daha yüksek scope’lu bir state holder’dan belirli bilgilere ihtiyacı varsa, state holder instance’ını geçmek yerine yalnızca ihtiyaç duyduğu bilgileri parametre olarak geçirin. Örneğin, aşağıdaki kod parçasında, UI logic state holder sınıfı, ViewModel instance’ının tamamını bir bağımlılık olarak geçirmek yerine ViewModel’den parametre olarak sadece ihtiyaç duyduğu bilgileri alır. class MyScreenViewModel(/* ... */) { val uiState: StateFlow&lt;MyScreenUiState&gt; = /* ... */ fun doSomething() { /* ... */ } fun doAnotherThing() { /* ... */ } // ... } @Stable class MyScreenState( // DO NOT pass a ViewModel instance to a plain state holder class // private val viewModel: MyScreenViewModel, // Instead, pass only what it needs as a dependency private val someState: StateFlow&lt;SomeState&gt;, private val doSomething: () -&gt; Unit, // Other UI-scoped types private val scaffoldState: ScaffoldState ) { /* ... */ } @Composable fun rememberMyScreenState( someState: StateFlow&lt;SomeState&gt;, doSomething: () -&gt; Unit, scaffoldState: ScaffoldState = rememberScaffoldState() ): MyScreenState = remember(someState, doSomething, scaffoldState) { MyScreenState(someState, doSomething, scaffoldState) } @Composable fun MyScreen( modifier: Modifier = Modifier, viewModel: MyScreenViewModel = viewModel(), state: MyScreenState = rememberMyScreenState( someState = viewModel.uiState.map { it.toSomeState() }, doSomething = viewModel::doSomething ), // ... ) { /* ... */ } . Aşağıdaki diyagram, UI ile önceki kod parçacığının farklı state holder’ları arasındaki bağımlılıkları temsil etmektedir: . Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-holders-and-ui-state/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-holders-and-ui-state/"
  },"288": {
    "doc": "State production",
    "title": "State production",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production/"
  },"289": {
    "doc": "State production",
    "title": "UI State Production",
    "content": "Modern UI ler nadiren statiktir. Kullanıcı, UI ile etkileşime girdiğinde veya uygulamanın yeni verileri göstermesi gerektiğinde UI’in state’i değişir. Bu belge, UI state’inin üretimi(production) ve yönetimi için yönergeler belirler. Sonunda şunları yapmalısınız: . | UI state’i oluşturmak(produce) için hangi API’leri kullanmanız gerektiğini bilin. Bu, tek yönlü veri akışı(UDF) ilkelerini izleyerek state holderlerinizde bulunan state değişikliği kaynaklarının doğasına bağlıdır. | Sistem kaynaklarının bilincinde olmak için UI state’inin üretimini nasıl kapsamanız(scope) gerektiğini öğrenin. | UI tarafından tüketim için UI stateini nasıl ortaya çıkarmanız gerektiğini bilin. | . Temel olarak state üretimi(state production), bu değişikliklerin UI state’ine artımlı olarak uygulanmasıdır. State her zaman vardır ve eventler sonucunda değişir. Eventler ve state arasındaki farklar aşağıdaki tabloda özetlenmiştir: . | Event | State | . | Transient, unpredictable, and exist for a finite period.(Geçici, öngörülemeyen ve sonlu bir süre için var olan.) | Always exists.(herzaman vardir) | . | The inputs of state production.(State üretiminin girdileridir.) | The output of state production.(State uretiminin ciktisidir.) | . | The product of the UI or other sources.(UI’in veya diğer kaynaklarin urunudur.) | Is consumed by the UI.(UI tarafindan tuketilir) | . Yukarıdakileri özetleyen harika bir anımsatıcı şudur: state is; events happen. Aşağıdaki şema, eventler bir zaman çizelgesinde meydana geldikçe statedeki değişiklikleri görselleştirmeye yardımcı olur. Her event uygun state holder tarafından işlenir ve bir state değişikliğiyle sonuçlanır: . Eventler şunlardan gelebilir: . | Kullanıcılar: Uygulamanın UI ile etkileşime girdikçe. | Diğer state değişikliği kaynakları: UI’den, domainden veya snackbar zaman aşımı eventleri gibi data katmanlarından uygulama verileri sunan API’ler, sırasıyla use case siniflari veya repositoryler. | . The UI state production pipeline . Android uygulamalarındaki state production, aşağıdakilerden oluşan bir processing pipeline olarak düşünülebilir: . | Inputs;State’in kaynakları değişir. Olabilirler: . | UI katmanında local: Bunlar, bir görev yönetimi uygulamasında “yapılacak iş” için bir başlık giren bir kullanıcı gibi kullanıcı eventleri veya UI state’indeki değişiklikleri yönlendiren UI logicine erişim sağlayan API’ler olabilir. Örneğin, Jetpack Compose’da DrawerState‘te open methodunu çağırmak. | UI katmanının dışında: Bunlar, UI state’inde değişikliklere neden olan domain veya data katmanlarından gelen kaynaklardır. Örneğin, bir NewsRepository’den yüklenmesi biten haberler veya diğer eventler. | Yukarıdakilerin hepsinin bir karışımı. | . | State holders;Business logici ve/veya UI logicini state değişikliği kaynaklarına uygulayan ve UI state oluşturmak(produce) için kullanıcı eventlerini işleyen türler. | Output;Uygulamanın, kullanıcılara ihtiyaç duydukları bilgileri sağlamak için işleyebileceği UI State. | . State production APIs . Pipeline’in hangi aşamasında olduğunuza bağlı olarak state productionda kullanılan iki ana API vardır: . | Pipeline stage | API | . | Input | You should use asynchronous APIs to perform work off the UI thread to keep the UI jank free. For example, Coroutines or Flows in Kotlin, and RxJava or callbacks in the Java Programming Language. | . | Output | You should use observable data holder APIs to invalidate and rerender the UI when state changes. For example, StateFlow, Compose State, or LiveData. Observable data holders guarantee the UI always has a UI state to display on the screen. | . Bu ikisi arasından, input için asenkron API seçiminin, output için gözlemlenebilir API seçiminden çok, state production pipelinein doğası üzerinde daha büyük bir etkisi vardır. Bunun nedeni, inputlarin pipeline’a uygulanabilecek processing türünü dikte etmesidir. State production pipeline assembly . Sonraki bölümler, çeşitli inputlar için en uygun state productin tekniklerini ve eşleşen output API’lerini kapsar. Her state production pipelie, inputlarin ve outputlarin bir kombinasyonudur ve şöyle olmalıdır: . | Yaşam döngüsünün farkında(Lifecycle aware): UI’in visible veya active olmadığı durumlarda, açıkça gerekli olmadıkça state production pipeline herhangi bir kaynak tüketmemelidir. | Kullanımı kolay(Easy to consume): UI, üretilen UI state’ini kolayca oluşturabilmelidir(produce etmelidir). State production pipelinenin outputuna yönelik hususlar, View sistemi veya Jetpack Compose gibi farklı View API’lerinde değişiklik gösterecektir. | . Not: İzleyen bölümlerde, tartışılan tüm API’ler deyimsel Kotlin ve Jetpack Compose kodunu kullanır. Ancak kılavuz, Java Programlama Dili veya Kotlin’deki diğer API’lerdeki eşdeğer analogları için geçerlidir. Input in state production pipelines . Bir state production pipelinedeki inputlar, state değişikliği kaynaklarını şu yollarla sağlayabilir: . | One-shot operations that may be synchronous or asynchronous, for example calls to suspend functions. | Stream APIs, for example Flows. | All of the above. | . Aşağıdaki bölümlerde, yukarıdaki inputlarin her biri için bir state production pipline’i nasıl kurabileceğiniz ele alınmaktadır. One-shot APIs as sources of state change . MutableStateFlow API’yi gözlemlenebilir, değiştirilebilir bir state containeri olarak kullanın. Jetpack Compose uygulamalarında, özellikle Compose text API‘leri ile çalışırken mutableStateOf‘u da düşünebilirsiniz. Her iki API de barındırdıkları değerlerde güvenli atomik güncellemelere izin veren methodlar sunar, güncellemeler senkron veya asenkro olsun ya da olmasın. Örneğin, basit bir zar atma uygulamasında state güncellemelerini düşünün. Kullanıcının attığı her zar, senkronize Random.nextInt() methodunu çağırır ve sonuç, UI state’ine yazılır. // StateFlow data class DiceUiState( val firstDieValue: Int? = null, val secondDieValue: Int? = null, val numberOfRolls: Int = 0, ) class DiceRollViewModel : ViewModel() { private val _uiState = MutableStateFlow(DiceUiState()) val uiState: StateFlow&lt;DiceUiState&gt; = _uiState.asStateFlow() // Called from the UI fun rollDice() { _uiState.update { currentState -&gt; currentState.copy( firstDieValue = Random.nextInt(from = 1, until = 7), secondDieValue = Random.nextInt(from = 1, until = 7), numberOfRolls = currentState.numberOfRolls + 1, ) } } } //compose @Stable interface DiceUiState { val firstDieValue: Int? val secondDieValue: Int? val numberOfRolls: Int? } private class MutableDiceUiState: DiceUiState { override var firstDieValue: Int? by mutableStateOf(null) override var secondDieValue: Int? by mutableStateOf(null) override var numberOfRolls: Int by mutableStateOf(0) } class DiceRollViewModel : ViewModel() { private val _uiState = MutableDiceUiState() val uiState: DiceUiState = _uiState // Called from the UI fun rollDice() { _uiState.firstDieValue = Random.nextInt(from = 1, until = 7) _uiState.secondDieValue = Random.nextInt(from = 1, until = 7) _uiState.numberOfRolls = _uiState.numberOfRolls + 1 } } . Mutating the UI state from asynchronous calls . Asenkron bir sonuç gerektiren state değişiklikleri için uygun CoroutineScope’ta bir Coroutine başlatın. Bu, CoroutineScope iptal edildiğinde uygulamanın işi silmesine izin verir. State holder daha sonra suspend method çağrısının sonucunu UI state’ini ortaya çıkarmak için kullanılan gözlemlenebilir API’ye yazar. Örneğin, [Architecture örneği](https://github.com/android/architecture-samplesndeki AddEditTaskViewModel’i göz önünde bulundurun. Askıya alınan(suspend edilen) saveTask() methodu bir taski asenkron olarak kaydettiğinde, MutableStateFlow’daki update methodu state değişikliğini UI state’ine yayar. // StateFlow data class AddEditTaskUiState( val title: String = \"\", val description: String = \"\", val isTaskCompleted: Boolean = false, val isLoading: Boolean = false, val userMessage: String? = null, val isTaskSaved: Boolean = false ) class AddEditTaskViewModel(...) : ViewModel() { private val _uiState = MutableStateFlow(AddEditTaskUiState()) val uiState: StateFlow&lt;AddEditTaskUiState&gt; = _uiState.asStateFlow() private fun createNewTask() { viewModelScope.launch { val newTask = Task(uiState.value.title, uiState.value.description) try { tasksRepository.saveTask(newTask) // Write data into the UI state. _uiState.update { it.copy(isTaskSaved = true) } } catch(cancellationException: CancellationException) { throw cancellationException } catch(exception: Exception) { _uiState.update { it.copy(userMessage = getErrorMessage(exception)) } } } } } //Compose State @Stable interface AddEditTaskUiState { val title: String val description: String val isTaskCompleted: Boolean val isLoading: Boolean val userMessage: String? val isTaskSaved: Boolean } private class MutableAddEditTaskUiState : AddEditTaskUiState() { override var title: String by mutableStateOf(\"\") override var description: String by mutableStateOf(\"\") override var isTaskCompleted: Boolean by mutableStateOf(false) override var isLoading: Boolean by mutableStateOf(false) override var userMessage: String? by mutableStateOf&lt;String?&gt;(null) override var isTaskSaved: Boolean by mutableStateOf(false) } class AddEditTaskViewModel(...) : ViewModel() { private val _uiState = MutableAddEditTaskUiState() val uiState: AddEditTaskUiState = _uiState private fun createNewTask() { viewModelScope.launch { val newTask = Task(uiState.value.title, uiState.value.description) try { tasksRepository.saveTask(newTask) // Write data into the UI state. _uiState.isTaskSaved = true } catch(cancellationException: CancellationException) { throw cancellationException } catch(exception: Exception) { _uiState.userMessage = getErrorMessage(exception)) } } } } . Not: Bir [AAC ViewModel](/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/about-viewmodel.md)'in viewModelScope'unda başlatılan coroutineler, istisnai olarak veya başka türlü tamamlanmaya çalışır. Bu, Coroutines açıkça iptal edilmedikçe veya ViewModel temizlenmedikçe, UI görünür olsun ya da olmasın gerçekleşir. Kısa ömürlü olma eğiliminde olduklarından, çoğu istek için bu genellikle uygundur. 5 saniye veya daha uzun süren istekleri çalıştırmak için viewModelScope kullanmamalısınız. Bunun yerine bunları WorkManager ile ertelenmiş veya uzun süreli işler olarak kuyruğa almalısınız. Mutating the UI state from background threads . UI state’inin productionu için main dispacther Coroutines’in başlatılması tercih edilir. Yani, aşağıdaki kod parçacıklarındaki withContext bloğunun dışında. Ancak, UI state’ini farklı bir backgroud context’inde güncellemeniz gerekirse, bunu aşağıdaki API’leri kullanarak yapabilirsiniz: . | Use the withContext method to run Coroutines in a different concurrent context. | When using MutableStateFlow, use the update method as usual. | When using Compose State, use the Snapshot.withMutableSnapshot to guarantee atomic updates to State in the concurrent context. | . Örneğin, aşağıdaki DiceRollViewModel parçacığında, SlowRandom.nextInt()’in CPU’ya bağlı bir Coroutine’den çağrılması gereken hesaplama açısından yoğun bir askıya alma işlevi olduğunu varsayalım. // StateFlow class DiceRollViewModel( private val defaultDispatcher: CoroutineScope = Dispatchers.Default ) : ViewModel() { private val _uiState = MutableStateFlow(DiceUiState()) val uiState: StateFlow&lt;DiceUiState&gt; = _uiState.asStateFlow() // Called from the UI fun rollDice() { viewModelScope.launch() { // Other Coroutines that may be called from the current context … withContext(defaultDispatcher) { _uiState.update { currentState -&gt; currentState.copy( firstDieValue = SlowRandom.nextInt(from = 1, until = 7), secondDieValue = SlowRandom.nextInt(from = 1, until = 7), numberOfRolls = currentState.numberOfRolls + 1, ) } } } } } // Compose State class DiceRollViewModel( private val defaultDispatcher: CoroutineScope = Dispatchers.Default ) : ViewModel() { private val _uiState = MutableDiceUiState() val uiState: DiceUiState = _uiState // Called from the UI fun rollDice() { viewModelScope.launch() { // Other Coroutines that may be called from the current context … withContext(defaultDispatcher) { Snapshot.withMutableSnapshot { _uiState.firstDieValue = SlowRandom.nextInt(from = 1, until = 7) _uiState.secondDieValue = SlowRandom.nextInt(from = 1, until = 7) _uiState.numberOfRolls = _uiState.numberOfRolls + 1 } } } } } . Not: Başlatılan tüm coroutinelerin farklı bir contexden çağrılması gerekiyorsa, doğrudan viewModelScope.launch(defaultDispatcher){ } öğesini arayabilirsiniz. Uyarı: Snapshot.withMutableSnapshot{ } kullanılmadan UI olmayan bir threadden Compose state’inin güncellenmesi, üretilen state’de tutarsızlıklara neden olabilir. Stream APIs as sources of state change . Streamlerde zaman içinde birden çok değer üreten state değişikliği kaynakları için, tüm kaynakların outputlarini uyumlu bir bütün halinde birleştirmek, state üretimine(production) doğrudan bir yaklaşımdır.Kotlin Flows kullanırken bunu combine fonksiyonu ile başarabilirsiniz. Bunun bir örneği, InterestsViewModel’deki “Now in Android” örneğinde görülebilir: . class InterestsViewModel( authorsRepository: AuthorsRepository, topicsRepository: TopicsRepository ) : ViewModel() { val uiState = combine( authorsRepository.getAuthorsStream(), topicsRepository.getTopicsStream(), ) { availableAuthors, availableTopics -&gt; InterestsUiState.Interests( authors = availableAuthors, topics = availableTopics ) } .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = InterestsUiState.Loading ) } . Not: Combined Flow’u, UI state için gözlemlenebilir API olarak bir [StateFlow](https://developer.android.com/kotlin/flow/stateflow-and-sharedflow)'a dönüştürmek için [stateIn](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html) operatörünü kullanabilirsiniz. StateFlows oluşturmak için stateIn operatörünün kullanılması, yalnızca UI görünürken aktif olması gerekebileceğinden, UI’ye state production pipeline’in activitysi üzerinde daha ayrıntılı kontrol sağlar. | Flow’un yaşam döngüsüne duyarlı bir şekilde collect edilmesi sırasında pipeline’in yalnızca UI görünür olduğunda etkin olması gerekiyorsa SharingStarted.WhileSubscription() öğesini kullanın. | Kullanıcı UI’e dönebildiği sürece, yani UI backstackde veya ekran dışında başka bir sekmede olduğu sürece pipeline’in aktif olması gerekiyorsa SharingStarted.Lazily kullanın. | . Stream tabanlı state kaynaklarının collectinin geçerli olmadığı durumlarda, Kotlin Flows gibi stream API’leri, streamlerin UI state’ine işlenmesine yardımcı olmak için [merging](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/merge.html?query=fun%20%3CT%3E%20merge(vararg%20flows:%20Flow%3CT%3E), [flattening](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html?query=inline%20fun%20%3CT,%20R%3E%20Flow%3CT%3E.flatMapLatest(crossinline%20transform:%20suspend%20(T) vb. gibi zengin bir transformation seti sunar. Anahtar Nokta: Çoğu durumda combine, stream API’lerinden state productiona yönelik tavsiye edilen bir yaklaşımdır. One-shot and stream APIs as sources of state change . State production pipeline’in, state değişikliği kaynakları olarak hem tek seferlik(one-shot) çağrılara hem de streamlere bağlı olduğu durumda, tanımlayıcı kısıtlama akışlardır(streams are defining constraint). Bu nedenle, tek seferlik çağrıları stream API’lerine dönüştürün veya outputlarini streamlere aktarın ve yukarıdaki stream bölümünde açıklandığı gibi işlemeye devam edin. Flowlarla, bu genellikle state değişikliklerini yaymak için bir veya daha fazla private backing MutableStateFlow instancei oluşturmak anlamına gelir. Compose state’inden snapshot flowlari da oluşturabilirsiniz. Aşağıdaki mimari örnekler repositorysinden TaskDetailViewModel’i göz önünde bulundurun: . //StateFlow class TaskDetailViewModel @Inject constructor( private val tasksRepository: TasksRepository, savedStateHandle: SavedStateHandle ) : ViewModel() { private val _isTaskDeleted = MutableStateFlow(false) private val _task = tasksRepository.getTaskStream(taskId) val uiState: StateFlow&lt;TaskDetailUiState&gt; = combine( _isTaskDeleted, _task ) { isTaskDeleted, task -&gt; TaskDetailUiState( task = taskAsync.data, isTaskDeleted = isTaskDeleted ) } // Convert the result to the appropriate observable API for the UI .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = TaskDetailUiState() ) fun deleteTask() = viewModelScope.launch { tasksRepository.deleteTask(taskId) _isTaskDeleted.update { true } } } //Compose State class TaskDetailViewModel @Inject constructor( private val tasksRepository: TasksRepository, savedStateHandle: SavedStateHandle ) : ViewModel() { private var _isTaskDeleted by mutableStateOf(false) private val _task = tasksRepository.getTaskStream(taskId) val uiState: StateFlow&lt;TaskDetailUiState&gt; = combine( snapshotFlow { _isTaskDeleted }, _task ) { isTaskDeleted, task -&gt; TaskDetailUiState( task = taskAsync.data, isTaskDeleted = isTaskDeleted ) } // Convert the result to the appropriate observable API for the UI .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = TaskDetailUiState() ) fun deleteTask() = viewModelScope.launch { tasksRepository.deleteTask(taskId) _isTaskDeleted = true } } . Not: Compose State, snapshotFlow { } API kullanılarak bir flowa dönüştürülür. Başka bir örnek için “Now In Android” örneğindeki ForYouViewModel‘e bakın. Output types in state production pipelines . UI State için output API’sinin seçimi ve sunumunun doğası, büyük ölçüde uygulamanızın UI’ini oluşturmak için kullandığı API’ye bağlıdır. Android uygulamalarında Views veya Jetpack Compose kullanmayı seçebilirsiniz. Buradaki hususlar şunları içerir: . | State’i yaşam döngüsüne duyarlı bir şekilde okuma. | State’in, state holderinden bir veya daha fazla field’inden gösterilmesi gerekip gerekmediği. | . Aşağıdaki tablo, herhangi bir input ve consumer için state production pipeline için hangi API’lerin kullanılacağını özetlemektedir: . | Input | Consumer | Output | . | One-shot APIs | Views | StateFlow or LiveData | . | One-shot APIs | Compose | StateFlow or Compose State | . | Stream APIs | Views | StateFlow or LiveData | . | Stream APIs | Compose | StateFlow | . | One-shot and stream APIs | Views | StateFlow or LiveData | . | One-shot and stream APIs | Compose | StateFlow | . State production pipeline initialization . State production pipeline’larının başlatılması, pipeline’ın çalışması için ilk koşulların ayarlanmasını içerir. Bu, örneğin bir haber makalesinin detail view’i için bir ID gibi pipeline’ın başlatılması için kritik olan ilk girdi değerlerinin sağlanmasını veya asenkron bir yüklemenin başlatılmasını içerebilir. Sistem kaynaklarını korumak için state production pipeline’ı mümkün olduğunca lazily başlatmalısınız. Pratikte bu genellikle çıktının bir tüketicisi olana kadar beklemek anlamına gelir. Flow API’leri, stateIn metodundaki started argümanı ile buna izin verir. Bunun uygulanamaz olduğu durumlarda, aşağıdaki kod parçasında gösterildiği gibi state production pipeline’ı explicit olarak başlatmak için idempotent bir initialize() fonksiyonu tanımlayın: . class MyViewModel : ViewModel() { private var initializeCalled = false // This function is idempotent provided it is only called from the UI thread. @MainThread fun initialize() { if(initializeCalled) return initializeCalled = true viewModelScope.launch { // seed the state production pipeline } } } . Uyarı: Bir ViewModel'in init bloğunda veya constructor'ında asenkron işlemler başlatmaktan kaçının. Asenkron işlemler bir nesne oluşturmanın yan etkisi olmamalıdır çünkü asenkron kod, nesne tam olarak başlatılmadan önce nesneden okuyabilir veya nesneye yazabilir. Bu aynı zamanda leaking the object (nesnenin sızdırılması) olarak da adlandırılır ve ince ve teşhis edilmesi zor hatalara yol açabilir. Bu özellikle Compose State ile çalışırken önemlidir. ViewModel Compose State fieldlarini tuttuğunda, ViewModel'in init bloğunda Compose State fieldlarını güncelleyen bir Coroutine başlatmayın, aksi takdirde bir IllegalStateException oluşabilir. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production/#ui-state-production",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production/#ui-state-production"
  },"290": {
    "doc": "String",
    "title": "String",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/string/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/string/"
  },"291": {
    "doc": "Style",
    "title": "Style",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/style/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/style/"
  },"292": {
    "doc": "Support multiple back stacks",
    "title": "Support multiple back stacks",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/support-multiple-back-stacks/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/support-multiple-back-stacks/"
  },"293": {
    "doc": "Tasks and the back stack",
    "title": "Tasks and the back stack",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/tasks-and-the-back-stack/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/tasks-and-the-back-stack/"
  },"294": {
    "doc": "Test navigation",
    "title": "Test navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/test-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/test-navigation/"
  },"295": {
    "doc": "Test your app with pseudolocales",
    "title": "Test your app with pseudolocales",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/test-your-app-with-pseudolocales/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/test-your-app-with-pseudolocales/"
  },"296": {
    "doc": "Test your app's activities",
    "title": "Test your app's activities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/test-your-apps-activities/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/test-your-apps-activities/"
  },"297": {
    "doc": "Test your fragments",
    "title": "Test your fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/test-your-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/test-your-fragments/"
  },"298": {
    "doc": "Test your paging implementation",
    "title": "Test your paging implementation",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/test-your-paging-implementation/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/test-your-paging-implementation/"
  },"299": {
    "doc": "The activity lifecycle",
    "title": "The activity lifecycle",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/the-activity-lifecycle/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/the-activity-lifecycle/"
  },"300": {
    "doc": "Thinking in Compose",
    "title": "Thinking in Compose",
    "content": "Intuitive: Thinking in Compose - MAD Skills . Jetpack Compose, Android için modern bir deklaratif UI Toolkit’tir. Compose, frontend view’ları zorunlu olarak değiştirmeden uygulama kullanıcı arayüzünüzü oluşturmanıza olanak tanıyan deklaratif bir API sağlayarak uygulama kullanıcı arayüzünüzü yazmayı ve korumayı kolaylaştırır. Bu terminoloji biraz açıklama gerektiriyor, ancak sonuçları uygulama tasarımınız için önemlidir. ",
    "url": "/docs/jetpack-compose/introduction/thinking-in-compose/",
    
    "relUrl": "/docs/jetpack-compose/introduction/thinking-in-compose/"
  },"301": {
    "doc": "Thinking in Compose",
    "title": "The declarative programming paradigm",
    "content": "Tarihsel olarak, bir Android view hiyerarşisi UI widget’larından oluşan bir ağaç olarak temsil edilebilir. Kullanıcı etkileşimleri gibi nedenlerle uygulamanın state’i değiştikçe, UI hiyerarşisinin mevcut verileri gösterecek şekilde güncellenmesi gerekir. UI’yi güncellemenin en yaygın yolu, findViewById() gibi fonksiyonları kullanarak ağaçta dolaşmak ve button.setText(String), container.addChild(View) veya img.setImageBitmap(Bitmap) gibi yöntemleri çağırarak nodları değiştirmektir. Bu yöntemler widget’ın dahili state’ini değiştirir. View’ları manuel olarak değiştirmek hata olasılığını artırır. Bir veri parçası birden fazla yerde işleniyorsa, onu gösteren view’lardan birini güncellemeyi unutmak kolaydır. Ayrıca, iki güncelleme beklenmedik bir şekilde çakıştığında illegal stateler oluşturmak da kolaydır. Örneğin, bir güncelleme, kullanıcı arayüzünden yeni kaldırılmış bir node’un değerini ayarlamaya çalışabilir. Genel olarak, yazılım bakım karmaşıklığı güncelleme gerektiren view sayısı ile birlikte artar. Son birkaç yıldır tüm endüstri, kullanıcı arayüzlerinin oluşturulması ve güncellenmesiyle ilgili mühendisliği büyük ölçüde basitleştiren deklaratif bir kullanıcı arayüzü modeline geçmeye başlamıştır. Bu teknik, kavramsal olarak tüm ekranı sıfırdan yeniden oluşturarak ve ardından yalnızca gerekli değişiklikleri uygulayarak çalışır. Bu yaklaşım, stateful bir view hiyerarşisini manuel olarak güncellemenin karmaşıklığını önler. Compose, deklaratif bir kullanıcı arayüzü framework’üdür. Tüm ekranı yeniden oluşturmanın zorluklarından biri, zaman, bilgi işlem gücü ve pil kullanımı açısından potansiyel olarak pahalı olmasıdır. Bu maliyeti azaltmak için Compose, herhangi bir zamanda kullanıcı arayüzünün hangi bölümlerinin yeniden çizilmesi gerektiğini akıllıca seçer. Bunun, Recomposition‘da tartışıldığı gibi, UI bileşenlerinizi nasıl tasarladığınızla ilgili bazı etkileri vardır. ",
    "url": "/docs/jetpack-compose/introduction/thinking-in-compose/#the-declarative-programming-paradigm",
    
    "relUrl": "/docs/jetpack-compose/introduction/thinking-in-compose/#the-declarative-programming-paradigm"
  },"302": {
    "doc": "Thinking in Compose",
    "title": "A simple composable function",
    "content": "Compose kullanarak, veri alan ve kullanıcı arayüzü öğeleri emit eden bir dizi composable fonksiyon tanımlayarak kullanıcı arayüzünüzü oluşturabilirsiniz. Basit bir örnek olarak, bir String alan ve bir selamlama mesajı görüntüleyen bir Text widget’ı emit eden bir Greeting widget’ı verilebilir. Bu fonksiyon ile ilgili birkaç kayda değer şey: . | Fonksiyona @Composable notasyonu eklenmiştir. Tüm Composable fonksiyonları bu annotation’a sahip olmalıdır; bu annotation Compose derleyicisine bu fonksiyonun verileri UI’ye dönüştürmek için tasarlandığını bildirir. | Fonksiyon veri alır. Composable fonksiyonlar, uygulama lojiğinin kullanıcı arayüzünü tanımlamasına olanak tanıyan parametreleri kabul edebilir. Bu durumda, widget’ımız kullanıcıyı adıyla selamlayabilmek için bir String kabul eder. | Fonksiyon, kullanıcı arayüzünde metin görüntüler. Bunu, aslında metin UI öğesini oluşturan Text() composable fonksiyonunu çağırarak yapar. Composable fonksiyonlar, diğer composable fonksiyonları çağırarak UI hiyerarşisini emit eder. | Fonksiyon hiçbir şey döndürmez. UI emit eden Compose fonksiyonlarının herhangi bir şey döndürmesi gerekmez, çünkü UI widget’ları oluşturmak yerine istenen ekran state’ini tanımlarlar. | Bu fonksiyon hızlı, idempotent ve side-effectsizdir. | Fonksiyon aynı argümanla birden fazla kez çağrıldığında aynı şekilde davranır ve global değişkenler veya random() çağrıları gibi diğer değerleri kullanmaz. | Fonksiyon, özellikleri veya global değişkenleri değiştirmek gibi herhangi bir side-effect olmaksızın kullanıcı arayüzünü tanımlar. | . | . Genel olarak, Recomposition bölümünde tartışılan nedenlerden dolayı tüm composable fonksiyonlar bu özelliklerle yazılmalıdır. ",
    "url": "/docs/jetpack-compose/introduction/thinking-in-compose/#a-simple-composable-function",
    
    "relUrl": "/docs/jetpack-compose/introduction/thinking-in-compose/#a-simple-composable-function"
  },"303": {
    "doc": "Thinking in Compose",
    "title": "The declarative paradigm shift",
    "content": "Birçok emperatif nesne yönelimli kullanıcı arabirimi araç setinde, kullanıcı arabirimini bir widget ağacını instantiate ederek başlatırsınız. Bunu genellikle bir XML layout dosyasını inflate ederek yaparsınız. Her widget kendi iç state’ini korur ve uygulama mantığının widget ile etkileşime girmesini sağlayan getter ve setter yöntemlerini ortaya çıkarır. Compose’un deklaratif yaklaşımında, widget’lar nispeten statelessdir ve setter veya getter fonksiyonlarını açığa çıkarmazlar. Aslında, widget’lar nesne olarak gösterilmez. Kullanıcı arayüzünü farklı argümanlarla aynı composable fonksiyonunu çağırarak güncellersiniz. Bu, App Architecture Guide’da açıklandığı gibi ViewModel gibi mimari modellere durum sağlamayı kolaylaştırır. Ardından, composable’larınız, gözlemlenebilir veriler her güncellendiğinde mevcut uygulama state’ini bir UI’ye dönüştürmekten sorumludur. Şekil 2. Uygulama lojiği, top-level composable fonksiyona veri sağlar. Bu fonksiyon, diğer composable’ları çağırarak kullanıcı arayüzünü tanımlamak için verileri kullanır ve uygun verileri bu composable’lara ve hiyerarşide aşağıya doğru iletir. Kullanıcı kullanıcı arayüzü ile etkileşime girdiğinde, kullanıcı arayüzü onClick gibi event’leri tetikler. Bu event’ler uygulama mantığını bilgilendirmeli ve bu da uygulamanın state’ini değiştirebilmelidir. State değiştiğinde, composable fonksiyonlar yeni verilerle tekrar çağrılır. Bu, UI öğelerinin yeniden çizilmesine neden olur - bu işleme recomposition denir. Şekil 3. Kullanıcı bir UI öğesiyle etkileşime girerek bir event’in tetiklenmesine neden oldu. Uygulama mantığı olaya yanıt verir, ardından composable fonksiyonlar gerekirse yeni parametrelerle otomatik olarak tekrar çağrılır. ",
    "url": "/docs/jetpack-compose/introduction/thinking-in-compose/#the-declarative-paradigm-shift",
    
    "relUrl": "/docs/jetpack-compose/introduction/thinking-in-compose/#the-declarative-paradigm-shift"
  },"304": {
    "doc": "Thinking in Compose",
    "title": "Dynamic content",
    "content": "Composable fonksiyonlar XML yerine Kotlin ile yazıldıkları için diğer Kotlin kodları kadar dinamik olabilirler. Örneğin, bir kullanıcı listesini selamlayan bir kullanıcı arayüzü oluşturmak istediğinizi varsayalım: . @Composable fun Greeting(names: List&lt;String&gt;) { for (name in names) { Text(\"Hello $name\") } } . Bu fonksiyon bir isim listesi alır ve her kullanıcı için bir karşılama mesajı oluşturur. Composable fonksiyonlar oldukça sofistike olabilir. Belirli bir UI öğesini göstermek isteyip istemediğinize karar vermek için if deyimlerini kullanabilirsiniz. Döngüler kullanabilirsiniz. Yardımcı fonksiyonları çağırabilirsiniz. Temel dilin tüm esnekliğine sahip olursunuz. Bu güç ve esneklik Jetpack Compose’un en önemli avantajlarından biridir. ",
    "url": "/docs/jetpack-compose/introduction/thinking-in-compose/#dynamic-content",
    
    "relUrl": "/docs/jetpack-compose/introduction/thinking-in-compose/#dynamic-content"
  },"305": {
    "doc": "Thinking in Compose",
    "title": "Recomposition",
    "content": "Emperatif bir UI modelinde, bir widget’ı değiştirmek için, widget’ın dahili state’ini değiştirmek üzere bir setter çağırırsınız. Compose’da, composable fonksiyonu yeni verilerle tekrar çağırırsınız. Bunu yapmak, fonksiyonun yeniden oluşturulmasına neden olur - fonksiyon tarafından emit edilen widget’lar, gerekirse yeni verilerle yeniden çizilir. Compose framework akıllı bir şekilde yalnızca değişen bileşenleri yeniden oluşturabilir. Örneğin, bir buton görüntüleyen bu composable fonksiyonu düşünün: . @Composable fun ClickCounter(clicks: Int, onClick: () -&gt; Unit) { Button(onClick = onClick) { Text(\"I've been clicked $clicks times\") } } . Butona her tıklandığında, caller clicks değerini günceller. Compose, yeni değeri göstermek için lambda’yı Text işleviyle birlikte yeniden çağırır; bu işleme recomposition denir. Değere bağlı olmayan diğer fonksiyonlar recompose edilmez. Daha önce de belirttiğimiz gibi, tüm UI ağacını yeniden oluşturmak hesaplama açısından pahalı olabilir ve bu da hesaplama gücünü ve pil ömrünü tüketir. Compose, bu akıllı recomposition ile bu sorunu çözer. Recomposition, girdiler değiştiğinde composable fonksiyonlarınızı tekrar çağırma işlemidir. Bu, fonksiyonun girdileri değiştiğinde gerçekleşir. Compose yeni girdilere göre recomposition yaparken, yalnızca değişmiş olabilecek fonksiyonları veya lambdaları çağırır ve diğerlerini atlar. Değişen parametrelere sahip olmayan tüm fonksiyonları veya lambdaları atlayarak, Compose verimli bir şekilde yeniden oluşturabilir. Bir fonksiyonun recomposition’ı atlanabileceğinden, composable fonksiyonların çalıştırılmasından kaynaklanan side-effects’e asla güvenmeyin. Bunu yaparsanız, kullanıcılar uygulamanızda garip ve öngörülemeyen davranışlarla karşılaşabilir. Side-effect, uygulamanızın geri kalanı tarafından görülebilen herhangi bir değişikliktir. Örneğin, bu eylemlerin hepsi tehlikeli side-effectlerdir: . | Shared bir nesnenin property’sine yazma | ViewModel’de bir gözlemlenebiliri güncelleme | Sharedprefleri güncelleme | . Composable fonksiyonlar, bir animasyon işlenirken olduğu gibi her karede yeniden çalıştırılabilir. Animasyonlar sırasında sıkıntıyı önlemek için composable fonksiyonlar hızlı olmalıdır. Shared preferences’dan okuma gibi pahalı işlemler yapmanız gerekiyorsa, bunu bir background coroutine içinde yapın ve değer sonucunu parametre olarak composable fonksiyona aktarın. Örnek olarak, bu kod SharedPreferences’daki bir değeri güncellemek için bir composable oluşturur. Composable, shared preferences’ın kendisini okumamalı veya yazmamalıdır. Bunun yerine, bu kod okuma ve yazma işlemlerini bir background coroutine içinde bir ViewModel’e taşır. Uygulama mantığı, güncellemeyi tetiklemek için geçerli değeri bir callback ile iletir. @Composable fun SharedPrefsToggle( text: String, value: Boolean, onValueChanged: (Boolean) -&gt; Unit ) { Row { Text(text) Checkbox(checked = value, onCheckedChange = onValueChanged) } } . Bu belgede Compose kullanırken dikkat etmeniz gereken bazı hususlar ele alınmaktadır: . | Composable fonksiyonlar herhangi bir sırada çalıştırılabilir. | Composable fonksiyonlar paralel olarak çalışabilir. | Recomposition mümkün olduğunca çok sayıda composable fonksiyonu ve lambdayı atlar. | Recomposition optimistiktir ve iptal edilebilir. | Composable bir fonksiyon, bir animasyonun her karesi gibi oldukça sık çalıştırılabilir. | . İlerleyen bölümlerde, recomposition’ı desteklemek için composable fonksiyonların nasıl oluşturulacağı ele alınacaktır. Her durumda, best practice composable fonksiyonlarınızı hızlı, idempotent ve side-effect-free tutmaktır. Composable functions can execute in any order . Composable bir fonksiyonun koduna bakarsanız, kodun göründüğü sırada çalıştırıldığını varsayabilirsiniz. Ancak bu her zaman doğru değildir. Composable bir fonksiyon diğer Composable fonksiyonlara çağrılar içeriyorsa, bu fonksiyonlar herhangi bir sırada çalışabilir. Compose, bazı UI öğelerinin diğerlerinden daha yüksek önceliğe sahip olduğunu kabul etme ve önce onları çizme seçeneğine sahiptir. Örneğin, bir tab layout’ta üç ekran çizmek için aşağıdaki gibi bir kodunuz olduğunu varsayalım: . @Composable fun ButtonRow() { MyFancyNavigation { StartScreen() MiddleScreen() EndScreen() } } . StartScreen, MiddleScreen ve EndScreen çağrıları herhangi bir sırada gerçekleşebilir. Bu, örneğin StartScreen() fonksiyonunun global bir değişkeni ayarlamasını (bir side-effect) ve MiddleScreen() fonksiyonunun bu değişiklikten yararlanmasını sağlayamayacağınız anlamına gelir. Bunun yerine, bu fonksiyonların her birinin kendi içinde bağımsız olması gerekir. Composable functions can run in parallel . Compose, composable fonksiyonları paralel olarak çalıştırarak recomposition’ı optimize edebilir. Bu, Compose’un birden fazla çekirdekten yararlanmasını ve ekranda olmayan composable fonksiyonları daha düşük bir öncelikte çalıştırmasını sağlar. Bu optimizasyon, composable bir fonksiyonun bir background thread havuzu içinde çalışabileceği anlamına gelir. Composable bir fonksiyon ViewModel üzerinde bir fonksiyon çağırırsa, Compose bu fonksiyonu aynı anda birkaç thread’den çağırabilir. Uygulamanızın doğru şekilde çalıştığından emin olmak için, tüm composable fonksiyonların hiçbir side-effect’i olmamalıdır. Bunun yerine, side-effectleri her zaman UI thread üzerinde çalışan onClick gibi callback’lerden tetikleyin. Composable bir fonksiyon çağırıldığında, çağırma işlemi çağırandan farklı bir thread üzerinde gerçekleşebilir. Bu da, hem bu tür kodlar thread-safe olmadığından hem de composable lambda’nın izin verilmeyen bir side-effect’i olduğundan, composable lambda’daki değişkenleri değiştiren kodlardan kaçınılması gerektiği anlamına gelir. İşte bir listeyi ve sayısını gösteren bir composable örneği: . @Composable fun ListComposable(myList: List&lt;String&gt;) { Row(horizontalArrangement = Arrangement.SpaceBetween) { Column { for (item in myList) { Text(\"Item: $item\") } } Text(\"Count: ${myList.size}\") } } . Bu kod side-effect’sizdir ve input listesini UI’ye dönüştürür. Bu, küçük bir listeyi görüntülemek için harika bir koddur. Ancak, fonksiyon lokal bir değişkene yazıyorsa, bu kod thread-safe veya doğru olmayacaktır: . @Composable @Deprecated(\"Example with bug\") fun ListWithBug(myList: List&lt;String&gt;) { var items = 0 Row(horizontalArrangement = Arrangement.SpaceBetween) { Column { for (item in myList) { Text(\"Item: $item\") items++ // Avoid! Side-effect of the column recomposing. } } Text(\"Count: $items\") } } . Bu örnekte, öğeler her yeniden düzenlemede değiştirilir. Bu, bir animasyonun her karesi veya liste güncellendiğinde olabilir. Her iki durumda da kullanıcı arayüzü yanlış sayıyı gösterecektir. Bu nedenle, Compose’da bu gibi yazmalar desteklenmez; bu yazmaları yasaklayarak, framework’ün composable lambdaları çalıştırmak için thread’leri değiştirmesine izin veririz. Recomposition skips as much as possible . Kullanıcı arayüzünüzün bazı bölümleri geçersiz olduğunda, Compose yalnızca güncellenmesi gereken bölümleri yeniden oluşturmak için elinden geleni yapar. Bu, UI ağacında üstündeki veya altındaki composable’ların hiçbirini çalıştırmadan tek bir Button’ın composable’ını yeniden çalıştırmayı atlayabileceği anlamına gelir. Her composable fonksiyon ve lambda kendi başına yeniden oluşturulabilir. İşte bir liste oluştururken yeniden oluşturmanın(recomposition) bazı öğeleri nasıl atlayabileceğini gösteren bir örnek: . /** * Kullanıcının tıklayabileceği isimlerin listesini bir başlıkla görüntüleme */ @Composable fun NamePicker( header: String, names: List&lt;String&gt;, onNameClicked: (String) -&gt; Unit ) { Column { // bu, [header] değiştiğinde yeniden oluşturacak, ancak [names] değiştiğinde oluşturmayacaktır Text(header, style = MaterialTheme.typography.bodyLarge) Divider() // LazyColumn, RecyclerView'in Compose versiyonudur. // items() fonksiyonuna geçirilen lambda bir RecyclerView.ViewHolder'a benzer. LazyColumn { items(names) { name -&gt; // Bir öğenin [name]'i güncellendiğinde, o öğenin adaptörü // yeniden oluşturacaktır. Bu, [header] değiştiğinde yeniden oluşturulmayacaktır NamePickerItem(name, onNameClicked) } } } } /** * Kullanıcının tıklayabileceği tek bir ad görüntüleyin. */ @Composable private fun NamePickerItem(name: String, onClicked: (String) -&gt; Unit) { Text(name, Modifier.clickable(onClick = { onClicked(name) })) } . Bu scope’ların her biri, recomposition sırasında çalıştırılacak tek şey olabilir. Compose, başlık değiştiğinde ebeveynlerinden hiçbirini çalıştırmadan Column lambda’sına atlayabilir. Ve Column’u çalıştırırken Compose, isimler değişmediyse LazyColumn’un öğelerini atlamayı seçebilir. Yine, tüm composable fonksiyonların veya lambdaların çalıştırılması side-effect içermemelidir. Bir side-effect gerçekleştirmeniz gerektiğinde, bunu bir callback’ten tetikleyin. Recomposition is optimistic . Compose bir composable’ın parametrelerinin değişmiş olabileceğini düşündüğünde recomposition başlar. Recomposition iyimserdir, yani Compose parametreler tekrar değişmeden önce recomposition işleminin bitmesini bekler. Recomposition bitmeden önce bir parametre değişirse, Compose recomposition’ı iptal edebilir ve yeni parametre ile yeniden başlatabilir. Recomposition iptal edildiğinde, Compose UI ağacını recomposition’dan atar. Görüntülenen kullanıcı arayüzüne bağlı olan herhangi bir side-effectiniz varsa, composition iptal edilse bile side-effect uygulanacaktır. Bu, tutarsız uygulama state’ine yol açabilir. İyimser recomposition işlemini gerçekleştirmek için tüm composable fonksiyonların ve lambdaların idempotent ve side effect free olduğundan emin olun. Composable functions might run quite frequently . Bazı durumlarda, bir UI animasyonunun her karesi için composable bir fonksiyon çalışabilir. Fonksiyon, cihaz depolama alanından okuma gibi pahalı işlemler gerçekleştiriyorsa, UI sıkıntısına neden olabilir. Örneğin, widget’ınız cihaz ayarlarını okumaya çalışırsa, bu ayarları saniyede yüzlerce kez okuyabilir ve uygulamanızın performansı üzerinde feci etkiler yaratabilir. Composable fonksiyonunuz veriye ihtiyaç duyuyorsa, veri için parametreler tanımlamalıdır. Daha sonra pahalı işleri composition dışında başka bir thread’e taşıyabilir ve mutableStateOf veya LiveData kullanarak verileri Compose’a aktarabilirsiniz. ",
    "url": "/docs/jetpack-compose/introduction/thinking-in-compose/#recomposition",
    
    "relUrl": "/docs/jetpack-compose/introduction/thinking-in-compose/#recomposition"
  },"306": {
    "doc": "Thinking in Compose",
    "title": "Learn More",
    "content": "Compose ve composable fonksiyonlarda nasıl düşüneceğiniz hakkında daha fazla bilgi edinmek için aşağıdaki ek kaynaklara göz atın. Videos . | Composable funtions - MAD Skills | . ",
    "url": "/docs/jetpack-compose/introduction/thinking-in-compose/#learn-more",
    
    "relUrl": "/docs/jetpack-compose/introduction/thinking-in-compose/#learn-more"
  },"307": {
    "doc": "Transform data streams",
    "title": "Transform data streams",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/transform-data-streams/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/transform-data-streams/"
  },"308": {
    "doc": "Two-way data binding",
    "title": "Two-way data binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/two-way-data-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/two-way-data-binding/"
  },"309": {
    "doc": "Type-safe navigation with Compose",
    "title": "Type-safe navigation with Compose",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/type-safe-navigation-with-compose/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/type-safe-navigation-with-compose/"
  },"310": {
    "doc": "UI Architecture",
    "title": "UI Architecture",
    "content": " ",
    "url": "/docs/jetpack-compose/ui-architecture/ui-architecture/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/ui-architecture/"
  },"311": {
    "doc": "Ui events",
    "title": "UI events",
    "content": "UI eventleri, UI layerda UI veya ViewModel tarafından işlenmesi gereken actionlardir. En yaygın event türü, kullanıcı eventleridir. Kullanıcı, uygulamayla etkileşim kurarak, örneğin ekrana dokunarak veya hareketler(gesture) oluşturarak kullanıcı eventleri oluşturur. UI daha sonra onClick() listenerlar gibi callbackleri kullanarak bu olayları tüketir( consume eder). Anahtar terimler: . | Kullanıcı Arabirimi(UI): Kullanıcı arabirimini yöneten View tabanlı kod veya Compose kodu. | UI eventleri(Kullanici arabirimi olaylari): UI layerda handle edilmesi gereken gereken actionlar. | Kullanıcı eventlari(User events): Kullanıcının uygulama ile etkileşim kurarken oluşturduğu eventler. | . ViewModel normalde belirli bir kullanıcı eventinin business logicini handle etmekten sorumludur; örneğin, kullanıcının bazı verileri yenilemek için bir butona tıklaması. Genellikle ViewModel, UI’in çağırabileceği methodlari göstererek bunu halleder. Kullanıcı eventlari, UI’in doğrudan handle edebilecegi UI behavior logicine de sahip olabilir; örneğin, farklı bir ekrana gitme veya bir Snackbar gösterme. Farklı mobil platformlarda veya form factorlerinde aynı uygulama için business logic aynı kalırken, UI behaviour logic’i bu durumlar arasında farklılık gösterebilen bir implementasyon detayıdır. UI layer sayfası, bu logic türlerini aşağıdaki gibi tanımlar: . | İş mantığı(business logic), state değişiklikleriyle ne yapılacağını ifade eder; örneğin, ödeme yapmak veya kullanıcı tercihlerini saklamak. Domain ve data layerlar genellikle bu logic’i handle eder. Bu kılavuz boyunca, Architecture Components ViewModel sınıfı, business logic’i handle eden sınıflar için düşünülmüş bir çözüm olarak kullanılır. | UI davranış mantığı veya UI mantığı(UI behavior logic veya UI logic), state değişikliklerinin nasıl görüntüleneceğini ifade eder; örneğin, navigation logic’i veya kullanıcıya mesajların nasıl gösterileceği. UI bu logic’i handle eder. | . Not: Bu sayfada sunulan öneriler ve best practiceler, geniş bir uygulama yelpazesine uygulanarak ölçeklenebilir, kaliteyi ve sağlamlığı artırabilir ve test edilmesini kolaylaştırabilir. Ancak, bunları kılavuz olarak ele almalı ve gereksinimlerinize göre uyarlamalısınız. Architecture: Handling UI events-MAD Skills . UI event decision tree . Aşağıdaki diyagram, belirli bir event kullanım senaryosunu(use case) ele almak için en iyi yaklaşımı bulmaya yönelik bir karar ağacını(decision tree) göstermektedir. Bu kılavuzun geri kalanında bu yaklaşımlar ayrıntılı olarak açıklanmaktadır. Handle user events . Bu eventler, bir UI elementinin state’inin (örneğin, expandable bir itemin state’i) değiştirilmesiyle ilgiliyse, UI, kullanıcı eventlerini doğrudan handle edebilir. Event, ekrandaki verilerin yenilenmesi gibi business logicin yürütülmesini gerektiriyorsa ViewModel tarafından işlenmelidir. Aşağıdaki örnek, UI elementini genişletmek (UI logic) ve ekrandaki verileri yenilemek (business logic) için farklı butonlarin nasıl kullanıldığını gösterir: . // Views class LatestNewsActivity : AppCompatActivity() { private lateinit var binding: ActivityLatestNewsBinding private val viewModel: LatestNewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ // The expand details event is processed by the UI that // modifies a View's internal state. binding.expandButton.setOnClickListener { binding.expandedSection.visibility = View.VISIBLE } // The refresh event is processed by the ViewModel that is in charge // of the business logic. binding.refreshButton.setOnClickListener { viewModel.refreshNews() } } } //compose @Composable fun LatestNewsScreen(viewModel: LatestNewsViewModel = viewModel()) { // State of whether more details should be shown var expanded by remember { mutableStateOf(false) } Column { Text(\"Some text\") if (expanded) { Text(\"More details\") } Button( // The expand details event is processed by the UI that // modifies this composable's internal state. onClick = { expanded = !expanded } ) { val expandText = if (expanded) \"Collapse\" else \"Expand\" Text(\"$expandText details\") } // The refresh event is processed by the ViewModel that is in charge // of the UI's business logic. Button(onClick = { viewModel.refreshNews() }) { Text(\"Refresh data\") } } } . User Events in RecyclerViews . Action, bir RecyclerView iteminde veya custom bir Viewde olduğu gibi, UI ağacının daha aşağısında üretilirse, ViewModel yine de kullanıcı eventlerini handle eden olmalıdır. Örneğin, NewsActivity’den gelen tüm haber itemlerinin bir bookmark butonu içerdiğini varsayalım. ViewModel’in bookmark eklenmiş haber iteminin IDsini bilmesi gerekir. Kullanıcı bir haber öğesine bookmark koyduğunda, RecyclerView adapteri, ViewModel’e bağımlılık gerektirecek şekilde ViewModel’den açığa çıkan addBookmark(newsId) methodunu çağırmaz. Bunun yerine ViewModel, eventi handle etmek için implementasyonu içeren NewsItemUiState adlı bir state nesnesini gösterir: . data class NewsItemUiState( val title: String, val body: String, val bookmarked: Boolean = false, val publicationDate: String, val onBookmark: () -&gt; Unit ) class LatestNewsViewModel( private val formatDateUseCase: FormatDateUseCase, private val repository: NewsRepository ) { val newsListUiItems = repository.latestNews.map { news -&gt; NewsItemUiState( title = news.title, body = news.body, bookmarked = news.bookmarked, publicationDate = formatDateUseCase(news.publicationDate), // Business logic is passed as a lambda function that the // UI calls on click events. onBookmark = { repository.addBookmark(news.id) } ) } } . Bu şekilde, RecyclerView adapteri yalnızca ihtiyaç duyduğu verilerle çalışır: NewsItemUiState nesnelerinin listesi. Adapterin ViewModel’in tamamına erişimi yoktur, bu da ViewModel tarafından açığa çıkarılan fonksiyonaliteyi kötüye kullanma olasılığını azaltır. Yalnızca activity sınıfının ViewModel ile çalışmasına izin verdiğinizde, sorumlulukları ayırmış olursunuz. Bu, viewler veya RecyclerView adapterlari gibi UI’e özgü nesnelerin ViewModel ile doğrudan etkileşime girmemesini sağlar. Uyarı: ViewModel’i RecyclerView adapterina passlamak kötü bir uygulamadır çünkü adapteri ViewModel sınıfıyla sıkı bir şekilde birleştirir. Not: Diğer bir yaygın pattern, RecyclerView adapterinin kullanıcı eylemleri( actionlari) için bir callback interfaceine sahip olmasıdır. Bu durumda, activty veya fragment bindingi handle edebilir ve doğrudan callback interfaceinden ViewModel methodlarini çağırabilir. Naming conventions for user event functions . Bu kılavuzda, kullanıcı eventlerini handle eden ViewModel fonksiyonlari, gerçekleştirdikleri eyleme göre bir fiille adlandırılır; örneğin: addBookmark(id) veya logIn(username, password). Handle ViewModel Events . ViewModel’den kaynaklanan UI actionlari(ViewModel eventleri), her zaman bir UI state güncellemesiyle sonuçlanmalıdır. Bu, Tek Yönlü Veri Akışı(UDF) ilkelerine uygundur. Configuration changesden sonra eventleri yeniden üretilebilir hale getirir ve UI actionlarinin kaybolmayacağını garanti eder. İsteğe bağlı olarak, saved state modülünü kullanırsanız, eventleri process ölümünden sonra tekrarlanabilir hale getirebilirsiniz. UI actionlarini UI state’ine maplemek her zaman basit bir işlem değildir, ancak daha basit bir logice yol açar. Örneğin, düşünce süreciniz, UI’in belirli bir ekrana nasıl yönlendirileceğini belirlemekle bitmemelidir. Daha fazla düşünmeniz ve bu kullanıcı akışını UI state’inizde nasıl temsil edeceğinizi düşünmeniz gerekir. Başka bir deyişle: UI’in yapması gereken işlemleri düşünmeyin; bu actionlarinin UI state’ini nasıl etkilediğini düşünün. Anahtar Nokta: ViewModel eventleri her zaman bir UI state güncellemesiyle sonuçlanmalıdır. Örneğin, kullanıcı oturum açma ekranında oturum açtığında ana ekrana gitme durumunu düşünün. Bunu UI state’inde aşağıdaki gibi modelleyebilirsiniz: . data class LoginUiState( val isLoading: Boolean = false, val errorMessage: String? = null, val isUserLoggedIn: Boolean = false ) . Bu UI, isUserLoggedIn state’indeki değişikliklere tepki verir ve gerektiğinde doğru hedefe gider: . //views class LoginViewModel : ViewModel() { private val _uiState = MutableStateFlow(LoginUiState()) val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow() /* ... */ } class LoginActivity : AppCompatActivity() { private val viewModel: LoginViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { uiState -&gt; if (uiState.isUserLoggedIn) { // Navigate to the Home screen. } ... } } } } } //compose class LoginViewModel : ViewModel() { var uiState by mutableStateOf(LoginUiState()) private set /* ... */ } @Composable fun LoginScreen( viewModel: LoginViewModel = viewModel(), onUserLogIn: () -&gt; Unit ) { val currentOnUserLogIn by rememberUpdatedState(onUserLogIn) // Whenever the uiState changes, check if the user is logged in. LaunchedEffect(viewModel.uiState) { if (viewModel.uiState.isUserLoggedIn) { currentOnUserLogIn() } } // Rest of the UI for the login screen. } . Not: Bu bölümdeki kod örnekleri coroutinelerin ve bunların yaşam döngüsüne duyarlı bileşenlerle nasıl kullanılacağı nın anlaşılmasını gerektirir. Consuming events can trigger state updates . UI’de belirli ViewModel eventlerinin kullanılması, diğer UI state güncellemelerine neden olabilir. Örneğin, kullanıcıya bir şey olduğunu bildirmek için ekranda geçici mesajlar gösterilirken, mesaj ekranda gösterildiğinde UI’in ViewModel’e başka bir state güncellemesini tetiklemesi için bildirimde bulunması gerekir. Kullanıcı mesajı tükettiğinde (bırakarak veya bir zaman aşımından sonra) meydana gelen event, “user input” olarak ele alınabilir ve bu nedenle, ViewModel bunun farkında olmalıdır. Bu durumda, UI state aşağıdaki gibi modellenebilir: . // Models the UI state for the Latest news screen. data class LatestNewsUiState( val news: List&lt;News&gt; = emptyList(), val isLoading: Boolean = false, val userMessage: String? = null ) . ViewModel, business logic kullanıcıya yeni bir geçici mesaj gösterilmesini gerektirdiğinde UI state’ini aşağıdaki gibi günceller: . //Views class LatestNewsViewModel(/* ... */) : ViewModel() { private val _uiState = MutableStateFlow(LatestNewsUiState(isLoading = true)) val uiState: StateFlow&lt;LatestNewsUiState&gt; = _uiState fun refreshNews() { viewModelScope.launch { // If there isn't internet connection, show a new message on the screen. if (!internetConnection()) { _uiState.update { currentUiState -&gt; currentUiState.copy(userMessage = \"No Internet connection\") } return@launch } // Do something else. } } fun userMessageShown() { _uiState.update { currentUiState -&gt; currentUiState.copy(userMessage = null) } } } //compose class LatestNewsViewModel(/* ... */) : ViewModel() { var uiState by mutableStateOf(LatestNewsUiState()) private set fun refreshNews() { viewModelScope.launch { // If there isn't internet connection, show a new message on the screen. if (!internetConnection()) { uiState = uiState.copy(userMessage = \"No Internet connection\") return@launch } // Do something else. } } fun userMessageShown() { uiState = uiState.copy(userMessage = null) } } . ViewModel’in, UI’in mesajı ekranda nasıl gösterdiğini bilmesi gerekmez; sadece gösterilmesi gereken bir kullanıcı mesajı olduğunu bilir. Geçici mesaj gösterildikten sonra, UI’in bunu ViewModel’e bildirmesi gerekir ve başka bir UI state güncellemesinin userMessage propertysini temizlemesine neden olur: . //views class LatestNewsActivity : AppCompatActivity() { private val viewModel: LatestNewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { uiState -&gt; uiState.userMessage?.let { // TODO: Show Snackbar with userMessage. // Once the message is displayed and // dismissed, notify the ViewModel. viewModel.userMessageShown() } ... } } } } } //compose @Composable fun LatestNewsScreen( snackbarHostState: SnackbarHostState, viewModel: LatestNewsViewModel = viewModel(), ) { // Rest of the UI content. // If there are user messages to show on the screen, // show it and notify the ViewModel. viewModel.uiState.userMessage?.let { userMessage -&gt; LaunchedEffect(userMessage) { snackbarHostState.showSnackbar(userMessage) // Once the message is displayed and dismissed, notify the ViewModel. viewModel.userMessageShown() } } } . Mesaj geçici olsa da, UI state, zamanın her noktasında ekranda görüntülenenlerin aslına sadık bir temsilidir. Kullanıcı mesajı görüntülenir veya görüntülenmez. Not: Ekranda gösterilecek kullanıcı mesajlarının listesini içeren daha gelişmiş bir kullanım örneği için Jetsnack Compose örneğine bakın. Navigation Events . Consuming events can trigger state updates bölümü, kullanıcı mesajlarını ekranda görüntülemek için UI state’ini nasıl kullandığınızı ayrıntılarıyla açıklar. Navigasyon eventleri, bir Android uygulamasında da yaygın olarak görülen bir event türüdür. Event, kullanıcı bir butona dokunduğu için UI’de tetiklenirse, UI, navigation controller çağırarak veya eventi çağırana uygun şekilde composable olarak göstererek bununla ilgilenir. //views class LoginActivity : AppCompatActivity() { private lateinit var binding: ActivityLoginBinding private val viewModel: LoginViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ binding.helpButton.setOnClickListener { navController.navigate(...) // Open help screen } } } //compose @Composable fun LoginScreen( onHelp: () -&gt; Unit, // Caller navigates to the right screen viewModel: LoginViewModel = viewModel() ) { // Rest of the UI Button(onClick = onHelp) { Text(\"Get help\") } } . Data input, navigateden önce bazı business logic doğrulaması gerektiriyorsa, ViewModel’in bu durumu UI’a göstermesi gerekir. Kullanıcı arayüzü bu state değişikliğine tepki verir ve buna göre navigate eder. Handle ViewModel events section bölümü bu kullanım durumunu kapsar. İşte benzer bir kod: . //views class LoginActivity : AppCompatActivity() { private val viewModel: LoginViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { uiState -&gt; if (uiState.isUserLoggedIn) { // Navigate to the Home screen. } ... } } } } } //compose @Composable fun LoginScreen( onUserLogIn: () -&gt; Unit, // Caller navigates to the right screen viewModel: LoginViewModel = viewModel() ) { Button( onClick = { // ViewModel validation is triggered viewModel.login() } ) { Text(\"Log in\") } // Rest of the UI val lifecycle = LocalLifecycleOwner.current.lifecycle val currentOnUserLogIn by rememberUpdatedState(onUserLogIn) LaunchedEffect(viewModel, lifecycle) { // Whenever the uiState changes, check if the user is logged in and // call the `onUserLogin` event when `lifecycle` is at least STARTED snapshotFlow { viewModel.uiState } .filter { it.isUserLoggedIn } .flowWithLifecycle(lifecycle) .collect { currentOnUserLogIn() } } } . Yukarıdaki örnekte, current destination olan Login backstackde tutulmayacağından uygulama beklendiği gibi çalışır. Kullanıcılar geri basarlarsa geri dönemezler. Ancak bunun olabileceği durumlarda, çözüm ek logic gerektirecektir. Navigation events when the destination is kept in the back stack . Bir ViewModel, A ekranından B ekranına bir navigation event üreten bir state belirlediğinde ve A ekranı navigation backstack’nde tutulduğunda, otomatik olarak B’ye ilerlemeye devam etmemek için ek logice ihtiyacınız olabilir. Bunu implement etmek için, UI’in diğer ekrana gitmeyi düşünüp düşünmemesi gerektiğini gösteren ek bir state’e sahip olunması gerekir.Normalde, bu state UI’de tutulur çünkü Navigation logic, ViewModel ile değil, UI ile ilgilidir. Bunu göstermek için, aşağıdaki kullanım örneğini ele alalım. Diyelim ki uygulamanızın kayıt akışındasınız. Doğum tarihi doğrulama ekranında, kullanıcı bir tarih girdiğinde, kullanıcı “Continue” butonuna dokunduğunda tarih ViewModel tarafından doğrulanır. ViewModel, doğrulama logic’ini data katmanına devreder. Tarih geçerliyse, kullanıcı bir sonraki ekrana geçer. Ek bir özellik olarak, kullanıcılar bazı verileri değiştirmek istediklerinde farklı kayıt ekranları arasında gidip gelebilirler. Bu nedenle, kayıt akışındaki tüm destinationlar aynı backstackde tutulur. Bu gereksinimler göz önüne alındığında, bu ekranı aşağıdaki gibi uygulayabilirsiniz: . //views // Key that identifies the `validationInProgress` state in the Bundle private const val DOB_VALIDATION_KEY = \"dobValidationKey\" class DobValidationFragment : Fragment() { private var validationInProgress: Boolean = false private val viewModel: DobValidationViewModel by viewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) val binding = // ... validationInProgress = savedInstanceState?.getBoolean(DOB_VALIDATION_KEY) ?: false binding.continueButton.setOnClickListener { viewModel.validateDob() validationInProgress = true } viewLifecycleOwner.lifecycleScope.launch { launch { viewModel.uiState .flowWithLifecycle(viewLifecycleOwner.lifecycle) .collect { uiState -&gt; // Update other parts of the UI ... // If the input is valid and the user wants // to navigate, navigate to the next screen // and reset `validationInProgress` flag if (uiState.isDobValid &amp;&amp; validationInProgress) { validationInProgress = false navController.navigate(...) // Navigate to next screen } } } } return binding } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) outState.putBoolean(DOB_VALIDATION_KEY, validationInProgress) } } //compose class DobValidationViewModel(/* ... */) : ViewModel() { var uiState by mutableStateOf(DobValidationUiState()) private set } @Composable fun DobValidationScreen( onNavigateToNextScreen: () -&gt; Unit, // Caller navigates to the right screen viewModel: DobValidationViewModel = viewModel() ) { // TextField that updates the ViewModel when a date of birth is selected var validationInProgress by rememberSaveable { mutableStateOf(false) } Button( onClick = { viewModel.validateInput() validationInProgress = true } ) { Text(\"Continue\") } // Rest of the UI /* * The following code implements the requirement of advancing automatically * to the next screen when a valid date of birth has been introduced * and the user wanted to continue with the registration process. */ if (validationInProgress) { val lifecycle = LocalLifecycleOwner.current.lifecycle val currentNavigateToNextScreen by rememberUpdatedState(onNavigateToNextScreen) LaunchedEffect(viewModel, lifecycle) { // If the date of birth is valid and the validation is in progress, // navigate to the next screen when `lifecycle` is at least STARTED, // which is the default Lifecycle.State for the `flowWithLifecycle` operator. snapshotFlow { viewModel.uiState } .filter { it.isDobValid } .flowWithLifecycle(lifecycle) .collect { validationInProgress = false currentNavigateToNextScreen() } } } } . Doğum tarihi doğrulama, ViewModel’in sorumlu olduğu business logictir. ViewModel çoğu zaman bu logic’i data katmanına devreder. Kullanıcıyı bir sonraki ekrana yönlendirme mantığı, UI logictir çünkü bu gereksinimler, UI yapılandırmasına bağlı olarak değişebilir. Örneğin, aynı anda birden çok kayıt adımı gösteriyorsanız, bir tablette otomatik olarak başka bir ekrana ilerlemek istemeyebilirsiniz. Yukarıdaki koddaki validationInProgress değişkeni bu işlevi uygular ve UI’in doğum tarihi geçerli olduğunda ve kullanıcı aşağıdaki kayıt adımına devam etmek istediğinde otomatik olarak navigate edilip edilmeyeceğini belirler. Other Use Cases . UI event usecaseinizin UI state güncellemeleriyle çözülemeyeceğini düşünüyorsanız, uygulamanızda veri akışını yeniden gözden geçirmeniz gerekebilir. Aşağıdaki ilkeleri göz önünde bulundurun: . | Her sınıf sorumlu olduğu şeyi yapmalı, daha fazlasını değil. Kullanıcı arabirimi, navigation calls, click events ve izin istekleri alma gibi ekrana özgü davranış mantığından sorumludur. ViewModel, iş mantığını içerir ve sonuçları hiyerarşinin alt katmanlarından UI state’ine dönüştürür. | Eventin nereden kaynaklandığını düşünün. Bu kılavuzun başında sunulan decision tree’yi takip edin ve her sınıfın sorumlu olduğu konuyu halletmesini sağlayın. Örneğin, event kullanıcı arayüzünden geliyorsa ve bir navigate ile olayıyla sonuçlanıyorsa, o eventin kullanıcı arayüzünde handle edilmesi gerekir. Bazı logicler ViewModel’e devredilebilir, ancak eventin handle edilmesi tamamen ViewModel’e devredilemez. | Birden çok consumer varsa ve activitynin birden çok kez consume edilmesinden endişe ediyorsanız uygulama mimarinizi yeniden gözden geçirmeniz gerekebilir. Birden fazla concurrent consumure sahip olmak, tam olarak bir kez teslim edilen sözleşmenin garanti edilmesinin son derece zor hale gelmesine neden olur, bu nedenle karmaşıklık ve subtle behavior miktarı patlar. Bu sorunu yaşıyorsanız, bu endişeleri kullanıcı arabirimi ağacınızda yukarıya taşımayı düşünün; hiyerarşide daha üstte yer alan farklı bir entitye ihtiyacınız olabilir. | State’in ne zaman tüketilmesi gerektiğini bir düşünün. Belirli durumlarda, uygulama arka plandayken (örneğin, bir Toast gösterirken) state’i tüketmeye devam etmek istemeyebilirsiniz. Bu gibi durumlarda, kullanıcı arabirimi ön planda olduğunda state’i kullanmayı düşünün. | . Not: Bazı uygulamalarda, ViewModel eventlerinin Kotlin Channels veya diğer reactive streams kullanılarak kullanıcı arayüzüne maruz kaldığını görmüş olabilirsiniz. Producer (ViewModel) consumeri (UI—Compose veya Views) geride bıraktığında, bu çözümler bu eventlerin teslimini ve işlenmesini garanti etmez. Bu, geliştirici için gelecekte sorunlara neden olabilir ve aynı zamanda çoğu uygulama için kabul edilemez bir kullanıcı deneyimidir çünkü bu, uygulamayı tutarsız bir durumda bırakabilir, hatalara neden olabilir veya kullanıcı kritik bilgileri kaçırabilir. Bu durumlardan birindeyseniz, o tek seferlik ViewModel eventinin kullanıcı arayüzünüz için gerçekte ne anlama geldiğini tekrar düşünün. Bunları hemen handle edin ve UI state’ine indirin. UI state’i, UI’yi belirli bir zamanda daha iyi temsil eder, size daha fazla teslimat ve işleme garantisi verir, test edilmesi genellikle daha kolaydır ve uygulamanızın geri kalanıyla tutarlı bir şekilde entegre olur. Bazı kod örnekleriyle yukarıda bahsedilen API’leri neden kullanmamanız gerektiği hakkında daha fazla bilgi edinmek için ViewModel: One-off event antipatterns blog gönderisini okuyun. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events/#ui-events",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events/#ui-events"
  },"312": {
    "doc": "Ui events",
    "title": "Ui events",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events/"
  },"313": {
    "doc": "UI layer libraries",
    "title": "UI layer libraries",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/ui-layer-libraries/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/ui-layer-libraries/"
  },"314": {
    "doc": "Ui layer",
    "title": "Ui layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-layer/"
  },"315": {
    "doc": "Unicode and internationalization support",
    "title": "Unicode and internationalization support",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/unicode-and-internationalization-support/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/unicode-and-internationalization-support/"
  },"316": {
    "doc": "Update UI components with NavigationUI",
    "title": "Update UI components with NavigationUI",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/update-ui-components-with-navigationui/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/update-ui-components-with-navigationui/"
  },"317": {
    "doc": "Use Hilt with other Jetpack libraries",
    "title": "Use Hilt with other Jetpack libraries",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/use-hilt-with-other-jetpack-libraries/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/use-hilt-with-other-jetpack-libraries/"
  },"318": {
    "doc": "Use Kotlin coroutines with Lifecycle-aware components",
    "title": "Use Kotlin coroutines with Lifecycle-aware components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/use-kotlin-coroutines-with-lifecycle-aware-components/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/use-kotlin-coroutines-with-lifecycle-aware-components/"
  },"319": {
    "doc": "Using Dagger in Android apps",
    "title": "Using Dagger in Android apps",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-android-apps/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-android-apps/"
  },"320": {
    "doc": "Using Dagger in multi-module apps",
    "title": "Using Dagger in multi-module apps",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-multi-module-apps/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-multi-module-apps/"
  },"321": {
    "doc": "Using the Bill of Materials",
    "title": "Using the Bill of Materials",
    "content": "Compose Malzeme Listesi (BOM), yalnızca BOM’un sürümünü belirterek tüm Compose kütüphane sürümlerinizi yönetmenizi sağlar. BOM’un kendisi, birlikte iyi çalışacak şekilde farklı Compose kütüphanelerinin kararlı sürümlerine bağlantılar içerir. Uygulamanızda BOM’u kullanırken, Compose kütüphane bağımlılıklarının kendilerine herhangi bir sürüm eklemeniz gerekmez. BOM sürümünü güncellediğinizde, kullandığınız tüm kütüphaneler otomatik olarak yeni sürümlerine güncellenir. Hangi Compose kütüphane sürümlerinin belirli bir BOM sürümüyle eşlendiğini öğrenmek için BOM ile kütüphane sürümü eşlemesine göz atın. ",
    "url": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/",
    
    "relUrl": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/"
  },"322": {
    "doc": "Using the Bill of Materials",
    "title": "Compose Compiler kütüphanesi neden BOM’a dahil edilmemiştir?",
    "content": "Compose Kotlin derleyici uzantısı (androidx.compose.compiler) Compose kütüphane sürümlerine bağlı değildir. Bunun yerine, Kotlin derleyici eklentisinin sürümlerine bağlanır ve Compose’un geri kalanından ayrı bir tempoda yayınlanır, bu nedenle Kotlin sürümünüzle uyumlu bir sürüm kullandığınızdan emin olun. Eklentinin her bir sürümüyle eşleşen Kotlin sürümünü Compose to Kotlin Compatibility Map adresinde bulabilirsiniz. ",
    "url": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#compose-compiler-k%C3%BCt%C3%BCphanesi-neden-boma-dahil-edilmemi%C5%9Ftir",
    
    "relUrl": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#compose-compiler-kütüphanesi-neden-boma-dahil-edilmemiştir"
  },"323": {
    "doc": "Using the Bill of Materials",
    "title": "BOM’da belirtilenden farklı bir kütüphane sürümünü nasıl kullanabilirim?",
    "content": "build.gradle dependencies bölümünde, BOM platformunun import edilmesini sağlayın. Kütüphane bağımlılığı import’unda, istediğiniz sürümü belirtin. Örneğin, BOM’da hangi sürüm belirtilmiş olursa olsun Material 3’ün alfa sürümünü kullanmak istiyorsanız bağımlılıkları şu şekilde bildirebilirsiniz: . dependencies { // Import the Compose BOM implementation platform('androidx.compose:compose-bom:2023.04.01') // Override Material Design 3 library version with a pre-release version implementation 'androidx.compose.material3:material3:1.1.0-alpha01' // Import other Compose libraries without version numbers // .. implementation 'androidx.compose.foundation:foundation' } . Not: Bir Compose kütüphanesinin alfa sürümünü kullanmak için BOM’u override etmek, derlemenizi bu alfa kütüphanesinin gerekli bağımlılıklarını kullanacak şekilde güncelleyecektir (bu da alfa olabilir). ",
    "url": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bomda-belirtilenden-farkl%C4%B1-bir-k%C3%BCt%C3%BCphane-s%C3%BCr%C3%BCm%C3%BCn%C3%BC-nas%C4%B1l-kullanabilirim",
    
    "relUrl": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bomda-belirtilenden-farklı-bir-kütüphane-sürümünü-nasıl-kullanabilirim"
  },"324": {
    "doc": "Using the Bill of Materials",
    "title": "BOM tüm Compose kitaplıklarını otomatik olarak uygulamama ekliyor mu?",
    "content": "Hayır. Uygulamanıza Compose kütüphanelerini eklemek ve kullanmak için her kütüphaneyi modül (uygulama düzeyinde) Gradle dosyanızda (genellikle app/build.gradle) ayrı bir bağımlılık satırı olarak bildirmeniz gerekir. BOM’u kullanmak, uygulamanızdaki tüm Compose kitaplıklarının sürümlerinin uyumlu olmasını sağlar, ancak BOM aslında bu Compose kitaplıklarını uygulamanıza eklemez. ",
    "url": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bom-t%C3%BCm-compose-kitapl%C4%B1klar%C4%B1n%C4%B1-otomatik-olarak-uygulamama-ekliyor-mu",
    
    "relUrl": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bom-tüm-compose-kitaplıklarını-otomatik-olarak-uygulamama-ekliyor-mu"
  },"325": {
    "doc": "Using the Bill of Materials",
    "title": "Compose kitaplık sürümlerini yönetmek için neden BOM önerilen yoldur?",
    "content": "İleride, Compose kütüphaneleri bağımsız olarak sürümlendirilecek, bu da sürüm numaralarının kendi hızlarında artırılmaya başlanacağı anlamına geliyor. Her kütüphanenin en son kararlı sürümleri test edilmiş ve birlikte iyi çalışacakları garanti edilmiştir. Ancak, her kütüphanenin en son kararlı sürümlerini bulmak zor olabilir ve BOM bu en son sürümleri otomatik olarak kullanmanıza yardımcı olur. ",
    "url": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#compose-kitapl%C4%B1k-s%C3%BCr%C3%BCmlerini-y%C3%B6netmek-i%C3%A7in-neden-bom-%C3%B6nerilen-yoldur",
    
    "relUrl": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#compose-kitaplık-sürümlerini-yönetmek-için-neden-bom-önerilen-yoldur"
  },"326": {
    "doc": "Using the Bill of Materials",
    "title": "BOM’u kullanmak zorunda mıyım?",
    "content": "Hayır. Her bir bağımlılık sürümünü manuel olarak eklemeyi seçebilirsiniz. Ancak, en son kararlı sürümlerin tümünü aynı anda kullanmayı kolaylaştıracağı için BOM’u kullanmanızı öneririz. ",
    "url": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bomu-kullanmak-zorunda-m%C4%B1y%C4%B1m",
    
    "relUrl": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bomu-kullanmak-zorunda-mıyım"
  },"327": {
    "doc": "Using the Bill of Materials",
    "title": "BOM sürüm katalogları ile çalışır mı?",
    "content": "Evet. BOM’un kendisini sürüm kataloğuna dahil edebilir ve diğer Compose kütüphane sürümlerini atlayabilirsiniz: . [libraries] androidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"androidxComposeBom\" } androidx-compose-foundation = { group = \"androidx.compose.foundation\", name = \"foundation\" } . Modülünüzün build.gradle dosyasında BOM’u içe aktarmayı unutmayın: . dependencies { val composeBom = platform(libs.androidx.compose.bom) implementation(composeBom) androidTestImplementation(composeBom) // import Compose dependencies as usual } . ",
    "url": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bom-s%C3%BCr%C3%BCm-kataloglar%C4%B1-ile-%C3%A7al%C4%B1%C5%9F%C4%B1r-m%C4%B1",
    
    "relUrl": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bom-sürüm-katalogları-ile-çalışır-mı"
  },"328": {
    "doc": "Using the Bill of Materials",
    "title": "Bir sorunu nasıl bildirebilirim veya BOM hakkında nasıl geri bildirimde bulunabilirim?",
    "content": "Sorun izleyicimize sorunlarınızı bildirebilirsiniz. ",
    "url": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bir-sorunu-nas%C4%B1l-bildirebilirim-veya-bom-hakk%C4%B1nda-nas%C4%B1l-geri-bildirimde-bulunabilirim",
    
    "relUrl": "/docs/jetpack-compose/introduction/using-the-bill-of-materials/#bir-sorunu-nasıl-bildirebilirim-veya-bom-hakkında-nasıl-geri-bildirimde-bulunabilirim"
  },"329": {
    "doc": "Verify app links",
    "title": "Verify app links",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/verify-app-links/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/verify-app-links/"
  },"330": {
    "doc": "View binding",
    "title": "View binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/view-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/view-binding/"
  },"331": {
    "doc": "ViewModel APIs cheat sheet",
    "title": "ViewModel APIs cheat sheet",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-apis-cheat-sheet/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-apis-cheat-sheet/"
  },"332": {
    "doc": "ViewModels scoping APIs",
    "title": "ViewModels scoping APIs",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-scoping-apis/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-scoping-apis/"
  },"333": {
    "doc": "ViewModel",
    "title": "ViewModel",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel/"
  },"334": {
    "doc": "Where to Hoist State",
    "title": "Where to Hoist State",
    "content": "Bir Compose uygulamasında, UI state‘ini nereye hoist ettiğiniz, UI logic veya business logic’in bunu gerektirip gerektirmediğine bağlıdır. Bu belge, bu iki ana senaryoyu ortaya koymaktadır. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/"
  },"335": {
    "doc": "Where to Hoist State",
    "title": "Best Practice",
    "content": "UI state’ini, onu okuyan ve yazan tüm composable’lar arasındaki en düşük ortak ataya hoist etmelisiniz. State’i tüketildiği yere en yakın yerde tutmalısınız. State sahibinden, tüketicilere immutable state’i ve state’i değiştirmek için event’leri gösterin. En düşük ortak ata Composition’ın dışında da olabilir. Örnek olarak, iş mantığı söz konusu olduğu için bir ViewModel’de state’i hoisting ederken. Bu sayfa, bu en iyi pratiği ve akılda tutulması gereken bir uyarıyı ayrıntılı olarak açıklamaktadır. Where to hoist that state in Compose . ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#best-practice",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#best-practice"
  },"336": {
    "doc": "Where to Hoist State",
    "title": "Types of UI state and UI logic",
    "content": "Aşağıda, bu belge boyunca kullanılan UI state ve logic türleri için tanımlar bulunmaktadır. UI State . UI state, UI’yi tanımlayan property’dir. İki tür UI state vardır: . | Ekran UI state‘i, ekranda görüntülemek için ihtiyaç duyduğunuz şeydir. Örneğin, bir NewsUiState sınıfı, haber makalelerini ve UI’yi oluşturmak için gereken diğer bilgileri içerebilir. Bu state, uygulama verilerini içerdiği için genellikle hiyerarşinin diğer katmanlarıyla bağlantılıdır. | UI öğesi state‘i, nasıl oluşturulduklarını etkileyen UI öğelerine özgü propertyleri ifade eder. Bir UI öğesi gösterilebilir veya gizlenebilir ve belirli bir yazı tipine, yazı tipi boyutuna veya yazı tipi rengine sahip olabilir. Android View’lerde View, doğası gereği stateful olduğu için bu state’i kendisi yönetir ve state’ini değiştirmek veya sorgulamak için metotlar sunar. Buna örnek olarak TextView sınıfının metin için get ve set metotları verilebilir. Jetpack Compose’da state, composable’ın dışındadır ve hatta onu composable’ın yakın çevresinden çağıran composable fonksiyonuna veya bir state holder’a çekebilirsiniz. Bunun bir örneği, Scaffold composable için ScaffoldState‘tir. Logic . Bir uygulamadaki mantık, iş mantığı veya UI mantığı olabilir: . | Business logic, uygulama verileri için ürün gereksinimlerinin uygulanmasıdır. Örneğin, kullanıcı düğmeye dokunduğunda bir haber okuyucu uygulamasında bir makalenin yer imlerine eklenmesi. Yer imini bir dosyaya veya veritabanına kaydetmeye yönelik bu mantık genellikle domain veya data katmanlarına yerleştirilir. State holder genellikle bu mantığı, ortaya çıkardıkları metotları çağırarak bu katmanlara devreder. | UI logic, UI statinin ekranda nasıl görüntüleneceği ile ilgilidir. Örneğin, kullanıcı bir kategori seçtiğinde doğru arama çubuğu ipucunun elde edilmesi, bir listede belirli bir öğeye kaydırma veya kullanıcı bir düğmeye tıkladığında belirli bir ekrana navigasyon mantığı. | . ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#types-of-ui-state-and-ui-logic",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#types-of-ui-state-and-ui-logic"
  },"337": {
    "doc": "Where to Hoist State",
    "title": "UI logic",
    "content": "UI mantığının state’i okuması veya yazması gerektiğinde, state’i yaşam döngüsünü takip ederek UI’ye scope etmelisiniz. Bunu başarmak için, state’i composable bir fonksiyonda doğru seviyede hoist etmelisiniz. Alternatif olarak, bunu yine UI yaşam döngüsüne göre scopelandirilmis düz bir state holder sınıfında da yapabilirsiniz. Aşağıda her iki çözümün de açıklaması ve hangisinin ne zaman kullanılacağı yer almaktadır. Composables as state owner . UI logic ve UI öğesi state’inin composable’larda olması, state ve logic basitse iyi bir yaklaşımdır. State’inizi gerektiğinde bir composable veya hoist’e dahili olarak bırakabilirsiniz. No state hoisting needed . State’in hoisting edilmesi her zaman gerekli değildir. Başka bir composable’ın kontrol etmesi gerekmediğinde state bir composable’da dahili olarak tutulabilir. Bu kod parçasında, dokunulduğunda genişleyen ve daralan bir composable vardır: . @Composable fun ChatBubble( message: Message ) { var showDetails by rememberSaveable { mutableStateOf(false) } // UI öğesi genişletme state'ini tanımlama ClickableText( text = AnnotatedString(message.content), onClick = { showDetails = !showDetails } // Basit UI mantığı uygulayın ) if (showDetails) { Text(message.timestamp) } } . showDetails değişkeni bu UI öğesinin dahili state’idir. Sadece bu composable içinde okunur ve değiştirilir ve ona uygulanan mantık çok basittir. Bu durumda state’i hoist etmek çok fazla fayda sağlamayacaktır, bu nedenle onu dahili olarak bırakabilirsiniz. Bunu yapmak, bu composable’ı genişletilmiş state’in sahibi ve tek doğruluk kaynağı haline getirir. Anahtar Nokta: UI öğesi state’ini composable fonksiyonların içinde tutmak kabul edilebilir. Uyguladığınız state ve mantık basitse ve UI hiyerarşisinin diğer bölümleri state’e ihtiyaç duymuyorsa bu iyi bir çözümdür. Örneğin, bu durum genellikle animasyon state’i için geçerlidir. Hoisting within composables . UI öğesi state’inizi diğer composable’larla paylaşmanız ve UI mantığını farklı yerlerde uygulamanız gerekiyorsa, UI hiyerarşisinde daha yükseğe hoist edebilirsiniz. Bu aynı zamanda composable’larınızı daha yeniden kullanılabilir ve test edilmesi daha kolay hale getirir. Aşağıdaki örnek, iki fonksiyonel parçayı uygulayan bir sohbet uygulamasıdır: . | JumpToBottom butonu mesaj listesini en alta kaydırır. Buton, liste state’i üzerinde UI mantığı gerçekleştirir. | MessagesList listesi, kullanıcı yeni mesajlar gönderdikten sonra en alta kaydırılır. UserInput, liste state’i üzerinde UI mantığı gerçekleştirir. | . Şekil 1. JumpToBottom butonu ve yeni mesajlarda aşağıya kaydırma özelliğine sahip sohbet uygulaması . Composable hiyerarşi aşağıdaki gibidir: Şekil 2. Chat Composable ağacı . LazyColumn state’i konuşma ekranına hoist edilir, böylece uygulama UI mantığını gerçekleştirebilir ve bunu gerektiren tüm composable’lardan state’i okuyabilir: Şekil 3. LazyColumn state’inin LazyColumn’dan ConversationScreen’e taşınması . Son olarak composablelar: Şekil 4. ConversationScreen’e hoist edilmis LazyListState ile sohbet composable ağacı . Kod aşağıdaki gibidir: . @Composable private fun ConversationScreen(/*...*/) { val scope = rememberCoroutineScope() val lazyListState = rememberLazyListState() // State ConversationScreen'e hoist edildi MessagesList(messages, lazyListState) // Ayni state'i MessagesList'de kullanin UserInput( onMessageSent = { // UI logic'i lazyListState üzerinde uygulayin scope.launch { lazyListState.scrollToItem(0) } }, ) } @Composable private fun MessagesList( messages: List&lt;Message&gt;, lazyListState: LazyListState = rememberLazyListState() // LazyListState default deger aldi ) { LazyColumn( state = lazyListState // Hoist edilmis state'i LazyColumn'a geçirin ) { items(messages, key = { message -&gt; message.id }) { item -&gt; Message(/*...*/) } } val scope = rememberCoroutineScope() JumpToBottom(onClicked = { scope.launch { lazyListState.scrollToItem(0) // lazyListState'e uygulanan UI mantığı } }) } . LazyListState, uygulanması gereken UI mantığı için gerektiği kadar yükseğe hoist edilir. Composable bir fonksiyonda initialize edildiğinden, yaşam döngüsünü takip ederek Composition’da saklanır. LazyListState’in MessagesList metodunda rememberLazyListState() varsayılan değeri ile tanımlandığını unutmayın. Bu, Compose’da yaygın bir patterndir. Composable’ları daha yeniden kullanılabilir ve esnek hale getirir. Daha sonra composable’ı uygulamanın state’i kontrol etmesi gerekmeyen farklı bölümlerinde kullanabilirsiniz. Bu genellikle bir composable’ı test ederken veya önizleme yaparken söz konusu olur. LazyColumn state’ini tam olarak bu şekilde tanımlar. Kilit Nokta: State’i en düşük ortak ataya hoist edin ve ihtiyacı olmayan composable’lara geçirmekten kaçının. Şekil 5. LazyListState için en düşük ortak ata ConversationScreen’dir . Plain state holder class as state owner . Bir composable, bir UI öğesinin bir veya birden fazla state field’ını içeren karmaşık UI mantığı içerdiğinde, bu sorumluluğu düz bir state holder sınıfı gibi state holder’lara devretmelidir. Bu, composable’ın mantığını izole olarak daha test edilebilir hale getirir ve karmaşıklığını azaltır. Bu yaklaşım, seperation of concerns ilkesini destekler: composable, UI öğelerini emit etmekten sorumludur ve state holder, UI mantığını ve UI öğesi state’ini içerir. Düz state holder sınıfları, composable fonksiyonunuzu çağıranlara kullanışlı fonksiyonlar sağlar, böylece bu mantığı kendileri yazmak zorunda kalmazlar. Bu düz sınıflar Composition içinde oluşturulur ve hatırlanır. Composable’ın yaşam döngüsünü takip ettikleri için, Compose kütüphanesi tarafından sağlanan rememberNavController() veya rememberLazyListState() gibi türleri alabilirler. Bunun bir örneği, LazyColumn veya LazyRow‘un UI karmaşıklığını kontrol etmek için Compose’da uygulanan LazyListState düz state holder sınıfıdır. // LazyListState.kt @Stable class LazyListState constructor( firstVisibleItemIndex: Int = 0, firstVisibleItemScrollOffset: Int = 0 ) : ScrollableState { /** * Suanki scroll pozisyonu icin holder sinifi */ private val scrollPosition = LazyListScrollPosition( firstVisibleItemIndex, firstVisibleItemScrollOffset ) suspend fun scrollToItem(/*...*/) { /*...*/ } override suspend fun scroll() { /*...*/ } suspend fun animateScrollToItem() { /*...*/ } } . LazyListState, bu UI öğesi için scrollPosition değerini saklayan LazyColumn state’ini encapsulate eder. Ayrıca, örneğin belirli bir öğeye kaydırma yaparak kaydırma konumunu değiştirmek için metotlar sunar. Not: Bu sınıf Stable olarak annotate edilmiştir. Compose’da stabilite hakkında daha fazla bilgi için bu blog gönderisine göz atın. Gördüğünüz gibi, bir composable’ın sorumluluklarını artırmak, bir state holder ihtiyacını artırır. Sorumluluklar UI mantığında ya da sadece takip edilmesi gereken state miktarında olabilir. Not: Düz state holder sınıfları bir Activity veya proses yeniden oluşturulduktan sonra korumak istediğiniz state içeriyorsa, rememberSaveable kullanın ve bunun için özel bir Saver oluşturun. Bir başka yaygın pattern de uygulamadaki root composable fonksiyonlarının karmaşıklığını ele almak için düz bir state holder sınıfı kullanmaktır. Navigasyon state’i ve ekran boyutlandırma gibi uygulama düzeyinde state’i enkapsüle etmek için böyle bir sınıf kullanabilirsiniz. Bunun tam bir açıklaması UI logic and its state holder sayfasında bulunabilir. ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#ui-logic",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#ui-logic"
  },"338": {
    "doc": "Where to Hoist State",
    "title": "Business logic",
    "content": "Composable ve plain state holder sınıfları UI mantığı ve UI element state’inden sorumluysa, bir ekran seviyesi state holder aşağıdaki görevlerden sorumludur: . | Genellikle business ve data katmanları gibi hiyerarşinin diğer katmanlarında yer alan uygulamanın iş mantığına erişim sağlamak. | Uygulama verilerini belirli bir ekranda sunum için hazırlamak, bu da ekran UI state’i haline gelir. | . ViewModels as state owner . AAC ViewModellerinin Android geliştirmedeki faydaları, onları iş mantığına erişim sağlamak ve uygulama verilerini ekranda sunum için hazırlamak için uygun hale getirir. Kilit Nokta: ViewModel, belirli sorumlulukları olan bir state holder’ın sadece bir uygulama detayıdır. Projenizin modülünü Android bağımlılıklarından uzak tutmak istiyorsanız, uygulamayı farklı bağlamlarda değiştirilebilir hale getirmek için interfacelere güvenebilirsiniz. Örneğin, Android’e özgü modülünüzde ViewModel’i ve diğer modüllerde düz bir state holder sınıfı gibi daha basit platformdan bağımsız implementasyonları kullanabilirsiniz. ViewModel’de UI state’ini hoist ettiğinizde, onu Composition’ın dışına taşırsınız. Şekil 6. ViewModel’e hoist edilen State, Composition’ın dışında saklanır. ViewModelleri Composition’ın bir parçası olarak saklanmaz. Framework tarafından sağlanırlar ve bir Activity, Fragment, navigasyon grafiği veya bir navigasyon grafiğinin hedefi olabilen bir ViewModelStoreOwner’a scope edilirler. ViewModel scope‘ları hakkında daha fazla bilgi için dokümantasyonu inceleyebilirsiniz. O halde ViewModel, UI state için doğruluk kaynağı ve en düşük ortak atadır. Screen UI state . Yukarıdaki tanımlara göre, ekran UI state’i business rules uygulanarak üretilir. Ekran seviyesi state holder’ın bundan sorumlu olduğu göz önüne alındığında, bu, ekran UI state’inin tipik olarak ekran seviyesi state holder’da, bu durumda bir ViewModel’de toplandığı anlamına gelir. Bir sohbet uygulamasının ConversationViewModel’ini ve bu modelin ekran UI state‘ini ve bunu değiştirmeye yönelik olayları nasıl ortaya çıkardığını düşünün: . class ConversationViewModel( channelId: String, messagesRepository: MessagesRepository ) : ViewModel() { val messages = messagesRepository .getLatestMessages(channelId) .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = emptyList() ) // Business logic fun sendMessage(message: Message) { /* ... */ } } . Composable’lar ViewModel’de toplanan ekran UI state’ini kullanır. Business logic’e erişim sağlamak için ViewModel instance’ını ekran düzeyindeki composable’larınıza enjekte etmelisiniz. Not: ViewModel instance’larını diğer composable’lara aktarmamalısınız. Daha fazla bilgi için Architecture state holders belgelerine bakın. Aşağıda, ekran düzeyinde bir composable’da kullanılan bir ViewModel örneği yer almaktadır. Burada, Composable ConversationScreen(), ViewModel’de hoist edilen ekran UI state’ini tüketir: . @Composable private fun ConversationScreen( conversationViewModel: ConversationViewModel = viewModel() ) { val messages by conversationViewModel.messages.collectAsStateWithLifecycle() ConversationScreen( messages = messages, onSendMessage = { message: Message -&gt; conversationViewModel.sendMessage(message) } ) } @Composable private fun ConversationScreen( messages: List&lt;Message&gt;, onSendMessage: (Message) -&gt; Unit ) { MessagesList(messages, onSendMessage) /* ... */ } . Not: viewModel() fonksiyonunu kullanmak için build.gradle dosyanıza androidx.lifecycle:lifecycle-viewmodel-compose bağımlılığını ekleyin. Compose’daki diğer kütüphanelerle çalışma belgelerimizde bu fonksiyon hakkında daha fazla bilgi edinin. Not: ViewModel’ler sistem tarafından başlatılan süreç yeniden oluşturulduktan sonra korumak istediğiniz state içeriyorsa, bunu kalıcı hale getirmek için SavedStateHandle kullanın. Daha fazla bilgi için UI State’lerini Kaydetme sayfasına bakın. Property drilling . ” Property drilling”, verilerin iç içe geçmiş birkaç child component üzerinden okunacakları konuma aktarılması anlamına gelir. Compose’da property drilling’in ortaya çıkabileceği tipik bir örnek, ekran seviyesi state holder’ı en üst seviyeye enjekte ettiğinizde ve state ve event’leri child composable’lara geçirdiğinizde ortaya çıkar. Bu durum ayrıca composable fonksiyon imzalarının overload’na neden olabilir. Event’leri ayrı lambda parametreleri olarak göstermek fonksiyon imzasını overload edebilecek olsa da, composable fonksiyon sorumluluklarının ne olduğunun görünürlüğünü maksimize eder. Bir bakışta ne yaptığını görebilirsiniz. Property drilling, state ve event’leri tek bir yerde kapsüllemek için sarmalayıcı sınıflar oluşturmak yerine tercih edilir çünkü bu, composable sorumlulukların görünürlüğünü azaltır. Sarmalayıcı sınıflara sahip olmadığınızda, composable’lara yalnızca ihtiyaç duydukları parametreleri aktarma olasılığınız da artar ki bu da en iyi pratiktir. Bu event’ler navigasyon event’leri ise aynı en iyi pratik geçerlidir, navigasyon dokümanlarında bu konuda daha fazla bilgi edinebilirsiniz. Bir performans sorunu tespit ettiyseniz, state’in okunmasını ertelemeyi de seçebilirsiniz. Daha fazla bilgi edinmek için performans dokümanlarına göz atabilirsiniz. UI element state . UI öğesi state’ini, okuması veya yazması gereken business logic varsa ekran seviyesi state holder’a hoist edebilirsiniz. Bir sohbet uygulaması örneğine devam edersek, kullanıcı @ ve bir ipucu yazdığında uygulama bir grup sohbetinde kullanıcı önerilerini görüntüler. Bu öneriler data katmanından gelir ve kullanıcı önerilerinin bir listesini hesaplama mantığı business logic olarak kabul edilir. Özellik şu şekilde görünür: . Şekil 7. Kullanıcı @ ve bir ipucu yazdığında bir grup sohbetinde kullanıcı önerilerini görüntüleyen özellik . Bu özelliği uygulayan ViewModel aşağıdaki gibi görünecektir: . class ConversationViewModel(/*...*/) : ViewModel() { // Hoisted state var inputMessage by mutableStateOf(\"\") private set val suggestions: StateFlow&lt;List&lt;Suggestion&gt;&gt; = snapshotFlow { inputMessage } .filter { hasSocialHandleHint(it) } .mapLatest { getHandle(it) } .mapLatest { repository.getSuggestions(it) } .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = emptyList() ) fun updateInput(newInput: String) { inputMessage = newInput } } . inputMessage, TextField state’ini tutan bir değişkendir. Kullanıcı her yeni girdi girdiğinde, uygulama öneriler üretmek için business logic’i çağırır. Not: Bu değişken, şu anda kullanıcı önerileri üretmek için ihtiyaç duyulduğu gibi business logic için gerekli olmasaydı, ekran seviyesi state holder hoist edilmemeliydi. Tanımlanmalı ve UI’da, ona ihtiyaç duyan composable fonksiyona daha yakın bir yerde saklanmalıdır. suggestions ekran UI state’idir ve StateFlow’dan collect edilerek Compose UI`dan tüketilir. Not: Ekran düzeyinde bir composable’ın hem business logic’e erişim sağlayan bir ViewModel’e hem de UI logic’ini ve UI elementlerinin state’ini yöneten düz bir state holder sınıfına sahip olması mümkündür. Caveat . Bazı Compose UI öğesi state’leri için ViewModel’e hoisting işlemi özel hususlar gerektirebilir. Örneğin, Compose UI öğelerinin bazı state holder’ları, state’i değiştirmek için metotlar ortaya koyar. Bunlardan bazıları animasyonları tetikleyen suspend fonksiyonları olabilir. Bu suspend fonksiyonları, Composition’a scope edilmemiş bir CoroutineScope‘dan çağırılırsa exception fırlatabilir. Diyelim ki uygulama drawer’ının içeriği dinamik ve kapandıktan sonra data katmanından getirip yenilemeniz gerekiyor. Drawer state’ini ViewModel’e hoist etmelisiniz, böylece state sahibinden bu öğe üzerinde hem UI hem de business logic’i çağırabilirsiniz. Ancak, Compose UI’den viewModelScope kullanarak DrawerState‘in close() metodunu çağırmak, “bu CoroutineContext‘te bir MonotonicFrameClock mevcut değil” şeklinde bir mesajla IllegalStateException türünde bir çalışma zamanı exception’ına neden olur. Bunu düzeltmek için Composition’a scope edilmiş bir CoroutineScope kullanın. CoroutineContext’te suspend fonksiyonlarının çalışması için gerekli olan bir MonotonicFrameClock sağlar. Uyarı: Compose UI öğesi state’inden açığa çıkan ve animasyonları tetikleyen bazı suspend fonksiyonlarının çağrılması, Composition’a scope edilmemiş bir CoroutineScope’tan çağrılırsa exception atar. Örneğin, LazyListState.animateScrollTo() ve DrawerState.close(). Bu çökmeyi düzeltmek için ViewModel’deki coroutine’in CoroutineContext’ini Composition’a scopelanmış bir CoroutineContext ile değiştirin. Şöyle görünebilir: . class ConversationViewModel(/*...*/) : ViewModel() { val drawerState = DrawerState(initialValue = DrawerValue.Closed) private val _drawerContent = MutableStateFlow(DrawerContent.Empty) val drawerContent: StateFlow&lt;DrawerContent&gt; = _drawerContent.asStateFlow() fun closeDrawer(uiScope: CoroutineScope) { viewModelScope.launch { withContext(uiScope.coroutineContext) { // Default context yerine kullanın drawerState.close() } // Drawer içeriğini getirme ve state'i güncelleme _drawerContent.update { content } } } } // in Compose @Composable private fun ConversationScreen( conversationViewModel: ConversationViewModel = viewModel() ) { val scope = rememberCoroutineScope() ConversationScreen(onCloseDrawer = { conversationViewModel.closeDrawer(uiScope = scope) }) } . ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#business-logic",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#business-logic"
  },"339": {
    "doc": "Where to Hoist State",
    "title": "Learn more",
    "content": "State ve Jetpack Compose hakkında daha fazla bilgi edinmek için aşağıdaki ek kaynaklara başvurun. Samples . | Jetnews sample | Jetchat sample | Now in Android App | . Codelabs . | Using State in Jetpack Compose Videos . | State holders and state production in the UI Layer | . ",
    "url": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#learn-more",
    
    "relUrl": "/docs/jetpack-compose/ui-architecture/managing-state/where-to-hoist-state/#learn-more"
  },"340": {
    "doc": "Why Compose",
    "title": "Why Compose",
    "content": "Jetpack Compose, Android’in yerel kullanıcı arayüzü oluşturmaya yönelik modern araç setidir. Android’de UI geliştirmeyi basitleştirir ve hızlandırır, uygulamalarınızı daha az kod, güçlü araçlar ve sezgisel Kotlin API’leri ile hayata geçirir. Android kullanıcı arayüzü oluşturmayı daha hızlı ve kolay hale getirir. Compose’u oluştururken, tüm bu avantajları ilk elden deneyimleyen ve bazı çıkarımlarını bizimle paylaşan farklı ortaklarla çalıştık. ",
    "url": "/docs/jetpack-compose/introduction/why-compose/",
    
    "relUrl": "/docs/jetpack-compose/introduction/why-compose/"
  },"341": {
    "doc": "Why Compose",
    "title": "Less Code",
    "content": "Daha az kod yazmak geliştirmenin tüm aşamalarını etkiler: bir yazar olarak, daha az test ve hata ayıklama ve daha az hata olasılığı ile elinizdeki soruna odaklanabilirsiniz; bir gözden geçiren veya bakımcı olarak okumak, anlamak, gözden geçirmek ve bakımını yapmak için daha az kodunuz olur. Compose, Android View sistemini kullanmaya kıyasla daha az kodla daha fazlasını yapmanızı sağlar: Butonlar, listeler veya animasyon - ne oluşturmanız gerekiyorsa, artık yazmanız gereken daha az kod var. İşte iş ortaklarımızdan bazılarının söyledikleri: . | “Aynı Button sınıfı için [kod] 10 kat daha küçüktü.” (Twitter) | “Ayrıca, ekranlarımızın çoğunun sahip olduğu RecyclerView ile oluşturulmuş herhangi bir ekran için de önemli bir azalma var.” (Monzo) | “Uygulamamızda listeler veya animasyonlar oluşturmak için ne kadar az satır gerektiğini görmekten çok memnun olduk. Feature başına daha az kod satırı yazıyoruz, bu da müşterilerimize değer sunmaya daha fazla odaklanmamızı sağlıyor.” (Cuvva) | Yazdığınız kodun Kotlin ve XML arasında bölünmesi yerine yalnızca Kotlin’de yazılması: “Kotlin ve XML arasında gidip gelmek yerine, hepsi aynı dilde ve genellikle aynı dosyada yazıldığında kodun izini sürmek çok daha kolay” (Monzo) | Compose ile yazılan kod basittir ve ne inşa ederseniz edin bakımı kolaydır. “Compose’un layout sistemi kavramsal olarak daha basit, bu yüzden akıl yürütmek daha kolay. Karmaşık bileşenlerin kodunu okumak da daha kolay.” (Square) ",
    "url": "/docs/jetpack-compose/introduction/why-compose/#less-code",
    
    "relUrl": "/docs/jetpack-compose/introduction/why-compose/#less-code"
  },"342": {
    "doc": "Why Compose",
    "title": "Intuitive",
    "content": "Compose deklaratif bir API kullanır, yani tek yapmanız gereken kullanıcı arayüzünüzü tanımlamaktır - Compose gerisini halleder. API’ler sezgiseldir - keşfetmesi ve kullanması kolaydır: “Tema katmanımız çok daha sezgisel ve okunaklı. Birden fazla katmanlı tema kaplaması aracılığıyla nitelik tanımları ve atamalardan sorumlu olan birden fazla XML dosyasına yayılan işleri tek bir Kotlin dosyasında gerçekleştirebildik.” (Twitter) . | . Compose ile belirli bir aktivite veya fragmenta bağlı olmayan küçük, stateless bileşenler oluşturursunuz. Bu da onların yeniden kullanımını ve test edilmesini kolaylaştırır: “Kendimize, stateless, kullanımı ve bakımı kolay ve uygulaması/genişletmesi/özelleştirmesi sezgisel olan yeni bir UI bileşenleri seti sunma hedefi koyduk. Compose bu konuda bizim için gerçekten sağlam bir yanıt sağladı.” (Twitter) . Compose’da state açıktır ve composable’a aktarılır. Bu şekilde, state için tek bir doğruluk kaynağı vardır, bu da onu kapsüllenmiş ve ayrıştırılmış hale getirir. Ardından, uygulama state’i değiştikçe kullanıcı arayüzünüz otomatik olarak güncellenir. “Bir şey hakkında akıl yürütürken kafanızda tutmanız gereken daha az şey ve kontrolünüz dışında olan veya yeterince anlaşılmayan daha az davranış vardır” (Cuvva) . ",
    "url": "/docs/jetpack-compose/introduction/why-compose/#intuitive",
    
    "relUrl": "/docs/jetpack-compose/introduction/why-compose/#intuitive"
  },"343": {
    "doc": "Why Compose",
    "title": "Accelerate development",
    "content": "Compose mevcut tüm kodlarınızla uyumludur: Compose kodunu View’lardan ve View’ları Compose’dan çağırabilirsiniz. Navigation, ViewModel ve Kotlin coroutines gibi en yaygın kütüphaneler Compose ile çalışır, böylece istediğiniz zaman ve istediğiniz yerde kullanmaya başlayabilirsiniz. “Birlikte çalışabilirlik, Compose’u entegre etmeye başladığımız yerdi ve bulduğumuz şey ‘sadece çalıştığı’ oldu. Aydınlık ve karanlık mod gibi şeyler hakkında düşünmek zorunda olmadığımızı ve tüm deneyimin inanılmaz derecede sorunsuz olduğunu gördük.” (Cuvva) . Canlı önizleme gibi özelliklerle tam Android Studio desteğini kullanarak kodu daha hızlı yineleyebilir ve gönderebilirsiniz: “Android Studio’daki önizlemeler büyük bir zaman tasarrufu sağladı. Birden fazla önizleme oluşturabilmek de bize zaman kazandırıyor. Genellikle bir kullanıcı arayüzü bileşenini farklı statelerde veya farklı ayarlarla kontrol etmemiz gerekiyor - hata state’leri veya farklı bir yazı tipi boyutu vb. gibi. Birden fazla önizleme oluşturabildiğimiz için bunu kolayca kontrol edebiliyoruz.” (Square) . ",
    "url": "/docs/jetpack-compose/introduction/why-compose/#accelerate-development",
    
    "relUrl": "/docs/jetpack-compose/introduction/why-compose/#accelerate-development"
  },"344": {
    "doc": "Why Compose",
    "title": "Powerful",
    "content": "Compose, Android platform API’lerine doğrudan erişim ve Materyal Tasarım, Koyu tema, animasyonlar ve daha fazlası için yerleşik destek ile güzel uygulamalar oluşturmanıza olanak tanır: “Compose ayrıca deklaratif kullanıcı arayüzünden daha fazlasını çözdü - erişilebilirlik apileri, layout, her türlü şey geliştirildi. Yapmak istediğiniz şey ile onu gerçekten yapmak arasında daha az adım var” (Square). Compose ile animasyonlar aracılığıyla uygulamalarınıza hareket ve hayat katmak hızlı ve kolay bir şekilde uygulanabiliyor: “Compose’a animasyon eklemek o kadar kolay ki renk/boyut/yükseklik değişiklikleri gibi şeyleri canlandırmamak için çok az neden var” (Monzo), “özel bir şey gerektirmeden animasyon yapabilirsiniz - statik bir ekran göstermekten farklı değil” (Square). İster Material Design ile ister kendi tasarım sisteminizle oluşturuyor olun, Compose size istediğiniz tasarımı uygulama esnekliği sağlar: “Material Design’ın temelden ayrılmış olması, genellikle Material’dan farklı tasarım gereksinimleri gerektiren kendi tasarım sistemimizi oluştururken bizim için gerçekten yararlı oldu.” (Square) . Twitter, Square, Monzo ve Cuvva’nın Compose’u nasıl kullandığı hakkında daha fazla bilgi edinmek için derinlemesine örnek olay incelemelerine göz atın. ",
    "url": "/docs/jetpack-compose/introduction/why-compose/#powerful",
    
    "relUrl": "/docs/jetpack-compose/introduction/why-compose/#powerful"
  },"345": {
    "doc": "Work with observable data objects",
    "title": "Work with observable data objects",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/work-with-obserable-data-objects/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/work-with-obserable-data-objects/"
  },"346": {
    "doc": "Working with the app",
    "title": "Working with the app",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/working-with-the-app/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/working-with-the-app/"
  },"347": {
    "doc": "WorkManager",
    "title": "WorkManager",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/workmanager/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/workmanager/"
  }
}
